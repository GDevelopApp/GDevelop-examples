{
  "firstLayout": "",
  "gdVersion": {
    "build": 231,
    "major": 5,
    "minor": 5,
    "revision": 0
  },
  "properties": {
    "adaptGameResolutionAtRuntime": true,
    "antialiasingMode": "MSAA",
    "antialisingEnabledOnMobile": false,
    "folderProject": false,
    "orientation": "landscape",
    "packageName": "com.example.gamename",
    "pixelsRounding": false,
    "projectUuid": "b79351be-4c9d-4008-a801-174f6eeb0c19",
    "scaleMode": "linear",
    "sizeOnStartupMode": "adaptWidth",
    "templateSlug": "",
    "version": "1.0.0",
    "name": "3d-endless-terrain",
    "description": "",
    "author": "",
    "windowWidth": 1280,
    "windowHeight": 720,
    "latestCompilationDirectory": "",
    "maxFPS": 60,
    "minFPS": 20,
    "verticalSync": false,
    "platformSpecificAssets": {},
    "loadingScreen": {
      "backgroundColor": 0,
      "backgroundFadeInDuration": 0.2,
      "backgroundImageResourceName": "",
      "gdevelopLogoStyle": "light",
      "logoAndProgressFadeInDuration": 0.2,
      "logoAndProgressLogoFadeInDelay": 0,
      "minDuration": 1.5,
      "progressBarColor": 16777215,
      "progressBarHeight": 20,
      "progressBarMaxWidth": 200,
      "progressBarMinWidth": 40,
      "progressBarWidthPercent": 30,
      "showGDevelopSplash": true,
      "showProgressBar": true
    },
    "watermark": {
      "placement": "bottom-left",
      "showWatermark": true
    },
    "authorIds": [],
    "authorUsernames": [],
    "categories": [],
    "playableDevices": [],
    "extensionProperties": [],
    "platforms": [
      {
        "name": "GDevelop JS platform"
      }
    ],
    "currentPlatform": "GDevelop JS platform"
  },
  "resources": {
    "resources": [],
    "resourceFolders": []
  },
  "objects": [],
  "objectsFolderStructure": {
    "folderName": "__ROOT"
  },
  "objectsGroups": [],
  "variables": [],
  "layouts": [
    {
      "b": 54,
      "disableInputWhenNotFocused": true,
      "mangledName": "Untitled_32scene",
      "name": "Untitled scene",
      "r": 54,
      "standardSortMethod": true,
      "stopSoundsOnStartup": true,
      "title": "",
      "v": 54,
      "uiSettings": {
        "grid": false,
        "gridType": "rectangular",
        "gridWidth": 32,
        "gridHeight": 32,
        "gridOffsetX": 0,
        "gridOffsetY": 0,
        "gridColor": 10401023,
        "gridAlpha": 0.8,
        "snap": false,
        "zoomFactor": 0.546875,
        "windowMask": false
      },
      "objectsGroups": [],
      "variables": [],
      "instances": [
        {
          "angle": 0,
          "customSize": true,
          "depth": 64,
          "height": 512,
          "layer": "",
          "name": "NewHeightMap3D",
          "persistentUuid": "b6d0adfb-1257-4f2d-9952-600caec2b280",
          "width": 512,
          "x": 348,
          "y": 77,
          "zOrder": 1,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        }
      ],
      "objects": [
        {
          "assetStoreId": "",
          "name": "NewHeightMap3D",
          "type": "HeightMap3D::HeightMap3D",
          "variant": "",
          "variables": [],
          "effects": [],
          "behaviors": [],
          "content": {}
        }
      ],
      "objectsFolderStructure": {
        "folderName": "__ROOT",
        "children": [
          {
            "objectName": "NewHeightMap3D"
          }
        ]
      },
      "events": [
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "DepartScene"
              },
              "parameters": [
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "Noise::Create"
              },
              "parameters": [
                "",
                "\"Terrain\"",
                ""
              ]
            },
            {
              "type": {
                "value": "Noise::SetFrequency"
              },
              "parameters": [
                "",
                "0.05",
                "\"Terrain\"",
                ""
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Repeat",
                  "repeatExpression": "65",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "IndexX",
                        "=",
                        "0"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Repeat",
                      "repeatExpression": "65",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "HeightMap3D::HeightMap3D::SetGridValue"
                          },
                          "parameters": [
                            "NewHeightMap3D",
                            "=",
                            "100 * Noise::Noise2d(\"Terrain\", IndexX, IndexY)",
                            "IndexX",
                            "IndexY",
                            ""
                          ]
                        },
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "IndexX",
                            "+",
                            "1"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "SetNumberVariable"
                          },
                          "parameters": [
                            "IndexY",
                            "+",
                            "1"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ],
              "variables": [
                {
                  "name": "IndexX",
                  "type": "number",
                  "value": 0
                },
                {
                  "name": "IndexY",
                  "type": "number",
                  "value": 0
                }
              ]
            }
          ]
        }
      ],
      "layers": [
        {
          "ambientLightColorB": 200,
          "ambientLightColorG": 200,
          "ambientLightColorR": 200,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 3,
          "cameraType": "",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": [
            {
              "effectType": "Scene3D::HemisphereLight",
              "name": "3D Light",
              "doubleParameters": {
                "elevation": 45,
                "intensity": 1,
                "rotation": 0
              },
              "stringParameters": {
                "groundColor": "64;64;64",
                "skyColor": "255;255;255",
                "top": "Y-"
              },
              "booleanParameters": {}
            }
          ]
        }
      ],
      "behaviorsSharedData": [
        {
          "name": "Flippable",
          "type": "FlippableCapability::FlippableBehavior"
        },
        {
          "name": "Object3D",
          "type": "Scene3D::Base3DBehavior"
        },
        {
          "name": "Resizable",
          "type": "ResizableCapability::ResizableBehavior"
        },
        {
          "name": "Scale",
          "type": "ScalableCapability::ScalableBehavior"
        }
      ]
    }
  ],
  "externalEvents": [],
  "eventsFunctionsExtensions": [
    {
      "author": "",
      "category": "General",
      "extensionNamespace": "",
      "fullName": "3D height map",
      "gdevelopVersion": ">=5.5.222",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXRlcnJhaW4iIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTQsNkwxMC4yNSwxMUwxMy4xLDE0LjhMMTEuNSwxNkM5LjgxLDEzLjc1IDcsMTAgNywxMEwxLDE4SDIzTDE0LDZaIiAvPjwvc3ZnPg==",
      "name": "HeightMap3D",
      "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/10e0a26c0d500830dfe23b94138beb0ef61607ba62bca05a5aa5c849777f1b06_terrain.svg",
      "shortDescription": "A height map in 3D.",
      "version": "0.0.1",
      "description": "",
      "tags": [
        "3d"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__heightMap3DExtension) {",
                "    return;",
                "}",
                "",
                "const vertexColors = [];",
                "",
                "class HeightMap {",
                "    /** @type {gdjs.CustomRuntimeObject} */",
                "    object;",
                "    /** @type {THREE.Mesh} */",
                "    mesh;",
                "",
                "    /** @type {THREE.TypedArray} */",
                "    vertices;",
                "",
                "    /** @type {integer} */",
                "    dimX;",
                "    /** @type {integer} */",
                "    dimY;",
                "",
                "    isDirty = false;",
                "",
                "    /**",
                "     * @param object {gdjs.CustomRuntimeObject}",
                "     * @param dimX {integer}",
                "     * @param dimY {integer}",
                "     */",
                "    constructor(object, dimX, dimY) {",
                "        this.object = object;",
                "        this.dimX = dimX;",
                "        this.dimY = dimY;",
                "        ",
                "        const geometry = new THREE.PlaneGeometry(64, 64, this.dimX - 1, this.dimY - 1);",
                "\t    this.vertices = geometry.attributes.position.array;",
                "        this.mesh = new THREE.Mesh(",
                "            geometry,",
                "            new THREE.MeshStandardMaterial({ metalness: 0 })",
                "        );",
                "        this.mesh.rotation.order = 'ZYX';",
                "        this.mesh.position.x = 32;",
                "        this.mesh.position.y = 32;",
                "        this.mesh.scale.y = -1;",
                "        object.get3DRendererObject().add(this.mesh);",
                "        // // Ensure a forward compatibility when vertexColors will be set to true",
                "        // // in the engine to allow to tint 3D custom objects.",
                "        // vertexColors.length = geometry.attributes.position.count * 3;",
                "        // vertexColors.fill(1);",
                "        // geometry.setAttribute(",
                "        //     'color',",
                "        //     new THREE.BufferAttribute(new Float32Array(vertexColors), 3)",
                "        // );",
                "    }",
                "",
                "    updateIfNeeded() {",
                "        if (this.isDirty) {",
                "            this.isDirty = false;",
                "            this.mesh.geometry.attributes.position.needsUpdate = true;",
                "            this.mesh.geometry.computeVertexNormals();",
                "        }",
                "    }",
                "",
                "    /**",
                "     * @param indexX {integer}",
                "     * @param indexY {integer}",
                "     * @param value {float}",
                "     */",
                "    setGridValue(indexX, indexY, value) {",
                "        this.vertices[2 + 3 * (indexX + indexY * this.dimX)] = value;",
                "        this.isDirty = true;",
                "    }",
                "",
                "    /**",
                "     * @param indexX {integer}",
                "     * @param indexY {integer}",
                "     * @returns {float}",
                "     */",
                "    getGridValue(indexX, indexY) {",
                "        return this.vertices[2 + 3 * (indexX + indexY * this.dimX)];",
                "    }",
                "}",
                "",
                "gdjs.__heightMap3DExtension = {",
                "    HeightMap",
                "};",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": [
        {
          "areaMaxX": 64,
          "areaMaxY": 64,
          "areaMaxZ": 64,
          "areaMinX": 0,
          "areaMinY": 0,
          "areaMinZ": 0,
          "defaultName": "",
          "description": "A height map in 3D.",
          "fullName": "3D height map",
          "is3D": true,
          "isUsingLegacyInstancesRenderer": true,
          "name": "HeightMap3D",
          "objects": [
            {
              "assetStoreId": "",
              "name": "Placeholder",
              "type": "Scene3D::Cube3DObject",
              "variables": [],
              "effects": [],
              "behaviors": [],
              "content": {
                "width": 64,
                "height": 64,
                "depth": 64,
                "enableTextureTransparency": false,
                "facesOrientation": "Y",
                "frontFaceResourceName": "",
                "backFaceResourceName": "",
                "backFaceUpThroughWhichAxisRotation": "X",
                "leftFaceResourceName": "",
                "rightFaceResourceName": "",
                "topFaceResourceName": "",
                "bottomFaceResourceName": "",
                "frontFaceVisible": true,
                "backFaceVisible": true,
                "leftFaceVisible": true,
                "rightFaceVisible": true,
                "topFaceVisible": true,
                "bottomFaceVisible": true,
                "frontFaceResourceRepeat": false,
                "backFaceResourceRepeat": false,
                "leftFaceResourceRepeat": false,
                "rightFaceResourceRepeat": false,
                "topFaceResourceRepeat": false,
                "bottomFaceResourceRepeat": false,
                "materialType": "Basic",
                "tint": "255;255;255"
              }
            }
          ],
          "objectsFolderStructure": {
            "folderName": "__ROOT",
            "children": [
              {
                "objectName": "Placeholder"
              }
            ]
          },
          "objectsGroups": [],
          "layers": [
            {
              "ambientLightColorB": 200,
              "ambientLightColorG": 200,
              "ambientLightColorR": 200,
              "camera3DFarPlaneDistance": 10000,
              "camera3DFieldOfView": 45,
              "camera3DNearPlaneDistance": 3,
              "cameraType": "",
              "followBaseLayerCamera": false,
              "isLightingLayer": false,
              "isLocked": false,
              "name": "",
              "renderingType": "",
              "visibility": true,
              "cameras": [
                {
                  "defaultSize": true,
                  "defaultViewport": true,
                  "height": 0,
                  "viewportBottom": 1,
                  "viewportLeft": 0,
                  "viewportRight": 1,
                  "viewportTop": 0,
                  "width": 0
                }
              ],
              "effects": []
            }
          ],
          "instances": [
            {
              "angle": 0,
              "customSize": false,
              "height": 0,
              "keepRatio": true,
              "layer": "",
              "name": "Placeholder",
              "persistentUuid": "fc9b8b2b-f491-40ae-a136-ad0a5165a09d",
              "width": 0,
              "x": 0,
              "y": 0,
              "zOrder": 1,
              "numberProperties": [],
              "stringProperties": [],
              "initialVariables": []
            }
          ],
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Delete"
                      },
                      "parameters": [
                        "Placeholder",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "HeightMap3D::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */\r",
                    "const object = objects[0];\r",
                    "\r",
                    "const dimX = object._getFieldDimensionX();\r",
                    "const dimY = object._getFieldDimensionY();\r",
                    "\r",
                    "object.__heightMap3DExtension = {};\r",
                    "object.__heightMap3DExtension.heightMap = new gdjs.__heightMap3DExtension.HeightMap(object, dimX, dimY);\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "HeightMap3D::HeightMap3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "doStepPostEvents",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */\r",
                    "const object = objects[0];\r",
                    "\r",
                    "object.__heightMap3DExtension.heightMap.updateIfNeeded();\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "HeightMap3D::HeightMap3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The field value at a grid point.",
              "fullName": "Grid value",
              "functionType": "ExpressionAndCondition",
              "name": "GridValue",
              "sentence": "the field value at _PARAM1_ ; _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */",
                    "const object = objects[0];",
                    "",
                    "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                    "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                    "",
                    "eventsFunctionContext.returnValue = object.__heightMap3DExtension.heightMap.getGridValue(indexX, indexY);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "HeightMap3D::HeightMap3D",
                  "type": "object"
                },
                {
                  "description": "X grid index",
                  "name": "IndexX",
                  "type": "expression"
                },
                {
                  "description": "Y grid index",
                  "name": "IndexY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "ActionWithOperator",
              "getterName": "GridValue",
              "name": "SetGridValue",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */",
                    "const object = objects[0];",
                    "",
                    "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                    "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "object.__heightMap3DExtension.heightMap.setGridValue(indexX, indexY, value);",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "HeightMap3D::HeightMap3D",
                  "type": "object"
                },
                {
                  "description": "X grid index",
                  "name": "IndexX",
                  "type": "expression"
                },
                {
                  "description": "Y grid index",
                  "name": "IndexY",
                  "type": "expression"
                },
                {
                  "description": "Field value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "65",
              "type": "Number",
              "label": "Field dimension X",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "FieldDimensionX"
            },
            {
              "value": "65",
              "type": "Number",
              "label": "Field dimension Y",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "FieldDimensionY"
            }
          ],
          "variants": []
        }
      ]
    },
    {
      "author": "Add00",
      "category": "Game mechanic",
      "extensionNamespace": "",
      "fullName": "Noise generator",
      "gdevelopVersion": ">=5.5.222",
      "helpPath": "/tutorials/procedural-generation",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXNwcmlua2xlciIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0xMSA3SDEzVjlIMTFWN001IDIySDlWMTBINVYyMk0xNCAxMUgxNlY5SDE0VjExTTE3IDEwSDE5VjhIMTdWMTBNMTcgNVY3SDE5VjVIMTdNMTQgOEgxNlY2SDE0VjhNMTcgMTNIMTlWMTFIMTdWMTNNNSA3SDUuMzNMNiA5SDhMOC42NyA3SDlWNkg1VjdaIiAvPjwvc3ZnPg==",
      "name": "Noise",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/sprinkler.svg",
      "shortDescription": "Generate noise values for procedural generation.",
      "version": "2.1.4",
      "description": [
        "Noise can be useful for many procedural generation cases such as:",
        "- Terrain, top down or side view ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-island-generator))",
        "- Object positioning (tree, stars...)",
        "- Curves (roads, rivers...)",
        "- Textures (fog, milky way...)",
        "- Screen shake",
        "- Many other things",
        "",
        "This extension contains expressions to generate Simplex noise values in 1, 2, 3 and 4 dimensions. A *\"seed\"* allows to generate the same world again later on instead of having to save the whole generated world.",
        "",
        "Version 2.0.0 compatibility break:",
        "- Seeds doesn't give the same result as with version 1.x.x"
      ],
      "origin": {
        "identifier": "Noise",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "perlin noise",
        "simplex noise",
        "procedural generation"
      ],
      "authorIds": [
        "AlZ3D1xkH0QDao7T37VZZUeYNpn1",
        "gqDaZjCfevOOxBYkK6zlhtZnXCg1",
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onFirstSceneLoaded",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs._extensionNoise) {",
                "    return;",
                "}",
                "",
                "/** Noise generator manager. */",
                "class NoiseManager {",
                "    /**",
                "     * Create the manager of noise generators.",
                "     */",
                "    constructor() {",
                "        this.seed = gdjs.randomInRange(1, Number.MAX_SAFE_INTEGER);",
                "        /** @type {Map<string, NoiseGenerator>} */",
                "        this.generators = new Map();",
                "    }",
                "",
                "    /**",
                "     * @param name {string}",
                "     * @return {NoiseGenerator}",
                "     */",
                "    getGenerator(name) {",
                "        let generator = this.generators.get(name);",
                "        if (!generator) {",
                "            generator = new NoiseGenerator(name + this.seed);",
                "            this.generators.set(name, generator);",
                "        }",
                "        return generator;",
                "    }",
                "",
                "    /**",
                "     * @param seed {number}",
                "     */",
                "    setSeed(seed) {",
                "        this.seed = seed;",
                "        this.generators.forEach(generator => generator.setSeed(name + this.seed));",
                "    }",
                "",
                "    /**",
                "     * @param name {string}",
                "     */",
                "    deleteGenerator(name) {",
                "        this.generators.delete(name);",
                "    }",
                "",
                "    /**",
                "     */",
                "    deleteAllGenerators() {",
                "        this.generators.clear();",
                "    }",
                "}",
                "",
                "/** Noise generator with octaves. */",
                "class NoiseGenerator {",
                "    /**",
                "     * Create a noise generator with a seed.",
                "     * @param seed {string}",
                "     */",
                "    constructor(seed) {",
                "        this.simplexNoise = new SimplexNoise(seed);",
                "        this.frequency = 1;",
                "        this.octaves = 1;",
                "        this.persistence = 0.5;",
                "        this.lacunarity = 2;",
                "        this.xLoopPeriod = 0;",
                "        this.yLoopPeriod = 0;",
                "    }",
                "",
                "    /**",
                "     * @param seed {string}",
                "     */",
                "    setSeed(seed) {",
                "        this.simplexNoise = new SimplexNoise(seed);",
                "    }",
                "",
                "    /**",
                "     * @param x {float}",
                "     * @param y {float}",
                "     * @param z {float} optionnal",
                "     * @param w {float} optionnal",
                "     * @return {float}",
                "     */",
                "    noise(x, y, z, w) {",
                "        if (this.xLoopPeriod && this.yLoopPeriod) {",
                "            const circleRatioX = 2 * Math.PI / this.xLoopPeriod;",
                "            const circleRatioY = 2 * Math.PI / this.yLoopPeriod;",
                "            const angleX = circleRatioX * x;",
                "            const angleY = circleRatioY * y;",
                "            x = Math.cos(angleX) / circleRatioX;",
                "            y = Math.sin(angleX) / circleRatioX;",
                "            z = Math.cos(angleY) / circleRatioY;",
                "            w = Math.sin(angleY) / circleRatioY;",
                "        }",
                "        else if (this.xLoopPeriod) {",
                "            const circleRatio = 2 * Math.PI / this.xLoopPeriod;",
                "            const angleX = circleRatio * x;",
                "            w = z;",
                "            z = y;",
                "            x = Math.cos(angleX) / circleRatio;",
                "            y = Math.sin(angleX) / circleRatio;",
                "        }",
                "        else if (this.yLoopPeriod) {",
                "            const circleRatio = 2 * Math.PI / this.xLoopPeriod;",
                "            const angleX = circleRatio * x;",
                "            w = z;",
                "            // Make the circle perimeter equals to the looping period",
                "            // to keep the same perceived frequency with or without looping.",
                "            y = Math.cos(angleX) / circleRatio;",
                "            z = Math.sin(angleX) / circleRatio;",
                "        }",
                "        let noiseFunction = this.simplexNoise.noise4D.bind(this.simplexNoise);",
                "        if (z === undefined) {",
                "            noiseFunction = this.simplexNoise.noise2D.bind(this.simplexNoise);",
                "        }",
                "        else if (w === undefined) {",
                "            noiseFunction = this.simplexNoise.noise3D.bind(this.simplexNoise);",
                "        }",
                "        let frequency = this.frequency;",
                "        let noiseSum = 0;",
                "        let amplitudeSum = 0;",
                "        let amplitude = 1;",
                "        for (let i = 0; i < this.octaves; i++) {",
                "            noiseSum += noiseFunction(x * frequency, y * frequency, z * frequency, w * frequency) * amplitude;",
                "            amplitudeSum += Math.abs(amplitude);",
                "            amplitude *= this.persistence;",
                "            frequency *= this.lacunarity;",
                "        }",
                "        return noiseSum / amplitudeSum;",
                "    }",
                "}",
                "",
                "/*",
                "A fast javascript implementation of simplex noise by Jonas Wagner",
                "https://github.com/jwagner/simplex-noise.js",
                "",
                "Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.",
                "Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).",
                "With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).",
                "Better rank ordering method by Stefan Gustavson in 2012.",
                "",
                " Copyright (c) 2021 Jonas Wagner",
                "",
                " Permission is hereby granted, free of charge, to any person obtaining a copy",
                " of this software and associated documentation files (the \"Software\"), to deal",
                " in the Software without restriction, including without limitation the rights",
                " to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                " copies of the Software, and to permit persons to whom the Software is",
                " furnished to do so, subject to the following conditions:",
                "",
                " The above copyright notice and this permission notice shall be included in all",
                " copies or substantial portions of the Software.",
                "",
                " THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                " OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
                " SOFTWARE.",
                " */",
                "",
                "const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);",
                "const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;",
                "const F3 = 1.0 / 3.0;",
                "const G3 = 1.0 / 6.0;",
                "const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;",
                "const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;",
                "const grad3 = new Float32Array([1, 1, 0,",
                "    -1, 1, 0,",
                "    1, -1, 0,",
                "    -1, -1, 0,",
                "    1, 0, 1,",
                "    -1, 0, 1,",
                "    1, 0, -1,",
                "    -1, 0, -1,",
                "    0, 1, 1,",
                "    0, -1, 1,",
                "    0, 1, -1,",
                "    0, -1, -1]);",
                "const grad4 = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,",
                "    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,",
                "    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,",
                "    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,",
                "    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,",
                "    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,",
                "    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,",
                "    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);",
                "",
                "",
                "/**",
                " * Builds a random permutation table.",
                " * This is exported only for (internal) testing purposes.",
                " * Do not rely on this export.",
                " * @param {() => number} random",
                " * @private",
                " */",
                "function buildPermutationTable(random) {",
                "    const p = new Uint8Array(256);",
                "    for (let i = 0; i < 256; i++) {",
                "        p[i] = i;",
                "    }",
                "    for (let i = 0; i < 255; i++) {",
                "        const r = i + ~~(random() * (256 - i));",
                "        const aux = p[i];",
                "        p[i] = p[r];",
                "        p[r] = aux;",
                "    }",
                "    return p;",
                "}",
                "",
                "/*",
                "The ALEA PRNG and masher code used by simplex-noise.js",
                "is based on code by Johannes BaagÃ¸e, modified by Jonas Wagner.",
                "See alea.md for the full license.",
                "@param {string|number} seed",
                "*/",
                "function alea(seed) {",
                "    let s0 = 0;",
                "    let s1 = 0;",
                "    let s2 = 0;",
                "    let c = 1;",
                "    const mash = masher();",
                "    s0 = mash(' ');",
                "    s1 = mash(' ');",
                "    s2 = mash(' ');",
                "    s0 -= mash(seed);",
                "    if (s0 < 0) {",
                "        s0 += 1;",
                "    }",
                "    s1 -= mash(seed);",
                "    if (s1 < 0) {",
                "        s1 += 1;",
                "    }",
                "    s2 -= mash(seed);",
                "    if (s2 < 0) {",
                "        s2 += 1;",
                "    }",
                "    return function () {",
                "        const t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32",
                "        s0 = s1;",
                "        s1 = s2;",
                "        return s2 = t - (c = t | 0);",
                "    };",
                "}",
                "",
                "function masher() {",
                "    let n = 0xefc8249d;",
                "    return function (data) {",
                "        data = data.toString();",
                "        for (let i = 0; i < data.length; i++) {",
                "            n += data.charCodeAt(i);",
                "            let h = 0.02519603282416938 * n;",
                "            n = h >>> 0;",
                "            h -= n;",
                "            h *= n;",
                "            n = h >>> 0;",
                "            h -= n;",
                "            n += h * 0x100000000; // 2^32",
                "        }",
                "        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32",
                "    };",
                "}",
                "",
                "/** Deterministic simplex noise generator suitable for 2D, 3D and 4D spaces. */",
                "class SimplexNoise {",
                "    /**",
                "     * Creates a new `SimplexNoise` instance.",
                "     * This involves some setup. You can save a few cpu cycles by reusing the same instance.",
                "     * @param {(() => number)|string|number} randomOrSeed A random number generator or a seed (string|number).",
                "     * Defaults to Math.random (random irreproducible initialization).",
                "     */",
                "    constructor(randomOrSeed) {",
                "        if (randomOrSeed === void 0) { randomOrSeed = Math.random; }",
                "        const random = typeof randomOrSeed == 'function' ? randomOrSeed : alea(randomOrSeed);",
                "        this.p = buildPermutationTable(random);",
                "        this.perm = new Uint8Array(512);",
                "        this.permMod12 = new Uint8Array(512);",
                "        for (let i = 0; i < 512; i++) {",
                "            this.perm[i] = this.p[i & 255];",
                "            this.permMod12[i] = this.perm[i] % 12;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Samples the noise field in 2 dimensions",
                "     * @param {number} x",
                "     * @param {number} y",
                "     * @returns a number in the interval [-1, 1]",
                "     */",
                "    noise2D(x, y) {",
                "        const permMod12 = this.permMod12;",
                "        const perm = this.perm;",
                "        let n0 = 0; // Noise contributions from the three corners",
                "        let n1 = 0;",
                "        let n2 = 0;",
                "        // Skew the input space to determine which simplex cell we're in",
                "        const s = (x + y) * F2; // Hairy factor for 2D",
                "        const i = Math.floor(x + s);",
                "        const j = Math.floor(y + s);",
                "        const t = (i + j) * G2;",
                "        const X0 = i - t; // Unskew the cell origin back to (x,y) space",
                "        const Y0 = j - t;",
                "        const x0 = x - X0; // The x,y distances from the cell origin",
                "        const y0 = y - Y0;",
                "        // For the 2D case, the simplex shape is an equilateral triangle.",
                "        // Determine which simplex we are in.",
                "        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords",
                "        if (x0 > y0) {",
                "            i1 = 1;",
                "            j1 = 0;",
                "        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)",
                "        else {",
                "            i1 = 0;",
                "            j1 = 1;",
                "        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)",
                "        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and",
                "        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where",
                "        // c = (3-sqrt(3))/6",
                "        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords",
                "        const y1 = y0 - j1 + G2;",
                "        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords",
                "        const y2 = y0 - 1.0 + 2.0 * G2;",
                "        // Work out the hashed gradient indices of the three simplex corners",
                "        const ii = i & 255;",
                "        const jj = j & 255;",
                "        // Calculate the contribution from the three corners",
                "        let t0 = 0.5 - x0 * x0 - y0 * y0;",
                "        if (t0 >= 0) {",
                "            const gi0 = permMod12[ii + perm[jj]] * 3;",
                "            t0 *= t0;",
                "            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient",
                "        }",
                "        let t1 = 0.5 - x1 * x1 - y1 * y1;",
                "        if (t1 >= 0) {",
                "            const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;",
                "            t1 *= t1;",
                "            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);",
                "        }",
                "        let t2 = 0.5 - x2 * x2 - y2 * y2;",
                "        if (t2 >= 0) {",
                "            const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;",
                "            t2 *= t2;",
                "            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);",
                "        }",
                "        // Add contributions from each corner to get the final noise value.",
                "        // The result is scaled to return values in the interval [-1,1].",
                "        return 70.0 * (n0 + n1 + n2);",
                "    }",
                "",
                "    /**",
                "     * Samples the noise field in 3 dimensions",
                "     * @param {number} x",
                "     * @param {number} y",
                "     * @param {number} z",
                "     * @returns a number in the interval [-1, 1]",
                "     */",
                "    noise3D(x, y, z) {",
                "        const permMod12 = this.permMod12;",
                "        const perm = this.perm;",
                "        let n0, n1, n2, n3; // Noise contributions from the four corners",
                "        // Skew the input space to determine which simplex cell we're in",
                "        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D",
                "        const i = Math.floor(x + s);",
                "        const j = Math.floor(y + s);",
                "        const k = Math.floor(z + s);",
                "        const t = (i + j + k) * G3;",
                "        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space",
                "        const Y0 = j - t;",
                "        const Z0 = k - t;",
                "        const x0 = x - X0; // The x,y,z distances from the cell origin",
                "        const y0 = y - Y0;",
                "        const z0 = z - Z0;",
                "        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.",
                "        // Determine which simplex we are in.",
                "        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords",
                "        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords",
                "        if (x0 >= y0) {",
                "            if (y0 >= z0) {",
                "                i1 = 1;",
                "                j1 = 0;",
                "                k1 = 0;",
                "                i2 = 1;",
                "                j2 = 1;",
                "                k2 = 0;",
                "            } // X Y Z order",
                "            else if (x0 >= z0) {",
                "                i1 = 1;",
                "                j1 = 0;",
                "                k1 = 0;",
                "                i2 = 1;",
                "                j2 = 0;",
                "                k2 = 1;",
                "            } // X Z Y order",
                "            else {",
                "                i1 = 0;",
                "                j1 = 0;",
                "                k1 = 1;",
                "                i2 = 1;",
                "                j2 = 0;",
                "                k2 = 1;",
                "            } // Z X Y order",
                "        }",
                "        else { // x0<y0",
                "            if (y0 < z0) {",
                "                i1 = 0;",
                "                j1 = 0;",
                "                k1 = 1;",
                "                i2 = 0;",
                "                j2 = 1;",
                "                k2 = 1;",
                "            } // Z Y X order",
                "            else if (x0 < z0) {",
                "                i1 = 0;",
                "                j1 = 1;",
                "                k1 = 0;",
                "                i2 = 0;",
                "                j2 = 1;",
                "                k2 = 1;",
                "            } // Y Z X order",
                "            else {",
                "                i1 = 0;",
                "                j1 = 1;",
                "                k1 = 0;",
                "                i2 = 1;",
                "                j2 = 1;",
                "                k2 = 0;",
                "            } // Y X Z order",
                "        }",
                "        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),",
                "        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and",
                "        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where",
                "        // c = 1/6.",
                "        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords",
                "        const y1 = y0 - j1 + G3;",
                "        const z1 = z0 - k1 + G3;",
                "        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords",
                "        const y2 = y0 - j2 + 2.0 * G3;",
                "        const z2 = z0 - k2 + 2.0 * G3;",
                "        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords",
                "        const y3 = y0 - 1.0 + 3.0 * G3;",
                "        const z3 = z0 - 1.0 + 3.0 * G3;",
                "        // Work out the hashed gradient indices of the four simplex corners",
                "        const ii = i & 255;",
                "        const jj = j & 255;",
                "        const kk = k & 255;",
                "        // Calculate the contribution from the four corners",
                "        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;",
                "        if (t0 < 0)",
                "            n0 = 0.0;",
                "        else {",
                "            const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;",
                "            t0 *= t0;",
                "            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);",
                "        }",
                "        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;",
                "        if (t1 < 0)",
                "            n1 = 0.0;",
                "        else {",
                "            const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;",
                "            t1 *= t1;",
                "            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);",
                "        }",
                "        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;",
                "        if (t2 < 0)",
                "            n2 = 0.0;",
                "        else {",
                "            const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;",
                "            t2 *= t2;",
                "            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);",
                "        }",
                "        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;",
                "        if (t3 < 0)",
                "            n3 = 0.0;",
                "        else {",
                "            const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;",
                "            t3 *= t3;",
                "            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);",
                "        }",
                "        // Add contributions from each corner to get the final noise value.",
                "        // The result is scaled to stay just inside [-1,1]",
                "        return 32.0 * (n0 + n1 + n2 + n3);",
                "    }",
                "",
                "    /**",
                "     * Samples the noise field in 4 dimensions",
                "     * @param {number} x",
                "     * @param {number} y",
                "     * @param {number} z",
                "     * @returns a number in the interval [-1, 1]",
                "     */",
                "    noise4D(x, y, z, w) {",
                "        const perm = this.perm;",
                "        let n0, n1, n2, n3, n4; // Noise contributions from the five corners",
                "        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in",
                "        const s = (x + y + z + w) * F4; // Factor for 4D skewing",
                "        const i = Math.floor(x + s);",
                "        const j = Math.floor(y + s);",
                "        const k = Math.floor(z + s);",
                "        const l = Math.floor(w + s);",
                "        const t = (i + j + k + l) * G4; // Factor for 4D unskewing",
                "        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space",
                "        const Y0 = j - t;",
                "        const Z0 = k - t;",
                "        const W0 = l - t;",
                "        const x0 = x - X0; // The x,y,z,w distances from the cell origin",
                "        const y0 = y - Y0;",
                "        const z0 = z - Z0;",
                "        const w0 = w - W0;",
                "        // For the 4D case, the simplex is a 4D shape I won't even try to describe.",
                "        // To find out which of the 24 possible simplices we're in, we need to",
                "        // determine the magnitude ordering of x0, y0, z0 and w0.",
                "        // Six pair-wise comparisons are performed between each possible pair",
                "        // of the four coordinates, and the results are used to rank the numbers.",
                "        let rankx = 0;",
                "        let ranky = 0;",
                "        let rankz = 0;",
                "        let rankw = 0;",
                "        if (x0 > y0)",
                "            rankx++;",
                "        else",
                "            ranky++;",
                "        if (x0 > z0)",
                "            rankx++;",
                "        else",
                "            rankz++;",
                "        if (x0 > w0)",
                "            rankx++;",
                "        else",
                "            rankw++;",
                "        if (y0 > z0)",
                "            ranky++;",
                "        else",
                "            rankz++;",
                "        if (y0 > w0)",
                "            ranky++;",
                "        else",
                "            rankw++;",
                "        if (z0 > w0)",
                "            rankz++;",
                "        else",
                "            rankw++;",
                "        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.",
                "        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w",
                "        // impossible. Only the 24 indices which have non-zero entries make any sense.",
                "        // We use a thresholding to set the coordinates in turn from the largest magnitude.",
                "        // Rank 3 denotes the largest coordinate.",
                "        // Rank 2 denotes the second largest coordinate.",
                "        // Rank 1 denotes the second smallest coordinate.",
                "        // The integer offsets for the second simplex corner",
                "        const i1 = rankx >= 3 ? 1 : 0;",
                "        const j1 = ranky >= 3 ? 1 : 0;",
                "        const k1 = rankz >= 3 ? 1 : 0;",
                "        const l1 = rankw >= 3 ? 1 : 0;",
                "        // The integer offsets for the third simplex corner",
                "        const i2 = rankx >= 2 ? 1 : 0;",
                "        const j2 = ranky >= 2 ? 1 : 0;",
                "        const k2 = rankz >= 2 ? 1 : 0;",
                "        const l2 = rankw >= 2 ? 1 : 0;",
                "        // The integer offsets for the fourth simplex corner",
                "        const i3 = rankx >= 1 ? 1 : 0;",
                "        const j3 = ranky >= 1 ? 1 : 0;",
                "        const k3 = rankz >= 1 ? 1 : 0;",
                "        const l3 = rankw >= 1 ? 1 : 0;",
                "        // The fifth corner has all coordinate offsets = 1, so no need to compute that.",
                "        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords",
                "        const y1 = y0 - j1 + G4;",
                "        const z1 = z0 - k1 + G4;",
                "        const w1 = w0 - l1 + G4;",
                "        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords",
                "        const y2 = y0 - j2 + 2.0 * G4;",
                "        const z2 = z0 - k2 + 2.0 * G4;",
                "        const w2 = w0 - l2 + 2.0 * G4;",
                "        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords",
                "        const y3 = y0 - j3 + 3.0 * G4;",
                "        const z3 = z0 - k3 + 3.0 * G4;",
                "        const w3 = w0 - l3 + 3.0 * G4;",
                "        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords",
                "        const y4 = y0 - 1.0 + 4.0 * G4;",
                "        const z4 = z0 - 1.0 + 4.0 * G4;",
                "        const w4 = w0 - 1.0 + 4.0 * G4;",
                "        // Work out the hashed gradient indices of the five simplex corners",
                "        const ii = i & 255;",
                "        const jj = j & 255;",
                "        const kk = k & 255;",
                "        const ll = l & 255;",
                "        // Calculate the contribution from the five corners",
                "        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;",
                "        if (t0 < 0)",
                "            n0 = 0.0;",
                "        else {",
                "            const gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;",
                "            t0 *= t0;",
                "            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);",
                "        }",
                "        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;",
                "        if (t1 < 0)",
                "            n1 = 0.0;",
                "        else {",
                "            const gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;",
                "            t1 *= t1;",
                "            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);",
                "        }",
                "        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;",
                "        if (t2 < 0)",
                "            n2 = 0.0;",
                "        else {",
                "            const gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;",
                "            t2 *= t2;",
                "            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);",
                "        }",
                "        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;",
                "        if (t3 < 0)",
                "            n3 = 0.0;",
                "        else {",
                "            const gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;",
                "            t3 *= t3;",
                "            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);",
                "        }",
                "        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;",
                "        if (t4 < 0)",
                "            n4 = 0.0;",
                "        else {",
                "            const gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;",
                "            t4 *= t4;",
                "            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);",
                "        }",
                "        // Sum up and scale the result to cover the range [-1,1]",
                "        return 27.0 * (n0 + n1 + n2 + n3 + n4);",
                "    };",
                "}",
                "",
                "gdjs._extensionNoise = {",
                "    noiseManager: new NoiseManager(),",
                "};",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 1 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "1D noise",
          "functionType": "Expression",
          "name": "Noise1d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = 0;\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 2 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "2D noise",
          "functionType": "Expression",
          "name": "Noise2d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = eventsFunctionContext.getArgument(\"Y\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "Y coordinate",
              "name": "Y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 3 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "3D noise",
          "functionType": "Expression",
          "name": "Noise3d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = eventsFunctionContext.getArgument(\"Y\");\r",
                "const z = eventsFunctionContext.getArgument(\"Z\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y, z);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "Y coordinate",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "Z coordinate",
              "name": "Z",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 4 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "4D noise",
          "functionType": "Expression",
          "name": "Noise4d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = eventsFunctionContext.getArgument(\"Y\");\r",
                "const z = eventsFunctionContext.getArgument(\"Z\");\r",
                "const w = eventsFunctionContext.getArgument(\"W\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y, z, w);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "Y coordinate",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "Z coordinate",
              "name": "Z",
              "type": "expression"
            },
            {
              "description": "W coordinate",
              "name": "W",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Create a noise generator with default settings (frequency = 1,  octaves = 1, persistence = 0.5, lacunarity = 2).",
          "fullName": "Create a noise generator",
          "functionType": "Action",
          "name": "Create",
          "sentence": "Create a noise generator named _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Delete a noise generators and loose its settings.",
          "fullName": "Delete a noise generator",
          "functionType": "Action",
          "name": "Delete",
          "sentence": "Delete _PARAM1_ noise generator",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.deleteGenerator(name);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Delete all noise generators and loose their settings.",
          "fullName": "Delete all noise generators",
          "functionType": "Action",
          "name": "DeleteAll",
          "sentence": "Delete all noise generators",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "gdjs._extensionNoise.noiseManager.deleteAllGenerators();",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "The seed is a number used to generate the random noise. Setting the same seed will result in the same random noise generation. It's for example useful to generate the same world, by saving this seed value and reusing it later to generate again a world.",
          "fullName": "Noise seed",
          "functionType": "Action",
          "name": "SetSeed",
          "sentence": "Change the noise seed to _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "gdjs._extensionNoise.noiseManager.setSeed(eventsFunctionContext.getArgument(\"Seed\"));",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Seed",
              "longDescription": "15 digits numbers maximum",
              "name": "Seed",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the looping period on X used for noise generation. The noise will wrap-around on X.",
          "fullName": "Noise looping period on X",
          "functionType": "Action",
          "name": "SetLoopPeriodX",
          "sentence": "Change the looping period on X of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).xLoopPeriod = eventsFunctionContext.getArgument(\"LoopPeriod\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Looping period on X",
              "name": "LoopPeriod",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the looping period on Y used for noise generation. The noise will wrap-around on Y.",
          "fullName": "Noise looping period on Y",
          "functionType": "Action",
          "name": "SetLoopPeriodY",
          "sentence": "Change the looping period on Y of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).yLoopPeriod = eventsFunctionContext.getArgument(\"LoopPeriod\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Looping period on Y",
              "name": "LoopPeriod",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the base frequency used for noise generation. A lower frequency will zoom in the noise.",
          "fullName": "Noise base frequency",
          "functionType": "Action",
          "name": "SetFrequency",
          "sentence": "Change the noise frequency of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).frequency = eventsFunctionContext.getArgument(\"Frequency\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Frequency",
              "name": "Frequency",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the number of octaves used for noise generation. It can be seen as layers of noise with different zoom.",
          "fullName": "Noise octaves",
          "functionType": "Action",
          "name": "SetOctaves",
          "sentence": "Change the number of noise octaves of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).octaves = eventsFunctionContext.getArgument(\"Octaves\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Octaves",
              "name": "Octaves",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the persistence used for noise generation. At its default value \"0.5\", it halves the noise amplitude at each octave.",
          "fullName": "Noise persistence",
          "functionType": "Action",
          "name": "SetPersistence",
          "sentence": "Change the noise persistence of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).persistence = eventsFunctionContext.getArgument(\"Persistence\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Persistence",
              "name": "Persistence",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the lacunarity used for noise generation. At its default value \"2\", it doubles the frequency at each octave.",
          "fullName": "Noise lacunarity",
          "functionType": "Action",
          "name": "SetLacunarity",
          "sentence": "Change the noise lacunarity of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).lacunarity = eventsFunctionContext.getArgument(\"Lacunarity\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Lacunarity",
              "name": "Lacunarity",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The seed used for noise generation.",
          "fullName": "Noise seed",
          "functionType": "Expression",
          "name": "Seed",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.seed;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "The base frequency used for noise generation.",
          "fullName": "Noise base frequency",
          "functionType": "Expression",
          "name": "Frequency",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).frequency;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The number of octaves used for noise generation.",
          "fullName": "Noise octaves number",
          "functionType": "Expression",
          "name": "Octaves",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).octaves;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The persistence used for noise generation.",
          "fullName": "Noise persistence",
          "functionType": "Expression",
          "name": "Persistence",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).persistence;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The lacunarity used for noise generation.",
          "fullName": "Noise lacunarity",
          "functionType": "Expression",
          "name": "Lacunarity",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).lacunarity;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "2 dimensional Perlin noise (depecated, use Noise2d instead).",
          "fullName": "Perlin 2D noise",
          "functionType": "Expression",
          "name": "Perlin2",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise2d(\"\", X, Y)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "3 dimensional Perlin noise (depecated, use Noise3d instead).",
          "fullName": "Perlin 3D noise",
          "functionType": "Expression",
          "name": "Perlin3",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise3d(\"\", X, Y, Z)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "z value",
              "name": "Z",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "2 dimensional simplex noise (depecated, use Noise2d instead).",
          "fullName": "Simplex 2D noise",
          "functionType": "Expression",
          "name": "Simplex2",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise2d(\"\", X, Y)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "3 dimensional simplex noise (depecated, use Noise3d instead).",
          "fullName": "Simplex 3D noise",
          "functionType": "Expression",
          "name": "Simplex3",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise3d(\"\", X, Y, Z)"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "z value",
              "name": "Z",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": []
    },
    {
      "author": "D8H",
      "category": "Visual effect",
      "extensionNamespace": "",
      "fullName": "Marching Squares (experimental)",
      "gdevelopVersion": ">=5.5.222",
      "helpPath": "/extensions/marching-squares/details",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXBlYW51dC1vdXRsaW5lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDIzQzExLjUzIDIzIDExLjA3IDIyLjk1IDEwLjYxIDIyLjg1QzcuMSAyMi4xIDQuODcgMTguNjQgNS42MiAxNS4xM0M1Ljg3IDEzLjk1IDYuNDUgMTIuODcgNy4yOCAxMkM3LjYyIDExLjY0IDcuNjIgMTEuMDggNy4yOCAxMC43MkM1LjIgOC4xNCA1LjYgNC4zNiA4LjE4IDIuMjhTMTQuNTQuNjA3IDE2LjYyIDMuMTlDMTguMzkgNS4zOCAxOC4zOSA4LjUgMTYuNjIgMTAuNzJDMTYuMzMgMTEuMTMgMTYuMzcgMTEuNyAxNi43MiAxMi4wNkMxOS4xNyAxNC42OCAxOS4wNCAxOC44IDE2LjQxIDIxLjI1QzE1LjIyIDIyLjM3IDEzLjY0IDIzIDEyIDIzTTEyIDNDMTEuMDkgMyAxMC4yIDMuMzEgOS41IDMuODlDOC41NSA0LjY1IDggNS43OSA4IDdDOCA3LjkxIDguMzEgOC43OSA4Ljg4IDkuNUM5Ljg0IDEwLjY0IDkuNzcgMTIuMzMgOC43MyAxMy40MUM3LjAzIDE1LjIyIDcuMTMgMTguMDcgOC45NCAxOS43N1MxMy42IDIxLjM4IDE1LjMgMTkuNTZDMTYuOTIgMTcuODMgMTYuOTIgMTUuMTQgMTUuMyAxMy40MUMxNC4yMyAxMi4zMiAxNC4xNSAxMC42IDE1LjEyIDkuNDFDMTYuNSA3LjY5IDE2LjIyIDUuMTcgMTQuNSAzLjc5QzE0IDMuNDEgMTMuNDcgMy4xNCAxMi44OCAzQzEyLjU5IDMgMTIuMjkgMyAxMiAzTTEyIDZDMTIgNi41NSAxMi40NSA3IDEzIDdTMTQgNi41NSAxNCA2IDEzLjU1IDUgMTMgNSAxMiA1LjQ1IDEyIDZNMTQgMTlDMTQuNTUgMTkgMTUgMTguNTUgMTUgMThTMTQuNTUgMTcgMTQgMTcgMTMgMTcuNDUgMTMgMTggMTMuNDUgMTkgMTQgMTlNMTMgMTZDMTMuNTUgMTYgMTQgMTUuNTUgMTQgMTVTMTMuNTUgMTQgMTMgMTQgMTIgMTQuNDUgMTIgMTUgMTIuNDUgMTYgMTMgMTZNMTEgMThDMTEuNTUgMTggMTIgMTcuNTUgMTIgMTdTMTEuNTUgMTYgMTEgMTYgMTAgMTYuNDUgMTAgMTcgMTAuNDUgMTggMTEgMThaIiAvPjwvc3ZnPg==",
      "name": "MarchingSquares",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/peanut-outline.svg",
      "shortDescription": "Allow to build a \"scalar field\" and draw contour lines of it: useful for fog of wars, liquid effects, paint the ground, etc...",
      "version": "0.6.0",
      "description": [
        "It can be helpful for:",
        "  * Liquid effects like water, blobs or lava ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-liquids))",
        "  * Fog of wars ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-fog-of-war))",
        "  * Platformer with destructible platforms ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-platforms-painter))",
        "  * Dynamically paint territories ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-qix))",
        "  * Top-down relief with physics ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-terraforming))",
        "  * Island generator ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-island-generator))"
      ],
      "origin": {
        "identifier": "MarchingSquares",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "blobs",
        "liquid",
        "lava",
        "water",
        "fog",
        "paint",
        "heightmap"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Define the scalar field painter library JavaScript code.",
          "fullName": "Define scalar field painter library",
          "functionType": "Action",
          "name": "DefineScalarFieldPainterLibrary",
          "private": true,
          "sentence": "Define the scalar field painter library JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// This library comes from https://github.com/D8H/scalar-field-painter",
                "// It can be generated with \"npm run build\" to the dist/ScalarFieldPainter.js",
                "",
                "/**",
                " * A stock to reuse instances and avoid allocation.",
                " */",
                "class Stock {",
                "    /**",
                "     * Create a stock.",
                "     */",
                "    constructor() {",
                "        this.elements = [];",
                "    }",
                "    /**",
                "     * Get an element to avoid allocation or create a new one if the stock is",
                "     * empty.",
                "     * @param create",
                "     * @returns an element",
                "     */",
                "    getOrCreate(create) {",
                "        return this.elements.pop() || create();",
                "    }",
                "    /**",
                "     * Stock an element to use it later.",
                "     * @param element",
                "     */",
                "    stock(element) {",
                "        this.elements.push(element);",
                "    }",
                "    /**",
                "     * Free all the elements from the stock.",
                "     */",
                "    flush() {",
                "        this.elements.length = 0;",
                "    }",
                "}",
                "",
                "const deltas = [",
                "    { x: -1, y: 0 },",
                "    { x: 1, y: 0 },",
                "    { x: 0, y: -1 },",
                "    { x: 0, y: 1 },",
                "];",
                "const createNode = () => ({ x: 0, y: 0 });",
                "const createContourNode = () => ({",
                "    x: 0,",
                "    y: 0,",
                "    originX: 0,",
                "    originY: 0,",
                "    value: 0,",
                "});",
                "/**",
                " *",
                " */",
                "class FloodFill {",
                "    constructor(scalarField) {",
                "        this.floodStack = [];",
                "        this.nodeStock = new Stock();",
                "        this.contourStack = [];",
                "        this.nextContourStack = [];",
                "        this.contourNodeStock = new Stock();",
                "        this.scalarField = scalarField;",
                "    }",
                "    /**",
                "     * Fill an area from a given location until a maximum field value is reached.",
                "     *",
                "     * The result is the same as drawing circles at every point of the area.",
                "     * This mean that the area will be filled with a value a lot gibber than 1.",
                "     *",
                "     * @param originX {float} in grid basis",
                "     * @param originY {float} in grid basis",
                "     * @param valueMax {float} the value where to stop the flooding",
                "     * @param thickness {float} the thickness of the contour shading.",
                "     * The field will have the value 1 at this given distance from the area.",
                "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "     * or a maximum otherwise.",
                "     */",
                "    fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "        const thicknessSq = thickness * thickness;",
                "        const fillingValue = Math.max(valueMax, thicknessSq * 1024 * 1024);",
                "        const cappingRadius = cappingRadiusRatio * thickness;",
                "        const cappingRadiusSq = cappingRadius * cappingRadius;",
                "        const getContourValue = (fieldValue, distanceSq) => {",
                "            const value = thicknessSq / distanceSq;",
                "            return fieldValue < value && distanceSq < cappingRadiusSq ? value : null;",
                "        };",
                "        this.floodFrom(originX, originY, (fieldValue) => fieldValue < valueMax, fillingValue, getContourValue);",
                "        this.shadeContour(getContourValue);",
                "    }",
                "    /**",
                "     * Unfill an area from a given location until a minimum field value is reached.",
                "     *",
                "     * It fills the area with the value 0.",
                "     *",
                "     * @param originX {float} in grid basis",
                "     * @param originY {float} in grid basis",
                "     * @param valueMax {float} the value where to stop the flooding",
                "     * @param thickness {float} the thickness of the contour shading.",
                "     * The field will have the value 1 at this given distance from the area.",
                "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "     * or a maximum otherwise.",
                "     */",
                "    unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio) {",
                "        const fillingValue = 0;",
                "        const thicknessSq = thickness * thickness;",
                "        const cappingRadius = cappingRadiusRatio * thickness;",
                "        const cappingRadiusSq = cappingRadius * cappingRadius;",
                "        const getContourValue = (fieldValue, distanceSq) => {",
                "            const value = distanceSq / thicknessSq;",
                "            return fieldValue > value && distanceSq < cappingRadiusSq ? value : null;",
                "        };",
                "        this.floodFrom(originX, originY, (fieldValue) => fieldValue > valueMin, fillingValue, getContourValue);",
                "        this.shadeContour(getContourValue);",
                "    }",
                "    /**",
                "     * Flood an area from a given location until a condition is reached.",
                "     * @param originX {float} in grid basis",
                "     * @param originY {float} in grid basis",
                "     * @param canFlood {(float) => boolean}",
                "     * @param fillingValue {float}",
                "     * @param getContourValue {(number, number) => number}",
                "     * or a maximum otherwise.",
                "     */",
                "    floodFrom(originX, originY, canFlood, fillingValue, getContourValue) {",
                "        const scalarField = this.scalarField;",
                "        // They should already be empty at this point.",
                "        this.floodStack.length = 0;",
                "        this.contourStack.length = 0;",
                "        this.nextContourStack.length = 0;",
                "        {",
                "            const x = Math.round(originX);",
                "            const y = Math.round(originY);",
                "            if (!scalarField.isInside(x, y)) {",
                "                return;",
                "            }",
                "            const fieldValue = scalarField.get(x, y);",
                "            if (canFlood(fieldValue)) {",
                "                const node = this.nodeStock.getOrCreate(createNode);",
                "                node.x = x;",
                "                node.y = y;",
                "                this.floodStack.push(node);",
                "            }",
                "        }",
                "        while (this.floodStack.length > 0) {",
                "            const node = this.floodStack.pop();",
                "            const x = node.x;",
                "            const y = node.y;",
                "            scalarField.set(x, y, fillingValue);",
                "            for (const delta of deltas) {",
                "                const neighborX = x + delta.x;",
                "                const neighborY = y + delta.y;",
                "                if (!scalarField.isInside(neighborX, neighborY)) {",
                "                    continue;",
                "                }",
                "                const fieldValue = scalarField.get(neighborX, neighborY);",
                "                if (canFlood(fieldValue)) {",
                "                    const neighbor = this.nodeStock.getOrCreate(createNode);",
                "                    neighbor.x = neighborX;",
                "                    neighbor.y = neighborY;",
                "                    this.floodStack.push(neighbor);",
                "                }",
                "                else {",
                "                    this.checkAnAddContourNode(neighborX, neighborY, x, y, getContourValue);",
                "                }",
                "            }",
                "            this.nodeStock.stock(node);",
                "        }",
                "    }",
                "    /**",
                "     * Shade the contour to keep the field somewhat continuous.",
                "     * @param getContourValue",
                "     */",
                "    shadeContour(getContourValue) {",
                "        const scalarField = this.scalarField;",
                "        const swap = this.nextContourStack;",
                "        this.nextContourStack = this.contourStack;",
                "        this.contourStack = swap;",
                "        while (this.contourStack.length > 0) {",
                "            while (this.contourStack.length > 0) {",
                "                const node = this.contourStack.pop();",
                "                if (scalarField.get(node.x, node.y) > node.value) {",
                "                    // This node wasn't the nearest one.",
                "                    continue;",
                "                }",
                "                for (const delta of deltas) {",
                "                    const neighborX = node.x + delta.x;",
                "                    const neighborY = node.y + delta.y;",
                "                    this.checkAnAddContourNode(neighborX, neighborY, node.originX, node.originY, getContourValue);",
                "                }",
                "                this.contourNodeStock.stock(node);",
                "            }",
                "            const swap = this.nextContourStack;",
                "            this.nextContourStack = this.contourStack;",
                "            this.contourStack = swap;",
                "        }",
                "    }",
                "    checkAnAddContourNode(nodeX, nodeY, originX, originY, getContourValue) {",
                "        const scalarField = this.scalarField;",
                "        if (!scalarField.isInside(nodeX, nodeY)) {",
                "            return;",
                "        }",
                "        // Avoid too big values",
                "        const minDistanceSq = 1 / 1024 / 1024;",
                "        const deltaX = nodeX - originX;",
                "        const deltaY = nodeY - originY;",
                "        const distanceSq = Math.max(minDistanceSq, deltaX * deltaX + deltaY * deltaY);",
                "        const value = getContourValue(scalarField.get(nodeX, nodeY), distanceSq);",
                "        if (value !== null) {",
                "            scalarField.set(nodeX, nodeY, value);",
                "            const newNode = this.contourNodeStock.getOrCreate(createContourNode);",
                "            newNode.x = nodeX;",
                "            newNode.y = nodeY;",
                "            newNode.originX = originX;",
                "            newNode.originY = originY;",
                "            newNode.value = value;",
                "            this.nextContourStack.push(newNode);",
                "        }",
                "    }",
                "}",
                "",
                "/**",
                " * @param x1 {float} first point x",
                " * @param y1 {float} first point y",
                " * @param x2 {float} second point x",
                " * @param y2 {float} second point y",
                " * @return {float} the square distance between 2 points",
                " */",
                "const getDistanceSq = (x1, y1, x2, y2) => {",
                "    const deltaX = x2 - x1;",
                "    const deltaY = y2 - y1;",
                "    return deltaX * deltaX + deltaY * deltaY;",
                "};",
                "/**",
                " * @param x {float} point x",
                " * @param y {float} point y",
                " * @param x1 {float} segment extremity x",
                " * @param y1 {float} segment extremity y",
                " * @param x2 {float} segment extremity x",
                " * @param y2 {float} segment extremity y",
                " * @return {float} the square distance between a point and a segment",
                " */",
                "const getDistanceSqToSegment = (x, y, x1, y1, x2, y2) => {",
                "    const length2 = getDistanceSq(x1, y1, x2, y2);",
                "    if (length2 === 0)",
                "        return getDistanceSq(x, y, x1, y1);",
                "    const t = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / length2));",
                "    return getDistanceSq(x, y, x1 + t * (x2 - x1), y1 + t * (y2 - y1));",
                "};",
                "/**",
                " * A scalar field.",
                " */",
                "class ScalarField {",
                "    /**",
                "     * Create a scalar field.",
                "     * @param dimX {integer}",
                "     * @param dimY {integer}",
                "     */",
                "    constructor(dimX, dimY) {",
                "        const fieldValues = new Array(dimY);",
                "        for (var y = 0; y < dimY; y++) {",
                "            fieldValues[y] = new Array(dimX).fill(0);",
                "        }",
                "        this.values = fieldValues;",
                "        this.floodFill = new FloodFill(this);",
                "    }",
                "    /**",
                "     * @return {integer} grid dimension on y",
                "     */",
                "    dimY() {",
                "        return this.values.length;",
                "    }",
                "    /**",
                "     * @return {integer} grid dimension on y",
                "     */",
                "    dimX() {",
                "        const firstColumn = this.values[0];",
                "        return firstColumn ? firstColumn.length : 0;",
                "    }",
                "    isInside(x, y) {",
                "        return x >= 0 && x <= this.dimX() - 1 && y >= 0 && y <= this.dimY() - 1;",
                "    }",
                "    get(x, y) {",
                "        return this.values[y][x];",
                "    }",
                "    /**",
                "     * @param squareX {integer} x grid index",
                "     * @param squareY {integer} y grid index",
                "     * @param value {float} the field value",
                "     */",
                "    set(x, y, value) {",
                "        this.values[y][x] = value;",
                "    }",
                "    /**",
                "     * @param pointX {float} in grid basis",
                "     * @param pointY {float} in grid basis",
                "     * @return {float} the field value",
                "     */",
                "    extrapolate(x, y) {",
                "        const squareX = Math.floor(x);",
                "        const squareY = Math.floor(y);",
                "        if (squareX < 0 ||",
                "            squareY < 0 ||",
                "            // - 1 because the extrapolation uses the next value.",
                "            squareX >= this.dimX() - 1 ||",
                "            squareY >= this.dimY() - 1) {",
                "            return 0;",
                "        }",
                "        // Extrapolate",
                "        let weighedValueSum = 0;",
                "        let weightSum = 0;",
                "        for (let vertexX = squareX; vertexX <= squareX + 1; vertexX++) {",
                "            for (let vertexY = squareY; vertexY <= squareY + 1; vertexY++) {",
                "                const value = this.values[vertexY][vertexX];",
                "                const dx = vertexX - x;",
                "                const dy = vertexY - y;",
                "                if (dx === 0 && dy === 0) {",
                "                    // No interpolation needed.",
                "                    return value;",
                "                }",
                "                else {",
                "                    const distance = Math.hypot(dx, dy);",
                "                    weighedValueSum += value / distance;",
                "                    weightSum += 1 / distance;",
                "                }",
                "            }",
                "        }",
                "        const mean = weighedValueSum / weightSum;",
                "        return mean;",
                "    }",
                "    /**",
                "     * Clear the field by filling it with a give value.",
                "     * @param value {float}",
                "     */",
                "    clear(value = 0) {",
                "        for (let rowValues of this.values) {",
                "            for (let x = 0; x < rowValues.length; x++) {",
                "                rowValues[x] = value;",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Cap the field between 2 values.",
                "     * @param min {float}",
                "     * @param max {float}",
                "     */",
                "    clamp(min, max) {",
                "        for (let rowValues of this.values) {",
                "            for (let x = 0; x < rowValues.length; x++) {",
                "                rowValues[x] = Math.min(Math.max(min, rowValues[x]), max);",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Apply an affine transformation on each field value.",
                "     * @param a {float} factor",
                "     * @param b {float} offset",
                "     */",
                "    transform(a, b) {",
                "        for (let rowValues of this.values) {",
                "            for (let x = 0; x < rowValues.length; x++) {",
                "                rowValues[x] = a * rowValues[x] + b;",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Merge the values from another field.",
                "     * @param scalarField {ScalarField}",
                "     * @param operation {function(float, float):float}",
                "     */",
                "    mergeField(scalarField, operation) {",
                "        const dimX = Math.min(this.dimX(), scalarField.dimX());",
                "        const dimY = Math.min(this.dimY(), scalarField.dimY());",
                "        for (let y = 0; y < dimY; y++) {",
                "            const thisRowValues = this.values[y];",
                "            const otherRowValues = scalarField.values[y];",
                "            for (let x = 0; x < dimX; x++) {",
                "                thisRowValues[x] = operation(thisRowValues[x], otherRowValues[x]);",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Merge a disk in the field.",
                "     * @param centerX {float} in grid basis",
                "     * @param centerY {float} in grid basis",
                "     * @param radius {float} in grid basis",
                "     * @param cappingRadiusRatio {float}",
                "     * @param operation {function(float, float):float}",
                "     */",
                "    mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation) {",
                "        const cappingRadius = cappingRadiusRatio * radius;",
                "        const minX = Math.max(0, Math.floor(centerX - cappingRadius));",
                "        const minY = Math.max(0, Math.floor(centerY - cappingRadius));",
                "        const maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));",
                "        const maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));",
                "        const radiusSq = radius * radius;",
                "        // Avoid too big values",
                "        const minDistanceSq = 1 / 1024 / 1024;",
                "        for (let y = minY; y <= maxY; y++) {",
                "            const rowValues = this.values[y];",
                "            for (let x = minX; x <= maxX; x++) {",
                "                const distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));",
                "                rowValues[x] = operation(rowValues[x], radiusSq / distanceSq);",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Merge a segment in the field.",
                "     * @param startX {float} in grid basis",
                "     * @param startY {float} in grid basis",
                "     * @param endX {float} in grid basis",
                "     * @param endY {float} in grid basis",
                "     * @param thickness {float} in grid basis",
                "     * @param cappingRadiusRatio {float}",
                "     * @param operation {function(float, float):float}",
                "     */",
                "    mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {",
                "        const cappingRadius = cappingRadiusRatio * thickness;",
                "        const minX = Math.max(0, Math.floor(Math.min(startX, endX) - cappingRadius));",
                "        const minY = Math.max(0, Math.floor(Math.min(startY, endY) - cappingRadius));",
                "        const maxX = Math.min(this.dimX() - 1, Math.ceil(Math.max(startX, endX) + cappingRadius));",
                "        const maxY = Math.min(this.dimY() - 1, Math.ceil(Math.max(startY, endY) + cappingRadius));",
                "        const thicknessSq = thickness * thickness;",
                "        // Avoid too big values",
                "        const minDistanceSq = 1 / 1024 / 1024;",
                "        for (let y = minY; y <= maxY; y++) {",
                "            const rowValues = this.values[y];",
                "            for (let x = minX; x <= maxX; x++) {",
                "                const distanceSq = Math.max(minDistanceSq, getDistanceSqToSegment(x, y, startX, startY, endX, endY));",
                "                rowValues[x] = operation(rowValues[x], thicknessSq / distanceSq);",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Merge a hill in the field.",
                "     * @param centerX {float} in grid basis",
                "     * @param centerY {float} in grid basis",
                "     * @param height {float}",
                "     * @param radius {float} in grid basis",
                "     * @param opacity {float}",
                "     * @param cappingRadiusRatio {float}",
                "     * @param operation {function(float, float):float}",
                "     */",
                "    mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {",
                "        const cappingRadius = cappingRadiusRatio * radius;",
                "        const minX = Math.max(0, Math.floor(centerX - cappingRadius));",
                "        const minY = Math.max(0, Math.floor(centerY - cappingRadius));",
                "        const maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));",
                "        const maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));",
                "        const logHeightDividedByRadiusSq = Math.log(height) / (radius * radius);",
                "        const opacityMultipliedByHeight = opacity * height;",
                "        // Avoid too big values",
                "        const minDistanceSq = 1 / 1024 / 1024;",
                "        for (let y = minY; y <= maxY; y++) {",
                "            const rowValues = this.values[y];",
                "            for (let x = minX; x <= maxX; x++) {",
                "                const distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));",
                "                // This is like a gaussian, but parametrized differently.",
                "                rowValues[x] = operation(rowValues[x], opacityMultipliedByHeight *",
                "                    Math.exp(-distanceSq * logHeightDividedByRadiusSq));",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Flood an area from a given location until a maximum field value is reached.",
                "     * @param originX {float} in grid basis",
                "     * @param originY {float} in grid basis",
                "     * @param valueMax {float}",
                "     * @param thickness {float}",
                "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "     * or a maximum otherwise.",
                "     */",
                "    fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "        this.floodFill.fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio);",
                "    }",
                "    /**",
                "     * Flood an area from a given location until a maximum field value is reached.",
                "     * @param originX {float} in grid basis",
                "     * @param originY {float} in grid basis",
                "     * @param valueMax {float}",
                "     * @param thickness {float}",
                "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "     * or a maximum otherwise.",
                "     */",
                "    unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio) {",
                "        this.floodFill.unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio);",
                "    }",
                "}",
                "",
                "const South = 0;",
                "const East = 1;",
                "const North = 2;",
                "const West = 3;",
                "const SouthWest = 4;",
                "const SouthEast = 5;",
                "const NorthEast = 6;",
                "const NorthWest = 7;",
                "const SouthWestMask = 1;",
                "const SouthEastMask = 2;",
                "const NorthEastMask = 4;",
                "const NorthWestMask = 8;",
                "const marchingSquaresFillVertices = [",
                "    [],",
                "    [South, West, SouthWest],",
                "    [East, South, SouthEast],",
                "    [East, West, SouthWest, SouthEast],",
                "    [North, East, NorthEast],",
                "    [South, SouthWest, West, North, NorthEast, East],",
                "    [South, North, NorthEast, SouthEast],",
                "    [West, North, NorthEast, SouthEast, SouthWest],",
                "    [West, North, NorthWest],",
                "    [North, South, SouthWest, NorthWest],",
                "    [South, West, NorthWest, North, East, SouthEast],",
                "    [North, East, SouthEast, SouthWest, NorthWest],",
                "    [East, West, NorthWest, NorthEast],",
                "    [East, South, SouthWest, NorthWest, NorthEast],",
                "    [South, West, NorthWest, NorthEast, SouthEast],",
                "    [],",
                "];",
                "const marchingSquaresOutlineVertices = [",
                "    [[]],",
                "    [[South, West]],",
                "    [[East, South]],",
                "    [[East, West]],",
                "    [[North, East]],",
                "    [",
                "        [East, South],",
                "        [West, North],",
                "    ],",
                "    [[South, North]],",
                "    [[West, North]],",
                "    [[West, North]],",
                "    [[North, South]],",
                "    [",
                "        [South, West],",
                "        [North, East],",
                "    ],",
                "    [[North, East]],",
                "    [[East, West]],",
                "    [[East, South]],",
                "    [[South, West]],",
                "    [[]],",
                "];",
                "/**",
                " * A marching square algorithm implementation.",
                " */",
                "class MarchingSquares {",
                "    /**",
                "     *",
                "     * @param scalarField",
                "     */",
                "    constructor(scalarField) {",
                "        /** {FloatPoint} Avoid memory allocations when returning points */",
                "        this.workingPoint = [0, 0];",
                "        this.scalarField = scalarField;",
                "    }",
                "    /**",
                "     * @param x {integer} the square top in the grid",
                "     * @param y {integer} the square left in the grid",
                "     * @param threshold {float}",
                "     * @return {integer} one of the 16 marching squares cases",
                "     */",
                "    getSquareIndex(x, y, threshold) {",
                "        /** @type {float} */",
                "        let squareIndex = 0;",
                "        if (this.scalarField.get(x, y + 1) > threshold) {",
                "            squareIndex |= SouthWestMask;",
                "        }",
                "        if (this.scalarField.get(x + 1, y + 1) > threshold) {",
                "            squareIndex |= SouthEastMask;",
                "        }",
                "        if (this.scalarField.get(x + 1, y) > threshold) {",
                "            squareIndex |= NorthEastMask;",
                "        }",
                "        if (this.scalarField.get(x, y) > threshold) {",
                "            squareIndex |= NorthWestMask;",
                "        }",
                "        return squareIndex;",
                "    }",
                "    /**",
                "     * Returns the mean between 2 corners weighted by their field value.",
                "     * @param indexX1 {integer} first corner x",
                "     * @param indexY1 {integer} first corner y",
                "     * @param indexX2 {integer} second corner x",
                "     * @param indexY2 {integer} second corner y",
                "     * @param threshold {float}",
                "     * @return {float} x in the grid",
                "     */",
                "    betweenX(indexX1, indexY1, indexX2, indexY2, threshold) {",
                "        const value1 = this.scalarField.get(indexX1, indexY1);",
                "        const value2 = this.scalarField.get(indexX2, indexY2);",
                "        const weight1 = Math.abs(value1 - threshold);",
                "        const weight2 = Math.abs(value2 - threshold);",
                "        return (weight2 * indexX1 + weight1 * indexX2) / (weight1 + weight2);",
                "    }",
                "    /**",
                "     * Returns the mean between 2 corners weighted by their field value.",
                "     * @param indexX1 {integer} first corner x",
                "     * @param indexY1 {integer} first corner y",
                "     * @param indexX2 {integer} second corner x",
                "     * @param indexY2 {integer} second corner y",
                "     * @param threshold {float}",
                "     * @return {float} y in the grid",
                "     */",
                "    betweenY(indexX1, indexY1, indexX2, indexY2, threshold) {",
                "        const value1 = this.scalarField.get(indexX1, indexY1);",
                "        const value2 = this.scalarField.get(indexX2, indexY2);",
                "        const weight1 = Math.abs(value1 - threshold);",
                "        const weight2 = Math.abs(value2 - threshold);",
                "        return (weight2 * indexY1 + weight1 * indexY2) / (weight1 + weight2);",
                "    }",
                "    /**",
                "     * @param side {integer} point location",
                "     * @param indexX {integer} the square top in the grid",
                "     * @param indexY {integer} the square left in the grid",
                "     * @param threshold {float}",
                "     * @param point {FloatPoint} is the result",
                "     */",
                "    calcPoint(side, indexX, indexY, threshold, point) {",
                "        let gridX = 0;",
                "        let gridY = 0;",
                "        switch (side) {",
                "            case South:",
                "                gridY = indexY + 1;",
                "                gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);",
                "                break;",
                "            case East:",
                "                gridX = indexX + 1;",
                "                gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);",
                "                break;",
                "            case North:",
                "                gridY = indexY;",
                "                gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);",
                "                break;",
                "            case West:",
                "                gridX = indexX;",
                "                gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);",
                "                break;",
                "            case SouthWest:",
                "                gridX = indexX;",
                "                gridY = indexY + 1;",
                "                break;",
                "            case SouthEast:",
                "                gridX = indexX + 1;",
                "                gridY = indexY + 1;",
                "                break;",
                "            case NorthEast:",
                "                gridX = indexX + 1;",
                "                gridY = indexY;",
                "                break;",
                "            case NorthWest:",
                "                gridX = indexX;",
                "                gridY = indexY;",
                "                break;",
                "        }",
                "        point[0] = gridX;",
                "        point[1] = gridY;",
                "    }",
                "    /**",
                "     * Draw the field squares",
                "     * @param minX {integer} left",
                "     * @param minY {integer} top",
                "     * @param maxX {integer} right",
                "     * @param maxY {integer} bottom",
                "     * @param threshold {float}",
                "     * @param drawUnder {boolean}",
                "     * @param shapePainter {ShapePainter}",
                "     */",
                "    fillContour(minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {",
                "        const point = this.workingPoint;",
                "        // It draws bands and small polygons.",
                "        // The contour line is in a second loop, it's more efficient",
                "        // than switching the style constantly.",
                "        for (let squareY = minY; squareY < maxY - 1; squareY++) {",
                "            // for run-length encoding",
                "            let first15SquareX = -1;",
                "            for (let squareX = minX; squareX < maxX - 1; squareX++) {",
                "                let squareIndex = this.getSquareIndex(squareX, squareY, threshold);",
                "                if (drawUnder) {",
                "                    squareIndex = 15 - squareIndex;",
                "                }",
                "                if (squareIndex === 15) {",
                "                    shapePainter.onFilledSquareChange(squareX, squareY);",
                "                }",
                "                if (first15SquareX === -1 && squareIndex === 15) {",
                "                    first15SquareX = squareX;",
                "                }",
                "                if (first15SquareX !== -1) {",
                "                    if (squareIndex !== 15) {",
                "                        shapePainter.drawRectangle(first15SquareX, squareY, squareX, squareY + 1);",
                "                        first15SquareX = -1;",
                "                    }",
                "                    else if (squareX === maxX - 2) {",
                "                        shapePainter.drawRectangle(first15SquareX, squareY, squareX + 1, squareY + 1);",
                "                        first15SquareX = -1;",
                "                    }",
                "                }",
                "                if (squareIndex !== 0 && squareIndex !== 15) {",
                "                    let fillVertices = marchingSquaresFillVertices[squareIndex];",
                "                    this.calcPoint(fillVertices[0], squareX, squareY, threshold, point);",
                "                    shapePainter.beginPath(point[0], point[1]);",
                "                    for (let index = 1; index < fillVertices.length; index++) {",
                "                        this.calcPoint(fillVertices[index], squareX, squareY, threshold, point);",
                "                        shapePainter.lineTo(point[0], point[1]);",
                "                    }",
                "                    shapePainter.closePath();",
                "                    shapePainter.endPath(squareX, squareY);",
                "                }",
                "            }",
                "        }",
                "    }",
                "    /**",
                "     * Draw the field squares",
                "     * @param minX {integer} left",
                "     * @param minY {integer} top",
                "     * @param maxX {integer} right",
                "     * @param maxY {integer} bottom",
                "     * @param threshold {float}",
                "     * @param drawUnder {boolean}",
                "     * @param shapePainter {ShapePainter}",
                "     */",
                "    outlineContour(minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {",
                "        const point = this.workingPoint;",
                "        for (let squareY = minY; squareY < maxY - 1; squareY++) {",
                "            for (let squareX = minX; squareX < maxX - 1; squareX++) {",
                "                let squareIndex = this.getSquareIndex(squareX, squareY, threshold);",
                "                if (drawUnder) {",
                "                    squareIndex = 15 - squareIndex;",
                "                }",
                "                if (squareIndex !== 0 && squareIndex !== 15) {",
                "                    for (let outlineVertices of marchingSquaresOutlineVertices[squareIndex]) {",
                "                        this.calcPoint(outlineVertices[0], squareX, squareY, threshold, point);",
                "                        shapePainter.beginPath(point[0], point[1]);",
                "                        for (let index = 1; index < outlineVertices.length; index++) {",
                "                            this.calcPoint(outlineVertices[index], squareX, squareY, threshold, point);",
                "                            shapePainter.lineTo(point[0], point[1]);",
                "                        }",
                "                        shapePainter.endPath(squareX, squareY);",
                "                    }",
                "                }",
                "            }",
                "        }",
                "    }",
                "}",
                "",
                "/**",
                " * A coordinate converter between a surface and a grid.",
                " */",
                "class CoordConverter {",
                "    /**",
                "     * Create a coordinate converter between a surface and a grid.",
                "     * @param cellWidth {float}",
                "     * @param cellHeight {float}",
                "     * @param left {float}",
                "     * @param top {float}",
                "     * @param right {float}",
                "     * @param bottom {float}",
                "     */",
                "    constructor(cellWidth, cellHeight, left, top, right, bottom) {",
                "        this.cellWidth = cellWidth;",
                "        this.cellHeight = cellHeight;",
                "        this.left = left;",
                "        this.top = top;",
                "        this.right = right;",
                "        this.bottom = bottom;",
                "    }",
                "    /**",
                "     * @param x {float} in the scene basis",
                "     * @return {float} x in the grid basis",
                "     */",
                "    convertToGridBasisX(x) {",
                "        return (x - this.left) / this.cellWidth;",
                "    }",
                "    /**",
                "     * @param y {float} in the scene basis",
                "     * @return {float} y in the grid basis",
                "     */",
                "    convertToGridBasisY(y) {",
                "        return (y - this.top) / this.cellHeight;",
                "    }",
                "    /**",
                "     * @param x {float} in the grid basis",
                "     * @return {float} x in the scene basis",
                "     */",
                "    convertFromGridBasisX(x) {",
                "        return x * this.cellWidth + this.left;",
                "    }",
                "    /**",
                "     * @param y {float} in the grid basis",
                "     * @return {float} y in the scene basis",
                "     */",
                "    convertFromGridBasisY(y) {",
                "        return y * this.cellHeight + this.top;",
                "    }",
                "    /**",
                "     * @param distance {float} in the grid basis",
                "     * @return {float} distance in the scene basis",
                "     */",
                "    convertToGridBasisDistance(distance) {",
                "        return distance / this.cellWidth;",
                "    }",
                "}",
                "",
                "/**",
                " * A height map.",
                " */",
                "class HeightMap {",
                "    /**",
                "     * Create a height map.",
                "     * @param scalarField {ScalarField} a scalar field for the height values.",
                "     * @param coordConverter {CoordConverter} a coordinate converter between the",
                "     * surface and the scalar field grid.",
                "     */",
                "    constructor(scalarField, coordConverter) {",
                "        this.scalarField = scalarField;",
                "        this.coordConverter = coordConverter;",
                "    }",
                "    /**",
                "     * @param pointX {float} in terrain basis",
                "     * @param pointY {float} in terrain basis",
                "     * @param normal {[float, float, float]} the result",
                "     * @return {[float, float, float]} the result",
                "     */",
                "    getFieldNormal(pointX, pointY, normal) {",
                "        if (!normal) {",
                "            normal = [0, 0, 0];",
                "        }",
                "        let x = this.coordConverter.convertToGridBasisX(pointX);",
                "        let y = this.coordConverter.convertToGridBasisY(pointY);",
                "        let squareX = Math.floor(x);",
                "        let squareY = Math.floor(y);",
                "        if (squareX < 0 ||",
                "            squareY < 0 ||",
                "            squareX >= this.scalarField.dimX() ||",
                "            squareY >= this.scalarField.dimY()) {",
                "            return null;",
                "        }",
                "        // This gives very approximating values on borders",
                "        // but it's the easiest way to avoid to be out of bounds.",
                "        // Why 1 but dim - 3?",
                "        // - 1 margin for the normal calculus on both side",
                "        // - 1 extra because extrapolation asks values on right and bottom.",
                "        if (squareX < 1) {",
                "            squareX = 1;",
                "            x = squareX;",
                "        }",
                "        if (squareX > this.scalarField.dimX() - 3) {",
                "            squareX = this.scalarField.dimX() - 3;",
                "            x = squareX;",
                "        }",
                "        if (squareY < 1) {",
                "            squareY = 1;",
                "            y = squareY;",
                "        }",
                "        if (squareY > this.scalarField.dimY() - 3) {",
                "            squareY = this.scalarField.dimY() - 3;",
                "            y = squareY;",
                "        }",
                "        // Extrapolate",
                "        let weighedValueSumX = 0;",
                "        let weighedValueSumY = 0;",
                "        let weighedValueSumZ = 0;",
                "        for (let vertexX = squareX; vertexX <= squareX + 1; vertexX++) {",
                "            for (let vertexY = squareY; vertexY <= squareY + 1; vertexY++) {",
                "                normal[0] = 0;",
                "                normal[1] = 0;",
                "                normal[2] = 0;",
                "                this.addGridPointNormal(vertexX, vertexY, normal);",
                "                const dx = vertexX - x;",
                "                const dy = vertexY - y;",
                "                if (dx === 0 && dy === 0) {",
                "                    // Double break, no interpolation needed.",
                "                    vertexX += 2;",
                "                    vertexY += 2;",
                "                }",
                "                else {",
                "                    const distance = Math.hypot(dx, dy);",
                "                    weighedValueSumX += normal[0] / distance;",
                "                    weighedValueSumY += normal[1] / distance;",
                "                    weighedValueSumZ += normal[2] / distance;",
                "                }",
                "            }",
                "        }",
                "        const length = Math.hypot(normal[0], normal[1], normal[2]);",
                "        normal[0] /= length;",
                "        normal[1] /= length;",
                "        normal[2] /= length;",
                "        return normal;",
                "    }",
                "    /**",
                "     * @param pointX {float} in terrain basis",
                "     * @param pointY {float} in terrain basis",
                "     * @return {float} the field value",
                "     */",
                "    getHeight(pointX, pointY) {",
                "        let x = this.coordConverter.convertToGridBasisX(pointX);",
                "        let y = this.coordConverter.convertToGridBasisY(pointY);",
                "        return this.scalarField.extrapolate(x, y);",
                "    }",
                "    /**",
                "     * Evaluate the normal at a given grid point.",
                "     *",
                "     * The normal is not normalized.",
                "     *",
                "     * @param x {integer} grid index",
                "     * @param y {integer} grid index",
                "     * @param normal {[float, float, float]} the result",
                "     */",
                "    addGridPointNormal(x, y, normal) {",
                "        const z = this.scalarField.get(x, y);",
                "        let rightX = 1;",
                "        const rightY = 0;",
                "        let rightZ = this.scalarField.get(x + 1, y) - z;",
                "        const rightLength = Math.hypot(rightX, rightZ);",
                "        rightX /= rightLength;",
                "        rightZ /= rightLength;",
                "        let leftX = -1;",
                "        const leftY = 0;",
                "        let leftZ = this.scalarField.get(x - 1, y) - z;",
                "        const leftLength = Math.hypot(leftX, leftZ);",
                "        leftX /= leftLength;",
                "        leftZ /= leftLength;",
                "        const bottomX = 0;",
                "        let bottomY = 1;",
                "        let bottomZ = this.scalarField.get(x, y + 1) - z;",
                "        const bottomLength = Math.hypot(bottomY, bottomZ);",
                "        bottomY /= bottomLength;",
                "        bottomZ /= bottomLength;",
                "        const topX = 0;",
                "        let topY = -1;",
                "        let topZ = this.scalarField.get(x, y - 1) - z;",
                "        const topLength = Math.hypot(topY, topZ);",
                "        topY /= topLength;",
                "        topZ /= topLength;",
                "        // The mean of the normal of the 4 triangles around the grid point.",
                "        this.addNormal(topX, topY, topZ, rightX, rightY, rightZ, normal);",
                "        this.addNormal(rightX, rightY, rightZ, bottomX, bottomY, bottomZ, normal);",
                "        this.addNormal(bottomX, bottomY, bottomZ, leftX, leftY, leftZ, normal);",
                "        this.addNormal(leftX, leftY, leftZ, topX, topY, topZ, normal);",
                "    }",
                "    /**",
                "     * @param uX {float}",
                "     * @param uY {float}",
                "     * @param uZ {float}",
                "     * @param vX {float}",
                "     * @param vY {float}",
                "     * @param vZ {float}",
                "     * @param normal {[float, float, float]} the result",
                "     */",
                "    addNormal(uX, uY, uZ, vX, vY, vZ, normal) {",
                "        normal[0] += uY * vZ - uZ * vY;",
                "        normal[1] += uZ * vX - uX * vZ;",
                "        normal[2] += uX * vY - uY * vX;",
                "    }",
                "    /**",
                "     * Clear the field by filling it with a give value.",
                "     * @param value {float}",
                "     */",
                "    clear(value = 0) {",
                "        this.scalarField.clear(value);",
                "    }",
                "    /**",
                "     * Cap the field between 2 values.",
                "     * @param min {float}",
                "     * @param max {float}",
                "     */",
                "    clamp(min, max) {",
                "        this.scalarField.clamp(min, max);",
                "    }",
                "    /**",
                "     * Apply an affine transformation on each field value.",
                "     * @param a {float} factor",
                "     * @param b {float} offset",
                "     */",
                "    transform(a, b) {",
                "        this.scalarField.transform(a, b);",
                "    }",
                "    /**",
                "     * Merge a disk in the field.",
                "     * @param centerX {float} in terrain basis",
                "     * @param centerY {float} in terrain basis",
                "     * @param radius {float} in terrain basis",
                "     * @param cappingRadiusRatio {float}",
                "     * @param operation {function(float, float):float}",
                "     */",
                "    mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation) {",
                "        this.scalarField.mergeDisk(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), this.coordConverter.convertToGridBasisDistance(radius), cappingRadiusRatio, operation);",
                "    }",
                "    /**",
                "     * Merge a segment in the field.",
                "     * @param startX {float} in terrain basis",
                "     * @param startY {float} in terrain basis",
                "     * @param endX {float} in terrain basis",
                "     * @param endY {float} in terrain basis",
                "     * @param thickness {float} in terrain basis",
                "     * @param cappingRadiusRatio {float}",
                "     * @param operation {function(float, float):float}",
                "     */",
                "    mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {",
                "        this.scalarField.mergeSegment(this.coordConverter.convertToGridBasisX(startX), this.coordConverter.convertToGridBasisY(startY), this.coordConverter.convertToGridBasisX(endX), this.coordConverter.convertToGridBasisY(endY), this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio, operation);",
                "    }",
                "    /**",
                "     * Merge a hill in the field.",
                "     * @param centerX {float} in terrain basis",
                "     * @param centerY {float} in terrain basis",
                "     * @param height {float}",
                "     * @param radius {float} in terrain basis",
                "     * @param opacity {float}",
                "     * @param cappingRadiusRatio {float}",
                "     * @param operation {function(float, float):float}",
                "     */",
                "    mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {",
                "        this.scalarField.mergeHill(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), height, this.coordConverter.convertToGridBasisDistance(radius), opacity, cappingRadiusRatio, operation);",
                "    }",
                "    /**",
                "     * Flood an area from a given location until a maximum field value is reached.",
                "     * @param originX {float} in terrain basis",
                "     * @param originY {float} in terrain basis",
                "     * @param valueMax {float}",
                "     * @param thickness {float}",
                "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "     * or a maximum otherwise.",
                "     */",
                "    fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "        this.scalarField.fillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);",
                "    }",
                "    /**",
                "     * Flood an area from a given location until a maximum field value is reached.",
                "     * @param originX {float} in terrain basis",
                "     * @param originY {float} in terrain basis",
                "     * @param valueMax {float}",
                "     * @param thickness {float}",
                "     * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "     * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "     * or a maximum otherwise.",
                "     */",
                "    unfillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "        this.scalarField.unfillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);",
                "    }",
                "}",
                "",
                "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
                "gdjs.__marchingSquaresExtension.CoordConverter = CoordConverter;",
                "gdjs.__marchingSquaresExtension.HeightMap = HeightMap;",
                "gdjs.__marchingSquaresExtension.MarchingSquares = MarchingSquares;",
                "gdjs.__marchingSquaresExtension.ScalarField = ScalarField;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
                "",
                "const parseOperation = function (operation) {",
                "  switch (operation) {",
                "    case \"Addition\":",
                "      return (value1, value2) => value1 + value2;",
                "    case \"Subtraction\":",
                "      return (value1, value2) => value1 - value2;",
                "    case \"Multiplication\":",
                "      return (value1, value2) => value1 * value2;",
                "    case \"Division\":",
                "      return (value1, value2) => value1 / value2;",
                "    case \"Minimum\":",
                "      return Math.min;",
                "    case \"Maximum\":",
                "    default:",
                "      return Math.max;",
                "  }",
                "  return;",
                "}",
                "",
                "class HitboxesIterable {",
                "  /**",
                "   * The hitboxes in a rectangular area.",
                "   * @constructor",
                "         * @param {any} behavior",
                "         * @param {integer} xMin The fist column to include.",
                "         * @param {integer} yMin The fist row to include.",
                "         * @param {integer} xMax The last column to include.",
                "         * @param {integer} yMax The last row to include.",
                "   */",
                "  constructor(",
                "    behavior,",
                "    xMin,",
                "    yMin,",
                "    xMax,",
                "    yMax",
                "  ) {",
                "    this.behavior = behavior;",
                "    this.xMin = xMin;",
                "    this.yMin = yMin;",
                "    this.xMax = xMax;",
                "    this.yMax = yMax;",
                "  };",
                "",
                "  setBounds(",
                "    xMin,",
                "    yMin,",
                "    xMax,",
                "    yMax",
                "  ) {",
                "    this.xMin = xMin;",
                "    this.yMin = yMin;",
                "    this.xMax = xMax;",
                "    this.yMax = yMax;",
                "  }",
                "",
                "  [Symbol.iterator]() {",
                "    // xMin and yMin next increment",
                "    let x = this.xMax;",
                "    let y = this.yMin - 1;",
                "    let hitbox = null;",
                "    let previousHitbox = null;",
                "    /** @type {IteratorReturnResult<gdjs.Polygon>} */",
                "    const result = { done: false, value: undefined };",
                "",
                "    return {",
                "      next: () => {",
                "        do {",
                "          x++;",
                "          if (x > this.xMax) {",
                "            y++;",
                "            x = this.xMin;",
                "          }",
                "          if (y > this.yMax) {",
                "            // done",
                "            result.done = true;",
                "            result.value = undefined;",
                "            return result;",
                "          }",
                "          hitbox = this.behavior.getHitbox(x, y);",
                "        }",
                "        while (!hitbox || hitbox === previousHitbox);",
                "",
                "        // happen with run-length encoding",
                "        previousHitbox = hitbox;",
                "        result.done = false;",
                "        result.value = hitbox;",
                "        return result;",
                "      },",
                "    };",
                "  };",
                "};",
                "",
                "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
                "gdjs.__marchingSquaresExtension.parseOperation = parseOperation;",
                "gdjs.__marchingSquaresExtension.HitboxesIterable = HitboxesIterable;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "Add to a Shape painter object and use the actions to draw a field. Useful for fog of wars, liquid effects (water, lava, blobs...).",
          "fullName": "Marching squares painter",
          "name": "MarchingSquaresBehavior",
          "objectType": "PrimitiveDrawing::Drawer",
          "eventsFunctions": [
            {
              "description": "Extend behavior class",
              "fullName": "Extend behavior class",
              "functionType": "Action",
              "name": "ExtendBehaviorClass",
              "private": true,
              "sentence": "Extend behavior class",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "const prototype = Object.getPrototypeOf(behavior);",
                    "if (!prototype.drawField) {",
                    "",
                    "  prototype.createField = function () {",
                    "    /** @type {float} */",
                    "    const left = this._getAreaLeftBound();",
                    "    /** @type {float} */",
                    "    const top = this._getAreaTopBound();",
                    "    /** @type {float} */",
                    "    const right = this._getAreaRightBound();",
                    "    /** @type {float} */",
                    "    const bottom = this._getAreaBottomBound();",
                    "    /** @type {float} */",
                    "    const cellWidth = this._getCellWidth();",
                    "    /** @type {float} */",
                    "    const cellHeight = this._getCellHeight();",
                    "",
                    "    // Build the scalar field",
                    "    const dimX = 1 + Math.ceil((right - left) / cellWidth);",
                    "    const dimY = 1 + Math.ceil((bottom - top) / cellHeight);",
                    "    const scalarField = new gdjs.__marchingSquaresExtension.ScalarField(dimX, dimY);",
                    "    this.scalarField = scalarField;",
                    "    ",
                    "    const coordConverter = new gdjs.__marchingSquaresExtension.CoordConverter(",
                    "      cellWidth,",
                    "      cellHeight,",
                    "      left,",
                    "      top,",
                    "      right,",
                    "      bottom);",
                    "    this.coordConverter = coordConverter;",
                    "",
                    "    const heightMap = new gdjs.__marchingSquaresExtension.HeightMap(scalarField, coordConverter);",
                    "    this.heightMap = heightMap;",
                    "",
                    "    const marchingSquares = new gdjs.__marchingSquaresExtension.MarchingSquares(scalarField);",
                    "    this.marchingSquares = marchingSquares;",
                    "",
                    "    /** @type {gdjs.Polygon[][]} */",
                    "    const hitboxTiles = new Array(dimY);",
                    "    for (var y = 0; y < dimY; y++) {",
                    "      hitboxTiles[y] = new Array(dimX).fill(null);",
                    "    }",
                    "    this.hitboxTiles = hitboxTiles;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param pointX {float} in scene basis",
                    "   * @param pointY {float} in scene basis",
                    "   * @return {boolean} true if the point is inside the contour",
                    "   */",
                    "  prototype.containsPoint = function (",
                    "    pointX,",
                    "    pointY,",
                    "  ) {",
                    "    /** @type {boolean} */",
                    "    const drawUnder = this._getFillOutside();",
                    "",
                    "    // It's a bit more precise than the contour",
                    "    // so it's not completly accurate.",
                    "    return !drawUnder && this.heightMap.getHeight(pointX, pointY) > this._getThreshold() ||",
                    "      drawUnder && this.heightMap.getHeight(pointX, pointY) < this._getThreshold();",
                    "  }",
                    "",
                    "  /**",
                    "   * Draw the field squares",
                    "   * @param minX {integer} left",
                    "   * @param minY {integer} top",
                    "   * @param maxX {integer} right",
                    "   * @param maxY {integer} bottom",
                    "   */",
                    "  prototype.drawField = function (",
                    "    minX,",
                    "    minY,",
                    "    maxX,",
                    "    maxY",
                    "  ) {",
                    "    /** @type {boolean} */",
                    "    const drawUnder = this._getFillOutside();",
                    "    /** @type {gdjs.ShapePainterRuntimeObject} */",
                    "    const shapePainter = this.owner;",
                    "    /** @type {float} */",
                    "    const threshold = this._getThreshold();",
                    "",
                    "    const fillOpacity = shapePainter.getFillOpacity();",
                    "    const outlineSize = shapePainter.getOutlineSize();",
                    "",
                    "    // It draws bands and small polygons.",
                    "    // The contour line is in a second loop, it's more efficient",
                    "    // than switching the style constantly.",
                    "",
                    "    const that = this;",
                    "    // fill",
                    "    if (fillOpacity !== 0) {",
                    "      shapePainter.setOutlineSize(0);",
                    "      this.marchingSquares.fillContour(",
                    "        minX,",
                    "        minY,",
                    "        maxX,",
                    "        maxY,",
                    "        threshold,",
                    "        drawUnder,",
                    "        {",
                    "          drawRectangle(left, top, right, bottom) {",
                    "            shapePainter.drawRectangle(",
                    "              that.coordConverter.convertFromGridBasisX(left),",
                    "              that.coordConverter.convertFromGridBasisY(top),",
                    "              that.coordConverter.convertFromGridBasisX(right),",
                    "              that.coordConverter.convertFromGridBasisY(bottom));",
                    "          },",
                    "          beginPath(x, y) {",
                    "            shapePainter.beginFillPath(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          lineTo(x, y) {",
                    "            shapePainter.drawPathLineTo(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          closePath() {",
                    "            shapePainter.closePath();",
                    "          },",
                    "          endPath() {",
                    "            shapePainter.endFillPath();",
                    "          },",
                    "          onFilledSquareChange(x, y) {",
                    "",
                    "          }",
                    "        }",
                    "      );",
                    "      shapePainter.setOutlineSize(outlineSize);",
                    "    }",
                    "    // outline",
                    "    if (outlineSize !== 0) {",
                    "      shapePainter.setFillOpacity(0);",
                    "      this.marchingSquares.outlineContour(",
                    "        minX,",
                    "        minY,",
                    "        maxX,",
                    "        maxY,",
                    "        threshold,",
                    "        drawUnder,",
                    "        {",
                    "          drawRectangle(left, top, right, bottom) {",
                    "          },",
                    "          beginPath(x, y) {",
                    "            shapePainter.beginFillPath(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          lineTo(x, y) {",
                    "            shapePainter.drawPathLineTo(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          closePath() {",
                    "            shapePainter.closePath();",
                    "          },",
                    "          endPath() {",
                    "            shapePainter.endFillPath();",
                    "          },",
                    "          onFilledSquareChange(x, y) {",
                    "",
                    "          }",
                    "        }",
                    "      );",
                    "    }",
                    "    shapePainter.setFillOpacity(fillOpacity);",
                    "  }",
                    "",
                    "  /**",
                    "   * Update the field hitboxes",
                    "   * @param minX {integer} left",
                    "   * @param minY {integer} top",
                    "   * @param maxX {integer} right",
                    "   * @param maxY {integer} bottom",
                    "   */",
                    "  prototype.updateMarchingSquareHitboxes = function (",
                    "    minX,",
                    "    minY,",
                    "    maxX,",
                    "    maxY",
                    "  ) {",
                    "    /** @type {boolean} */",
                    "    const drawUnder = this._getFillOutside();",
                    "    /** @type {float} */",
                    "    const threshold = this._getThreshold();",
                    "    /** @type {gdjs.ShapePainterRuntimeObject} */",
                    "    const shapePainter = this.owner;",
                    "",
                    "    const point = this.workingPoint;",
                    "",
                    "    // Move all Polygons to recycledPolygons",
                    "    if (this.recycledPolygons.length < shapePainter._defaultHitBoxes.length) {",
                    "      const swapPolygons = this.recycledPolygons;",
                    "      this.recycledPolygons = shapePainter._defaultHitBoxes;",
                    "      shapePainter._defaultHitBoxes = swapPolygons;",
                    "    }",
                    "    const hitboxes = shapePainter._defaultHitBoxes;",
                    "    this.recycledPolygons.push.apply(this, hitboxes);",
                    "    hitboxes.length = 0;",
                    "",
                    "    for (const hitboxRowTiles of this.hitboxTiles) {",
                    "      hitboxRowTiles.fill(null);",
                    "    }",
                    "    /** @type {gdjs.Polygon} */",
                    "    let currentRectangle = null;",
                    "    /** @type {gdjs.Polygon} */",
                    "    let currentPolygon = null;",
                    "    const that = this;",
                    "    this.marchingSquares.fillContour(",
                    "      minX,",
                    "      minY,",
                    "      maxX,",
                    "      maxY,",
                    "      threshold,",
                    "      drawUnder,",
                    "      {",
                    "        drawRectangle(left, top, right, bottom) {",
                    "          left = that.coordConverter.convertFromGridBasisX(left);",
                    "          top = that.coordConverter.convertFromGridBasisY(top);",
                    "          right = that.coordConverter.convertFromGridBasisX(right);",
                    "          bottom = that.coordConverter.convertFromGridBasisY(bottom);",
                    "          const vertices = currentRectangle.vertices;",
                    "",
                    "          vertices.length = 4;",
                    "          vertices[0] || (vertices[0] = [0, 0]);",
                    "          vertices[1] || (vertices[1] = [0, 0]);",
                    "          vertices[2] || (vertices[2] = [0, 0]);",
                    "          vertices[3] || (vertices[3] = [0, 0]);",
                    "",
                    "          vertices[0][0] = left;",
                    "          vertices[0][1] = top;",
                    "",
                    "          vertices[1][0] = right;",
                    "          vertices[1][1] = top;",
                    "",
                    "          vertices[2][0] = right;",
                    "          vertices[2][1] = bottom;",
                    "",
                    "          vertices[3][0] = left;",
                    "          vertices[3][1] = bottom;",
                    "          hitboxes.push(currentRectangle);",
                    "          currentRectangle = null;",
                    "        },",
                    "        beginPath(x, y) {",
                    "          currentPolygon = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();",
                    "          currentPolygon.vertices.length = 0;",
                    "          currentPolygon.vertices.push([",
                    "            that.coordConverter.convertFromGridBasisX(x),",
                    "            that.coordConverter.convertFromGridBasisY(y)]);",
                    "        },",
                    "        lineTo(x, y) {",
                    "          currentPolygon.vertices.push([",
                    "            that.coordConverter.convertFromGridBasisX(x),",
                    "            that.coordConverter.convertFromGridBasisY(y)]);",
                    "        },",
                    "        closePath() {",
                    "        },",
                    "        endPath(squareX, squareY) {",
                    "          hitboxes.push(currentPolygon);",
                    "          that.hitboxTiles[squareY][squareX] = currentPolygon;",
                    "        },",
                    "        onFilledSquareChange(squareX, squareY) {",
                    "          if (!currentRectangle) {",
                    "            currentRectangle = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();",
                    "          }",
                    "          that.hitboxTiles[squareY][squareX] = currentRectangle;",
                    "        }",
                    "      }",
                    "    );",
                    "",
                    "    shapePainter.hitBoxes = hitboxes;",
                    "    shapePainter.hitBoxesDirty = false;",
                    "    shapePainter.aabb.min[0] = this._getAreaLeftBound();",
                    "    shapePainter.aabb.min[1] = this._getAreaTopBound();",
                    "    shapePainter.aabb.max[0] = shapePainter.aabb.min[0] + (this.scalarField.dimX() - 1) * this._getCellWidth();",
                    "    shapePainter.aabb.max[1] = shapePainter.aabb.min[1] + (this.scalarField.dimY() - 1) * this._getCellHeight();",
                    "  }",
                    "",
                    "  /**",
                    "   * @param squareX {integer} x grid index",
                    "   * @param squareY {integer} y grid index",
                    "   * @return {gdjs.Polygon}",
                    "   */",
                    "  prototype.getHitbox = function (squareX, squareY) {",
                    "    return this.hitboxTiles[squareY][squareX];",
                    "  }",
                    "}",
                    "",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Extend object instance prototype.",
              "fullName": "Extend object instance prototype",
              "functionType": "Action",
              "name": "ExtendObjectInstancePrototype",
              "private": true,
              "sentence": "Extend _PARAM0_ prototype",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/**",
                    " * @type {Iterable<gdjs.Polygon>}",
                    " */",
                    "behavior.marchingSquaresHitBoxesIterable = new gdjs.__marchingSquaresExtension.HitboxesIterable(behavior, 0, 0, 0, 0);",
                    "",
                    "/** @type {gdjs.Polygon[]} Avoid allocations when updating hitboxes*/",
                    "behavior.recycledPolygons = [];",
                    "",
                    "behavior.owner.updateHitBoxes = function () {",
                    "  this.hitBoxesDirty = false;",
                    "}",
                    "",
                    "behavior.owner.getHitBoxesAround = function (",
                    "  left,",
                    "  top,",
                    "  right,",
                    "  bottom",
                    ") {",
                    "  const leftIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(left)));",
                    "  const topIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(top)));",
                    "  const rightIndex = Math.min(behavior.scalarField.dimX() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisX(right)));",
                    "  const bottomIndex = Math.min(behavior.scalarField.dimY() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisY(bottom)));",
                    "  /** @type {Iterable<gdjs.Polygon>} */",
                    "  const iterable = behavior.marchingSquaresHitBoxesIterable;",
                    "  iterable.setBounds(leftIndex, topIndex, rightIndex, bottomIndex);",
                    "  return iterable;",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "NumberVariable"
                      },
                      "parameters": [
                        "AreaRightBound",
                        "<=",
                        "AreaLeftBound"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "AreaRightBound",
                        "=",
                        "Object.Behavior::AreaLeft() + SceneWindowWidth()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "NumberVariable"
                      },
                      "parameters": [
                        "AreaBottomBound",
                        "<=",
                        "AreaTopBound"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "AreaBottomBound",
                        "=",
                        "AreaBottomBound + SceneWindowHeight()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GlobalVariableAsBoolean"
                      },
                      "parameters": [
                        "__marchingSquares.IsJavaScriptDefined",
                        "False"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetGlobalVariableAsBoolean"
                      },
                      "parameters": [
                        "__marchingSquares.IsJavaScriptDefined",
                        "True"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::DefineScalarFieldPainterLibrary"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::ExtendBehaviorClass"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::ExtendObjectInstancePrototype"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Clear the field by setting every values to 0.",
              "fullName": "Clear the field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "ClearField",
              "sentence": "Clear the field of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.clear();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Unfill an area of the field from a given location until a given height is reached.",
              "fullName": "Unfill area",
              "functionType": "Action",
              "group": "Field painting",
              "name": "UpsidedownFloodFrom",
              "sentence": "Unfill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a minimum of _PARAM4_ with thickness: _PARAM5_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const originX = eventsFunctionContext.getArgument(\"OriginX\");",
                    "const originY = eventsFunctionContext.getArgument(\"OriginY\");",
                    "const minimum = eventsFunctionContext.getArgument(\"Minimum\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.unfillFrom(originX, originY, minimum, thickness, cappingRadiusRatio);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Origin X",
                  "name": "OriginX",
                  "type": "expression"
                },
                {
                  "description": "Origin Y",
                  "name": "OriginY",
                  "type": "expression"
                },
                {
                  "description": "Minimum height",
                  "name": "Minimum",
                  "type": "expression"
                },
                {
                  "description": "Contour thickness",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Fill an area of the field from a given location until a given height is reached.",
              "fullName": "Fill area",
              "functionType": "Action",
              "group": "Field painting",
              "name": "FloodFrom",
              "sentence": "Fill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a maximum of _PARAM4_ with thickness: _PARAM5_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const originX = eventsFunctionContext.getArgument(\"OriginX\");",
                    "const originY = eventsFunctionContext.getArgument(\"OriginY\");",
                    "const maximum = eventsFunctionContext.getArgument(\"Maximum\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.fillFrom(originX, originY, maximum, thickness, cappingRadiusRatio);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Origin X",
                  "name": "OriginX",
                  "type": "expression"
                },
                {
                  "description": "Origin Y",
                  "name": "OriginY",
                  "type": "expression"
                },
                {
                  "description": "Maximum height",
                  "name": "Maximum",
                  "type": "expression"
                },
                {
                  "description": "Contour thickness",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Cap every value of the field to a range.",
              "fullName": "Clamp the field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "ClampField",
              "sentence": "Clamp the field of _PARAM0_ from: _PARAM2_ to: _PARAM3_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const min = eventsFunctionContext.getArgument(\"Minimum\");",
                    "const max = eventsFunctionContext.getArgument(\"Maximum\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.clamp(min, max);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Minimum",
                  "name": "Minimum",
                  "type": "expression"
                },
                {
                  "description": "Maximum",
                  "name": "Maximum",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Apply an affine on the field values.",
              "fullName": "Transform the field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "TransformField",
              "sentence": "Transform the field of _PARAM0_ with a coefficient: _PARAM2_ and an offset: _PARAM3_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const a = eventsFunctionContext.getArgument(\"Coefficient\");",
                    "const b = eventsFunctionContext.getArgument(\"Offset\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.transform(a, b);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Coefficient",
                  "name": "Coefficient",
                  "type": "expression"
                },
                {
                  "description": "Offset",
                  "name": "Offset",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Add a hill to the field.",
              "fullName": "Add a hill",
              "functionType": "Action",
              "group": "Field painting",
              "name": "AddHill",
              "sentence": "Add a hill to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, _PARAM4_, radius: _PARAM5_, opacity: _PARAM6_ using: _PARAM8_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                    "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                    "const height = Math.max(1, eventsFunctionContext.getArgument(\"Height\"));",
                    "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                    "const opacity = eventsFunctionContext.getArgument(\"Opacity\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Center X",
                  "name": "CenterX",
                  "type": "expression"
                },
                {
                  "description": "Center Y",
                  "name": "CenterY",
                  "type": "expression"
                },
                {
                  "description": "Height",
                  "longDescription": "The hill height at the center, a value of 1 or less means a flat hill.",
                  "name": "Height",
                  "type": "expression"
                },
                {
                  "description": "Radius",
                  "longDescription": "The hill height is 1 at this radius.",
                  "name": "Radius",
                  "type": "expression"
                },
                {
                  "description": "Opacity",
                  "longDescription": "Set to 1 to apply the hill instantly or repeat this action with a lower value to make is progressive.",
                  "name": "Opacity",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Add a disk to the field.",
              "fullName": "Add a disk",
              "functionType": "Action",
              "group": "Field painting",
              "name": "AddDisk",
              "sentence": "Add a disk to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_ using: _PARAM6_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                    "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                    "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Center X",
                  "name": "CenterX",
                  "type": "expression"
                },
                {
                  "description": "Center Y",
                  "name": "CenterY",
                  "type": "expression"
                },
                {
                  "description": "Radius",
                  "longDescription": "The spike height is 1 at this radius.",
                  "name": "Radius",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Mask a disk to the field.",
              "fullName": "Mask a disk",
              "functionType": "Action",
              "group": "Field painting",
              "name": "MaskDisk",
              "sentence": "Mask a disk on the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                    "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                    "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const cappingRadius = cappingRadiusRatio * radius;",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Center X",
                  "name": "CenterX",
                  "type": "expression"
                },
                {
                  "description": "Center Y",
                  "name": "CenterY",
                  "type": "expression"
                },
                {
                  "description": "Radius",
                  "longDescription": "The spike height is 1 at this radius.",
                  "name": "Radius",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Add a line to the field.",
              "fullName": "Add a line",
              "functionType": "Action",
              "group": "Field painting",
              "name": "AddLine",
              "sentence": "Add a line to the field of _PARAM0_ from _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with thickness: _PARAM6_ using: _PARAM8_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const startX = eventsFunctionContext.getArgument(\"StartX\");",
                    "const startY = eventsFunctionContext.getArgument(\"StartY\");",
                    "const endX = eventsFunctionContext.getArgument(\"EndX\");",
                    "const endY = eventsFunctionContext.getArgument(\"EndY\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the start",
                  "name": "StartX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the start",
                  "name": "StartY",
                  "type": "expression"
                },
                {
                  "description": "X position of the end",
                  "name": "EndX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the end",
                  "name": "EndY",
                  "type": "expression"
                },
                {
                  "description": "Thickness",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Mask a line to the field.",
              "fullName": "Mask a line",
              "functionType": "Action",
              "group": "Field painting",
              "name": "MaskLine",
              "sentence": "Mask a line on the field of _PARAM0_ from _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with thickness: _PARAM6_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const startX = eventsFunctionContext.getArgument(\"StartX\");",
                    "const startY = eventsFunctionContext.getArgument(\"StartY\");",
                    "const endX = eventsFunctionContext.getArgument(\"EndX\");",
                    "const endY = eventsFunctionContext.getArgument(\"EndY\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the start",
                  "name": "StartX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the start",
                  "name": "StartY",
                  "type": "expression"
                },
                {
                  "description": "X position of the end",
                  "name": "EndX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the end",
                  "name": "EndY",
                  "type": "expression"
                },
                {
                  "description": "Thickness",
                  "longDescription": "The spike height is 1 at this radius.",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Apply a given operation on every value of the field using the value from the other field at the same position.",
              "fullName": "Merge a field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "MergeField",
              "sentence": "Merge _PARAM0_ with the field of _PARAM2_ using: _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const fieldObjects = eventsFunctionContext.getObjects(\"FieldObject\");",
                    "const fieldBehaviorName = eventsFunctionContext.getArgument(\"FieldBehavior\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/** @type {Array<number[]>} */",
                    "const fieldValues = behavior.scalarFieldValues;",
                    "",
                    "for (const fieldObject of fieldObjects) {",
                    "    const otherBehavior = fieldObject.getBehavior(behaviorName);",
                    "    if (!otherBehavior) {",
                    "        continue;",
                    "    }",
                    "    behavior.scalarField.mergeField(otherBehavior.scalarField, operation);",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Field object",
                  "name": "FieldObject",
                  "type": "objectList"
                },
                {
                  "description": "Field behavior",
                  "name": "FieldBehavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\",\"Minimum\",\"Multiplication\",\"Division\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Update the field hitboxes.",
              "fullName": "Update hitboxes",
              "functionType": "Action",
              "group": "Field evaluation",
              "name": "UpdateHitboxes",
              "sentence": "Update the field hitboxes of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.updateMarchingSquareHitboxes(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Draw the field contours.",
              "fullName": "Draw the contours",
              "functionType": "Action",
              "group": "Field evaluation",
              "name": "DrawField",
              "sentence": "Draw the field contours of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const screenWidth = runtimeScene.getGame().getGameResolutionWidth();",
                    "const screenHeight = runtimeScene.getGame().getGameResolutionHeight();",
                    "",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const object = objects[0];",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "if (behavior._behaviorData.MustOnlyDrawScreen) {",
                    "    const layer = runtimeScene.getLayer(object.getLayer());",
                    "    const screen1 = layer.convertCoords(0, 0);",
                    "    const screen2 = layer.convertCoords(screenWidth, 0);",
                    "    const screen3 = layer.convertCoords(0, screenHeight);",
                    "    const screen4 = layer.convertCoords(screenWidth, screenHeight);",
                    "",
                    "    const screenLeft = Math.min(screen1[0], screen2[0], screen3[0], screen4[0]);",
                    "    const screenTop = Math.min(screen1[1], screen2[1], screen3[1], screen4[1]);",
                    "    const screenRight = Math.max(screen1[0], screen2[0], screen3[0], screen4[0]);",
                    "    const screenBottom = Math.max(screen1[1], screen2[1], screen3[1], screen4[1]);",
                    "",
                    "    const minX = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(screenLeft)));",
                    "    const minY = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(screenTop)));",
                    "",
                    "    const maxX = Math.min(behavior.scalarField.dimX(), 1 + Math.ceil(behavior.coordConverter.convertToGridBasisX(screenRight)));",
                    "    const maxY = Math.min(behavior.scalarField.dimY(), 1 + Math.ceil(behavior.coordConverter.convertToGridBasisY(screenBottom)));",
                    "",
                    "    behavior.drawField(minX, minY, maxX, maxY);",
                    "}",
                    "else {",
                    "    // This is useful for static content or games without scrolling.",
                    "    behavior.drawField(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the width of the field cells.",
              "fullName": "Width of the cells",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetCellWidth",
              "sentence": "Change the width of the field cells of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "CellWidth",
                        "=",
                        "Value"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the height of the field cells.",
              "fullName": "Height of the cells",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetCellHeight",
              "sentence": "Change the height of the field cells of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "CellHeight",
                        "=",
                        "Value"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Rebuild the field with the new dimensions.",
              "fullName": "Rebuild the field",
              "functionType": "Action",
              "name": "RebuildField",
              "private": true,
              "sentence": "Rebuild the field _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/** @type {float} */",
                    "const left = behavior._getAreaLeftBound();",
                    "/** @type {float} */",
                    "const top = behavior._getAreaTopBound();",
                    "/** @type {float} */",
                    "const right = behavior._getAreaRightBound() || game.getGameResolutionWidth();",
                    "/** @type {float} */",
                    "const bottom = behavior._getAreaBottomBound() || game.getGameResolutionHeight();",
                    "/** @type {float} */",
                    "const cellWidth = behavior._getCellWidth();",
                    "/** @type {float} */",
                    "const cellHeight = behavior._getCellHeight();",
                    "",
                    "behavior.createField();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Fill outside or inside of the contours.",
              "fullName": "Fill outside",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetFillOutside",
              "sentence": "Fill outside of the contours of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetBooleanVariable"
                      },
                      "parameters": [
                        "FillOutside",
                        "False",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BooleanVariable"
                      },
                      "parameters": [
                        "Value",
                        "True",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetBooleanVariable"
                      },
                      "parameters": [
                        "FillOutside",
                        "True",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Fill outside?",
                  "name": "Value",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the contour threshold.",
              "fullName": "Contour threshold",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetThreshold",
              "sentence": "Change the contour threshold of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "Threshold",
                        "=",
                        "Value"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the field area bounds.",
              "fullName": "Area bounds",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetAreaBounds",
              "sentence": "Change the field area bounds of _PARAM0_ left: _PARAM2_ top: _PARAM3_ right: _PARAM4_ bottom: _PARAM5_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "AreaLeftBound",
                        "=",
                        "LeftBound"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "AreaTopBound",
                        "=",
                        "TopBound"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "AreaRightBound",
                        "=",
                        "RightBound"
                      ]
                    },
                    {
                      "type": {
                        "value": "SetNumberVariable"
                      },
                      "parameters": [
                        "AreaBottomBound",
                        "=",
                        "BottomBound"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Left bound",
                  "name": "LeftBound",
                  "type": "expression"
                },
                {
                  "description": "Top bound",
                  "name": "TopBound",
                  "type": "expression"
                },
                {
                  "description": "Right bound",
                  "name": "RightBound",
                  "type": "expression"
                },
                {
                  "description": "Bottom bound",
                  "name": "BottomBound",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area left bound of the field.",
              "fullName": "Area left",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaLeft",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "AreaLeftBound"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area top bound of the field.",
              "fullName": "Area top",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaTop",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "AreaTopBound"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area right bound of the field.",
              "fullName": "Area right",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaRight",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "AreaRightBound"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Egal"
                      },
                      "parameters": [
                        "AreaLeftBound",
                        "=",
                        "AreaRightBound"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "AreaLeftBound + SceneWindowWidth()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area bottom bound of the field.",
              "fullName": "Area bottom",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaBottom",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "AreaBottomBound"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Egal"
                      },
                      "parameters": [
                        "AreaTopBound",
                        "=",
                        "AreaBottomBound"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "AreaTopBound + SceneWindowHeight()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Width of the field cells.",
              "fullName": "Width of a cell",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "CellWidth",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CellWidth"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Height of the field cells.",
              "fullName": "Height of a cell",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "CellHeight",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "CellHeight"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The number of cells on the x axis.",
              "fullName": "Dimension X",
              "functionType": "Expression",
              "group": "Field saving",
              "name": "DimensionX",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.dimX();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The number of cells on the y axis.",
              "fullName": "Dimension Y",
              "functionType": "Expression",
              "group": "Field saving",
              "name": "DimensionY",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.dimY();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The contour threshold.",
              "fullName": "Contour threshold",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "ContourThreshold",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Threshold"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The normal X coordinate at a given location.",
              "fullName": "Normal X",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "NormalX",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[0];"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The normal Y coordinate at a given location.",
              "fullName": "Normal Y",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "NormalY",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[1];"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The normal Z coordinate at a given location.",
              "fullName": "Normal Z",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "NormalZ",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[2];"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the field value at a grid point.",
              "fullName": "Grid value",
              "functionType": "Action",
              "group": "Field loading",
              "name": "SetGridValue",
              "sentence": "Change the field value of _PARAM0_ at the grid point _PARAM2_; _PARAM3_ to _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                    "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.set(indexX, indexY, value);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X grid index",
                  "name": "IndexX",
                  "type": "expression"
                },
                {
                  "description": "Y grid index",
                  "name": "IndexY",
                  "type": "expression"
                },
                {
                  "description": "Field value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The field value at a grid point.",
              "fullName": "Grid value",
              "functionType": "Expression",
              "group": "Field saving",
              "name": "GridValue",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                    "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.get(indexX, indexY);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X grid index",
                  "name": "IndexX",
                  "type": "expression"
                },
                {
                  "description": "Y grid index",
                  "name": "IndexY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The field value at a given location.",
              "fullName": "Field value",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "FieldValue",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the contours are filled outside.",
              "fullName": "Fill outside",
              "functionType": "Condition",
              "group": "Field configuration",
              "name": "CheckFillOutside",
              "sentence": "The contours of _PARAM0_ are filled outside",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "False"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "BooleanVariable"
                      },
                      "parameters": [
                        "FillOutside",
                        "True",
                        ""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if a field is greater than a given value.",
              "fullName": "Field value",
              "functionType": "Condition",
              "group": "Field evaluation",
              "name": "CheckFieldValue",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY) > value;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if a point is inside the contour.",
              "fullName": "Point is inside",
              "functionType": "Condition",
              "group": "Field evaluation",
              "name": "ContainsPoint",
              "sentence": "_PARAM2_; _PARAM3_ is inside _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.containsPoint(pointX, pointY);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area left bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaLeftBound"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area top bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaTopBound"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area right bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaRightBound"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area bottom bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaBottomBound"
            },
            {
              "value": "20",
              "type": "Number",
              "unit": "Pixel",
              "label": "Cell width",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "CellWidth"
            },
            {
              "value": "20",
              "type": "Number",
              "unit": "Pixel",
              "label": "Cell height",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "CellHeight"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Fill outside",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "FillOutside"
            },
            {
              "value": "1",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "Contour threshold",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Threshold"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Must only draw what is on the screen",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "MustOnlyDrawScreen"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    },
    {
      "author": "",
      "category": "General",
      "extensionNamespace": "",
      "fullName": "3D sprite",
      "gdevelopVersion": ">=5.5.222",
      "helpPath": "/objects/sprite/",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWdob3N0LW91dGxpbmUiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIgMkM3LjAzIDIgMyA2LjAzIDMgMTFWMjJMNiAxOUw5IDIyTDEyIDE5TDE1IDIyTDE4IDE5TDIxIDIyVjExQzIxIDYuMDMgMTYuOTcgMiAxMiAyTTE5IDE3LjE3TDE4IDE2LjE3TDE2LjU5IDE3LjU5TDE1IDE5LjE3TDEzLjQxIDE3LjU5TDEyIDE2LjE3TDEwLjU5IDE3LjU5TDkgMTkuMTdMNy40MSAxNy41OUw2IDE2LjE3TDUgMTcuMTdWMTFDNSA3LjE0IDguMTQgNCAxMiA0UzE5IDcuMTQgMTkgMTFWMTcuMTdNMTEgMTBDMTEgMTEuMTEgMTAuMTEgMTIgOSAxMlM3IDExLjExIDcgMTAgNy45IDggOSA4IDExIDguOSAxMSAxME0xNyAxMEMxNyAxMS4xMSAxNi4xMSAxMiAxNSAxMlMxMyAxMS4xMSAxMyAxMCAxMy45IDggMTUgOCAxNyA4LjkgMTcgMTBaIiAvPjwvc3ZnPg==",
      "name": "Sprite3D",
      "previewIconUrl": "https://asset-resources.gdevelop.io/public-resources/Icons/3bd33ec77ed20d3f631c6c92884728b375aa2879174bc9f289c864d0e0383d59_ghost-outline.svg",
      "shortDescription": "An animated sprite in 3D.",
      "version": "0.1.2",
      "description": "The 3D sprite is an object that can be moved and rotated in 3D.",
      "origin": {
        "identifier": "Sprite3D",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "3d"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "globalVariables": [],
      "sceneVariables": [],
      "eventsFunctions": [
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs.__sprite3DExtension) {",
                "    return;",
                "}",
                "",
                "const vertexColors = [];",
                "",
                "class Sprite3DRenderer {",
                "    /** @type {gdjs.CustomRuntimeObject} */",
                "    object;",
                "    /** @type {THREE.Mesh} */",
                "    mesh;",
                "",
                "    /**",
                "     * @param object {gdjs.CustomRuntimeObject}",
                "     */",
                "    constructor(object) {",
                "        this.object = object;",
                "",
                "        const geometry = new THREE.PlaneGeometry(1, -1);",
                "        const animationFrame = object.getAnimator().getCurrentFrame();",
                "        if (animationFrame) {",
                "            const material = animationFrame.texture;",
                "            this.mesh = new THREE.Mesh(geometry, material);",
                "            this.mesh.rotation.order = 'ZYX';",
                "            object.get3DRendererObject().add(this.mesh);",
                "            // Ensure a forward compatibility when vertexColors will be set to true",
                "            // in the engine to allow to tint 3D sprites.",
                "            vertexColors.length = geometry.attributes.position.count * 3;",
                "            vertexColors.fill(1);",
                "            geometry.setAttribute(",
                "                'color',",
                "                new THREE.BufferAttribute(new Float32Array(vertexColors), 3)",
                "            );",
                "        }",
                "        this.updateFrame();",
                "        object.getAnimator().setOnFrameChangeCallback(() => this.updateFrame());",
                "    }",
                "",
                "    updateFrame() {",
                "        const frame = this.object.getAnimator().getCurrentFrame();",
                "        if (!frame) {",
                "            return;",
                "        }",
                "        const material = frame.texture;",
                "",
                "        const image = material.map.image;",
                "        const width = image.width;",
                "        const height = image.height;",
                "        const origin = frame.origin;",
                "        this.mesh.position.set(-origin.x + width / 2, -origin.y + height / 2, 0);",
                "        this.mesh.scale.set(width, height, 1);",
                "",
                "        const center = frame.center;",
                "        this.object.setRotationCenter(center.x - origin.x, center.y - origin.y);",
                "",
                "        this.mesh.material = material;",
                "",
                "        const hitBoxes = this.object._untransformedHitBoxes;",
                "        if (frame.hasCustomCollisionMask) {",
                "            let i = 0;",
                "            for (let len = frame.customCollisionMask.length; i < len; ++i) {",
                "                const polygonData = frame.customCollisionMask[i];",
                "",
                "                // Add a polygon, if necessary (Avoid recreating a polygon if it already exists).",
                "                if (i >= hitBoxes.length) {",
                "                    hitBoxes.push(new gdjs.Polygon());",
                "                }",
                "                let j = 0;",
                "                for (const len2 = polygonData.length; j < len2; ++j) {",
                "                    const pointData = polygonData[j];",
                "",
                "                    // Add a point, if necessary (Avoid recreating a point if it already exists).",
                "                    if (j >= hitBoxes[i].vertices.length) {",
                "                        hitBoxes[i].vertices.push([0, 0]);",
                "                    }",
                "                    hitBoxes[i].vertices[j][0] = pointData.x - origin.x;",
                "                    hitBoxes[i].vertices[j][1] = pointData.y - origin.y;",
                "                }",
                "                hitBoxes[i].vertices.length = j;",
                "            }",
                "            hitBoxes.length = i;",
                "        }",
                "        else if (hitBoxes.length === 0) {",
                "            const hitBox = new gdjs.Polygon();",
                "            hitBoxes.push(hitBox);",
                "            const vertices = hitBox.vertices;",
                "            vertices.push([-origin.x, -origin.y]);",
                "            vertices.push([-origin.x + width, -origin.y]);",
                "            vertices.push([-origin.x + width, -origin.y + height]);",
                "            vertices.push([-origin.x, -origin.y + height]);",
                "        }",
                "",
                "        const aabb = this.object._unrotatedAABB;",
                "        aabb.min[0] = -origin.x;",
                "        aabb.min[1] = -origin.y;",
                "        aabb.max[0] = -origin.x + width;",
                "        aabb.max[1] = -origin.y + height;",
                "",
                "        this.object._isUntransformedHitBoxesDirty = false;",
                "    }",
                "}",
                "",
                "gdjs.__sprite3DExtension = {",
                "    Sprite3DRenderer",
                "};",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": [
        {
          "areaMaxX": 64,
          "areaMaxY": 64,
          "areaMaxZ": 64,
          "areaMinX": 0,
          "areaMinY": 0,
          "areaMinZ": 0,
          "defaultName": "",
          "description": "An animated sprite in 3D.",
          "fullName": "3D sprite",
          "is3D": true,
          "isAnimatable": true,
          "isUsingLegacyInstancesRenderer": true,
          "name": "Sprite3D",
          "objects": [],
          "objectsFolderStructure": {
            "folderName": "__ROOT"
          },
          "objectsGroups": [],
          "layers": [
            {
              "ambientLightColorB": 200,
              "ambientLightColorG": 200,
              "ambientLightColorR": 200,
              "camera3DFarPlaneDistance": 10000,
              "camera3DFieldOfView": 45,
              "camera3DNearPlaneDistance": 3,
              "cameraType": "",
              "followBaseLayerCamera": false,
              "isLightingLayer": false,
              "isLocked": false,
              "name": "",
              "renderingType": "",
              "visibility": true,
              "cameras": [
                {
                  "defaultSize": true,
                  "defaultViewport": true,
                  "height": 0,
                  "viewportBottom": 1,
                  "viewportLeft": 0,
                  "viewportRight": 1,
                  "viewportTop": 0,
                  "width": 0
                }
              ],
              "effects": []
            }
          ],
          "instances": [],
          "eventsFunctions": [
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Sprite3D::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "/** @type {gdjs.CustomRuntimeObject} */\r",
                    "const object = objects[0];\r",
                    "\r",
                    "object.__sprite3DExtension = {};\r",
                    "object.__sprite3DExtension.sprite3DRenderer = new gdjs.__sprite3DExtension.Sprite3DRenderer(object)\r",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "Sprite3D::Sprite3D",
                  "type": "object"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [],
          "variants": []
        }
      ]
    }
  ],
  "externalLayouts": []
}