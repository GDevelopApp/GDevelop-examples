{
  "firstLayout": "",
  "gdVersion": {
    "build": 99,
    "major": 4,
    "minor": 0,
    "revision": 0
  },
  "properties": {
    "adaptGameResolutionAtRuntime": true,
    "antialiasingMode": "MSAA",
    "antialisingEnabledOnMobile": false,
    "folderProject": false,
    "orientation": "landscape",
    "packageName": "com.example.island.generator",
    "pixelsRounding": false,
    "projectUuid": "4df513c8-f0f4-4e16-943f-3750934f8465",
    "scaleMode": "linear",
    "sizeOnStartupMode": "",
    "templateSlug": "",
    "useExternalSourceFiles": false,
    "version": "1.0.0",
    "name": "Island Generator",
    "description": "",
    "author": "",
    "windowWidth": 800,
    "windowHeight": 600,
    "latestCompilationDirectory": "C:\\Users\\davyh\\Documents\\GDevelop projects\\_Export\\marching-squares-island-generator",
    "maxFPS": 60,
    "minFPS": 20,
    "verticalSync": false,
    "platformSpecificAssets": {},
    "loadingScreen": {
      "backgroundColor": 0,
      "backgroundFadeInDuration": 0.2,
      "backgroundImageResourceName": "",
      "gdevelopLogoStyle": "light",
      "logoAndProgressFadeInDuration": 0.2,
      "logoAndProgressLogoFadeInDelay": 0.2,
      "minDuration": 1.5,
      "progressBarColor": 16777215,
      "progressBarHeight": 20,
      "progressBarMaxWidth": 200,
      "progressBarMinWidth": 40,
      "progressBarWidthPercent": 30,
      "showGDevelopSplash": true,
      "showProgressBar": true
    },
    "watermark": {
      "placement": "bottom-left",
      "showWatermark": true
    },
    "authorIds": [
      "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
    ],
    "authorUsernames": [],
    "categories": [],
    "playableDevices": [],
    "extensionProperties": [],
    "platforms": [
      {
        "name": "GDevelop JS platform"
      }
    ],
    "currentPlatform": "GDevelop JS platform"
  },
  "resources": {
    "resources": [
      {
        "alwaysLoaded": false,
        "file": "assets/EnableNoiseButton.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\EnableNoiseButton.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/DisableNoiseButton.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\DisableNoiseButton.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/RerollTerrainButton.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\RerollTerrainButton.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/RerollIslandButton.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\RerollIslandButton.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/EnableConstraintButton.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\EnableConstraintButton.png",
        "smoothed": true,
        "userAdded": true
      },
      {
        "alwaysLoaded": false,
        "file": "assets/DisableConstraintButton.png",
        "kind": "image",
        "metadata": "",
        "name": "assets\\DisableConstraintButton.png",
        "smoothed": true,
        "userAdded": true
      }
    ],
    "resourceFolders": []
  },
  "objects": [],
  "objectsFolderStructure": {
    "folderName": "__ROOT"
  },
  "objectsGroups": [],
  "variables": [],
  "layouts": [
    {
      "b": 85,
      "disableInputWhenNotFocused": true,
      "mangledName": "IslandGenerator",
      "name": "IslandGenerator",
      "r": 25,
      "standardSortMethod": true,
      "stopSoundsOnStartup": true,
      "title": "Island Generator",
      "v": 52,
      "uiSettings": {
        "grid": true,
        "gridType": "rectangular",
        "gridWidth": 48,
        "gridHeight": 48,
        "gridOffsetX": 0,
        "gridOffsetY": 0,
        "gridColor": 10401023,
        "gridAlpha": 0.8,
        "snap": true,
        "zoomFactor": 0.6533333534240722,
        "windowMask": false
      },
      "objectsGroups": [
        {
          "name": "Field",
          "objects": [
            {
              "name": "HeightField"
            },
            {
              "name": "ContourLine"
            },
            {
              "name": "TerrainRangeSizeField"
            },
            {
              "name": "TerrainLowerBoundField"
            }
          ]
        }
      ],
      "variables": [
        {
          "name": "Stroke",
          "type": "string",
          "value": "48"
        },
        {
          "name": "Palette",
          "type": "array",
          "children": [
            {
              "type": "structure",
              "children": [
                {
                  "name": "Color",
                  "type": "string",
                  "value": "25;52;85"
                },
                {
                  "name": "Threshold",
                  "type": "number",
                  "value": 0
                }
              ]
            },
            {
              "type": "structure",
              "children": [
                {
                  "name": "Color",
                  "type": "string",
                  "value": "49;99;160"
                },
                {
                  "name": "Threshold",
                  "type": "string",
                  "value": "0.35"
                }
              ]
            },
            {
              "type": "structure",
              "children": [
                {
                  "name": "Color",
                  "type": "string",
                  "value": "248;231;28"
                },
                {
                  "name": "Threshold",
                  "type": "string",
                  "value": "0.5"
                }
              ]
            },
            {
              "type": "structure",
              "children": [
                {
                  "name": "Color",
                  "type": "string",
                  "value": "126;211;33"
                },
                {
                  "name": "Threshold",
                  "type": "string",
                  "value": "0.6"
                }
              ]
            },
            {
              "type": "structure",
              "children": [
                {
                  "name": "Color",
                  "type": "string",
                  "value": "115;60;44"
                },
                {
                  "name": "Threshold",
                  "type": "string",
                  "value": "0.75"
                }
              ]
            },
            {
              "type": "structure",
              "children": [
                {
                  "name": "Color",
                  "type": "string",
                  "value": "136;107;99"
                },
                {
                  "name": "Threshold",
                  "type": "number",
                  "value": 1
                }
              ]
            }
          ]
        },
        {
          "name": "HeightMax",
          "type": "string",
          "value": "8"
        },
        {
          "name": "CellSize",
          "type": "string",
          "value": "5"
        },
        {
          "name": "ContourCount",
          "type": "string",
          "value": "16"
        },
        {
          "name": "IsNoiseEnable",
          "type": "boolean",
          "value": true
        },
        {
          "name": "IsIslandConstraintEnable",
          "type": "boolean",
          "value": true
        }
      ],
      "instances": [
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "NormalLabel",
          "persistentUuid": "e903209e-4472-4141-8442-17e91964a83d",
          "width": 0,
          "x": 0,
          "y": 576,
          "zOrder": 26,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "HeightField",
          "persistentUuid": "77478141-6a68-44b8-80cf-fae809014a85",
          "width": 0,
          "x": 83,
          "y": -47,
          "zOrder": 27,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "TerrainRangeSizeField",
          "persistentUuid": "641d8189-2df2-4db4-aecf-e31c88822c02",
          "width": 0,
          "x": 192,
          "y": -48,
          "zOrder": 46,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "TerrainLowerBoundField",
          "persistentUuid": "4050989a-cd72-461b-8227-f8711c45cd48",
          "width": 0,
          "x": 240,
          "y": -48,
          "zOrder": 47,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "ValueLabel",
          "persistentUuid": "10736f96-a3cd-4bb5-afba-4eff343b5802",
          "width": 0,
          "x": 0,
          "y": 553,
          "zOrder": 48,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "RerollIslandButton",
          "persistentUuid": "c440a95d-f19e-42d6-8504-dc3a67a871cf",
          "width": 0,
          "x": 0,
          "y": 416,
          "zOrder": 49,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "RerollTerrainButton",
          "persistentUuid": "b8133f7b-27ef-41ac-9a1e-c6f50325feee",
          "width": 0,
          "x": 0,
          "y": 320,
          "zOrder": 50,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "ToogleNoiseButton",
          "persistentUuid": "edcefaca-4bc5-422c-8013-51e911a7eed2",
          "width": 0,
          "x": 0,
          "y": 128,
          "zOrder": 51,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "",
          "name": "ToogleConstraintButton",
          "persistentUuid": "0be34847-0509-4966-99e6-d5916ccdc803",
          "width": 0,
          "x": 0,
          "y": 224,
          "zOrder": 52,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        },
        {
          "angle": 0,
          "customSize": false,
          "height": 0,
          "layer": "UI",
          "name": "Directions",
          "persistentUuid": "48fcfde1-fdb7-4409-a1c0-a145e79421e8",
          "width": 0,
          "x": 229,
          "y": 274,
          "zOrder": 53,
          "numberProperties": [],
          "stringProperties": [],
          "initialVariables": []
        }
      ],
      "objects": [
        {
          "assetStoreId": "",
          "name": "HeightField",
          "type": "PrimitiveDrawing::Drawer",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "MarchingSquaresBehavior",
              "type": "MarchingSquares::MarchingSquaresBehavior",
              "DrawOutside": true,
              "FillOutside": false,
              "CellHeight": 10,
              "CellWidth": 10
            }
          ],
          "fillOpacity": 255,
          "outlineSize": 0,
          "outlineOpacity": 255,
          "fillColor": {
            "b": 0,
            "g": 0,
            "r": 0
          },
          "outlineColor": {
            "b": 35,
            "g": 166,
            "r": 245
          },
          "absoluteCoordinates": true,
          "clearBetweenFrames": false,
          "antialiasing": "none"
        },
        {
          "assetStoreId": "",
          "name": "ContourLine",
          "type": "PrimitiveDrawing::Drawer",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "MarchingSquaresBehavior",
              "type": "MarchingSquares::MarchingSquaresBehavior",
              "AreaLeftBound": 0,
              "AreaTopBound": 0,
              "AreaRightBound": 0,
              "AreaBottomBound": 0,
              "CellWidth": 10,
              "CellHeight": 10,
              "FillOutside": false,
              "Threshold": 1,
              "MustOnlyDrawScreen": false
            }
          ],
          "fillOpacity": 255,
          "outlineSize": 0,
          "outlineOpacity": 255,
          "fillColor": {
            "b": 255,
            "g": 255,
            "r": 255
          },
          "outlineColor": {
            "b": 0,
            "g": 0,
            "r": 0
          },
          "absoluteCoordinates": true,
          "clearBetweenFrames": false,
          "antialiasing": "none"
        },
        {
          "assetStoreId": "",
          "name": "TerrainRangeSizeField",
          "type": "PrimitiveDrawing::Drawer",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "MarchingSquaresBehavior",
              "type": "MarchingSquares::MarchingSquaresBehavior",
              "DrawOutside": true,
              "FillOutside": false,
              "CellHeight": 10,
              "CellWidth": 10
            }
          ],
          "fillOpacity": 255,
          "outlineSize": 0,
          "outlineOpacity": 255,
          "fillColor": {
            "b": 0,
            "g": 0,
            "r": 0
          },
          "outlineColor": {
            "b": 35,
            "g": 166,
            "r": 245
          },
          "absoluteCoordinates": true,
          "clearBetweenFrames": false,
          "antialiasing": "none"
        },
        {
          "assetStoreId": "",
          "name": "TerrainLowerBoundField",
          "type": "PrimitiveDrawing::Drawer",
          "variables": [],
          "effects": [],
          "behaviors": [
            {
              "name": "MarchingSquaresBehavior",
              "type": "MarchingSquares::MarchingSquaresBehavior",
              "DrawOutside": true,
              "FillOutside": false,
              "CellHeight": 10,
              "CellWidth": 10
            }
          ],
          "fillOpacity": 255,
          "outlineSize": 0,
          "outlineOpacity": 255,
          "fillColor": {
            "b": 0,
            "g": 0,
            "r": 0
          },
          "outlineColor": {
            "b": 35,
            "g": 166,
            "r": 245
          },
          "absoluteCoordinates": true,
          "clearBetweenFrames": false,
          "antialiasing": "none"
        },
        {
          "adaptCollisionMaskAutomatically": false,
          "assetStoreId": "",
          "name": "ToogleNoiseButton",
          "type": "Sprite",
          "updateIfNotVisible": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "animations": [
            {
              "name": "Disable",
              "useMultipleDirections": false,
              "directions": [
                {
                  "looping": false,
                  "timeBetweenFrames": 0.07999999821186066,
                  "sprites": [
                    {
                      "hasCustomCollisionMask": false,
                      "image": "assets\\DisableNoiseButton.png",
                      "points": [],
                      "originPoint": {
                        "name": "origine",
                        "x": 0,
                        "y": 0
                      },
                      "centerPoint": {
                        "automatic": true,
                        "name": "centre",
                        "x": 0,
                        "y": 0
                      },
                      "customCollisionMask": []
                    }
                  ]
                }
              ]
            },
            {
              "name": "Enable",
              "useMultipleDirections": false,
              "directions": [
                {
                  "looping": false,
                  "timeBetweenFrames": 0.07999999821186066,
                  "sprites": [
                    {
                      "hasCustomCollisionMask": false,
                      "image": "assets\\EnableNoiseButton.png",
                      "points": [],
                      "originPoint": {
                        "name": "origine",
                        "x": 0,
                        "y": 0
                      },
                      "centerPoint": {
                        "automatic": true,
                        "name": "centre",
                        "x": 0,
                        "y": 0
                      },
                      "customCollisionMask": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "adaptCollisionMaskAutomatically": false,
          "assetStoreId": "",
          "name": "ToogleConstraintButton",
          "type": "Sprite",
          "updateIfNotVisible": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "animations": [
            {
              "name": "Disable",
              "useMultipleDirections": false,
              "directions": [
                {
                  "looping": false,
                  "timeBetweenFrames": 0.07999999821186066,
                  "sprites": [
                    {
                      "hasCustomCollisionMask": false,
                      "image": "assets\\DisableConstraintButton.png",
                      "points": [],
                      "originPoint": {
                        "name": "origine",
                        "x": 0,
                        "y": 0
                      },
                      "centerPoint": {
                        "automatic": true,
                        "name": "centre",
                        "x": 0,
                        "y": 0
                      },
                      "customCollisionMask": []
                    }
                  ]
                }
              ]
            },
            {
              "name": "Enable",
              "useMultipleDirections": false,
              "directions": [
                {
                  "looping": false,
                  "timeBetweenFrames": 0.07999999821186066,
                  "sprites": [
                    {
                      "hasCustomCollisionMask": false,
                      "image": "assets\\EnableConstraintButton.png",
                      "points": [],
                      "originPoint": {
                        "name": "origine",
                        "x": 0,
                        "y": 0
                      },
                      "centerPoint": {
                        "automatic": true,
                        "name": "centre",
                        "x": 0,
                        "y": 0
                      },
                      "customCollisionMask": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "adaptCollisionMaskAutomatically": false,
          "assetStoreId": "",
          "name": "RerollIslandButton",
          "type": "Sprite",
          "updateIfNotVisible": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "animations": [
            {
              "name": "NewObject",
              "useMultipleDirections": false,
              "directions": [
                {
                  "looping": false,
                  "timeBetweenFrames": 0.07999999821186066,
                  "sprites": [
                    {
                      "hasCustomCollisionMask": false,
                      "image": "assets\\RerollIslandButton.png",
                      "points": [],
                      "originPoint": {
                        "name": "origine",
                        "x": 0,
                        "y": 0
                      },
                      "centerPoint": {
                        "automatic": true,
                        "name": "centre",
                        "x": 0,
                        "y": 0
                      },
                      "customCollisionMask": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "adaptCollisionMaskAutomatically": false,
          "assetStoreId": "",
          "name": "RerollTerrainButton",
          "type": "Sprite",
          "updateIfNotVisible": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "animations": [
            {
              "name": "NewObject",
              "useMultipleDirections": false,
              "directions": [
                {
                  "looping": false,
                  "timeBetweenFrames": 0.07999999821186066,
                  "sprites": [
                    {
                      "hasCustomCollisionMask": false,
                      "image": "assets\\RerollTerrainButton.png",
                      "points": [],
                      "originPoint": {
                        "name": "origine",
                        "x": 0,
                        "y": 0
                      },
                      "centerPoint": {
                        "automatic": true,
                        "name": "centre",
                        "x": 0,
                        "y": 0
                      },
                      "customCollisionMask": []
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "ValueLabel",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "string": "",
          "font": "",
          "textAlignment": "",
          "characterSize": 20,
          "color": {
            "b": 255,
            "g": 255,
            "r": 255
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "",
            "font": "",
            "textAlignment": "",
            "characterSize": 20,
            "color": "255;255;255"
          }
        },
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "NormalLabel",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "string": "Click to evaluate the height and normal",
          "font": "",
          "textAlignment": "",
          "characterSize": 20,
          "color": {
            "b": 255,
            "g": 255,
            "r": 255
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "Click to evaluate the height and normal",
            "font": "",
            "textAlignment": "",
            "characterSize": 20,
            "color": "255;255;255"
          }
        },
        {
          "assetStoreId": "",
          "bold": false,
          "italic": false,
          "name": "Directions",
          "smoothed": true,
          "type": "TextObject::Text",
          "underlined": false,
          "variables": [],
          "effects": [],
          "behaviors": [],
          "string": "There is neither noise nor island shapes.\n      Press one of the first two buttons.",
          "font": "",
          "textAlignment": "",
          "characterSize": 20,
          "color": {
            "b": 0,
            "g": 0,
            "r": 0
          },
          "content": {
            "bold": false,
            "isOutlineEnabled": false,
            "isShadowEnabled": false,
            "italic": false,
            "outlineColor": "255;255;255",
            "outlineThickness": 2,
            "shadowAngle": 90,
            "shadowBlurRadius": 2,
            "shadowColor": "0;0;0",
            "shadowDistance": 4,
            "shadowOpacity": 127,
            "smoothed": true,
            "underlined": false,
            "text": "There is neither noise nor island shapes.\n      Press one of the first two buttons.",
            "font": "",
            "textAlignment": "",
            "characterSize": 20,
            "color": "0;0;0"
          }
        }
      ],
      "objectsFolderStructure": {
        "folderName": "__ROOT",
        "children": [
          {
            "objectName": "HeightField"
          },
          {
            "objectName": "ContourLine"
          },
          {
            "objectName": "TerrainRangeSizeField"
          },
          {
            "objectName": "TerrainLowerBoundField"
          },
          {
            "objectName": "ToogleNoiseButton"
          },
          {
            "objectName": "ToogleConstraintButton"
          },
          {
            "objectName": "RerollIslandButton"
          },
          {
            "objectName": "RerollTerrainButton"
          },
          {
            "objectName": "ValueLabel"
          },
          {
            "objectName": "NormalLabel"
          },
          {
            "objectName": "Directions"
          }
        ]
      },
      "events": [
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "This example uses a MarchingSquare behavior on each of these objects:\n- 1 HeightField contains the heights of the terrain for each point of a grid\n- 16 ContourLine contain the exact same thing as HeightField but is used to render the terraces with different colors\n- 1 TerrainRangeSizeField and 1 TerrainLowerBoundField are used to constraint the terrain generation to make an island\n\nThe behavior documentation has illustrations that help to understand this example.\nIt can be reached using the help button in the behavior tab from one of the objects.\n"
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "DepartScene"
              },
              "parameters": [
                ""
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "ModVarScene"
              },
              "parameters": [
                "Radius",
                "=",
                "32"
              ]
            },
            {
              "type": {
                "value": "ResetTimer"
              },
              "parameters": [
                "",
                "\"RefreshNormal\""
              ]
            },
            {
              "type": {
                "value": "Cache"
              },
              "parameters": [
                "Directions"
              ]
            }
          ],
          "events": [
            {
              "colorB": 228,
              "colorG": 176,
              "colorR": 74,
              "creationTime": 0,
              "name": "Initialize relief contours",
              "source": "",
              "type": "BuiltinCommonInstructions::Group",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Create 16 relief contours with a color gradient.\nThe number of contours can be changed with the ContourCount variable.\nThe gradient colors are defined in the \"Palette\" variable.\n\nA different Threshold is set on every ContourLine. This is what allows to draw the terraces."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "contourIndex",
                        "=",
                        "0"
                      ]
                    },
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "paletteIndex",
                        "=",
                        "1"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Repeat",
                  "repeatExpression": "Variable(ContourCount)",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "Create"
                      },
                      "parameters": [
                        "",
                        "ContourLine",
                        "0",
                        "0",
                        "\"\""
                      ]
                    },
                    {
                      "type": {
                        "value": "ChangePlan"
                      },
                      "parameters": [
                        "ContourLine",
                        "=",
                        "Variable(contourIndex)"
                      ]
                    },
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "paletteIndice",
                        "=",
                        "Variable(contourIndex) / Variable(ContourCount)"
                      ]
                    },
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "contourThreshold",
                        "=",
                        "ExtendedMath::Map(Variable(paletteIndice), 0, 1, -Variable(HeightMax),  Variable(HeightMax))"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetThreshold"
                      },
                      "parameters": [
                        "ContourLine",
                        "MarchingSquaresBehavior",
                        "Variable(contourThreshold)",
                        ""
                      ]
                    }
                  ],
                  "events": [
                    {
                      "type": "BuiltinCommonInstructions::Comment",
                      "color": {
                        "b": 109,
                        "g": 230,
                        "r": 255,
                        "textB": 0,
                        "textG": 0,
                        "textR": 0
                      },
                      "comment": "Switch to the next color gradient"
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [
                        {
                          "type": {
                            "value": "VarScene"
                          },
                          "parameters": [
                            "paletteIndice",
                            ">",
                            "Variable(Palette[Variable(paletteIndex)].Threshold)"
                          ]
                        }
                      ],
                      "actions": [
                        {
                          "type": {
                            "value": "ModVarScene"
                          },
                          "parameters": [
                            "paletteIndex",
                            "+",
                            "1"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "PrimitiveDrawing::FillColor"
                          },
                          "parameters": [
                            "ContourLine",
                            "ColorConversion::RgbMean(VariableString(Palette[Variable(paletteIndex) - 1].Color), VariableString(Palette[Variable(paletteIndex)].Color), ExtendedMath::Map(Variable(paletteIndice),  Variable(Palette[Variable(paletteIndex) - 1].Threshold), Variable(Palette[Variable(paletteIndex)].Threshold), 0, 1))"
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "ModVarScene"
                          },
                          "parameters": [
                            "contourIndex",
                            "+",
                            "1"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ],
              "parameters": []
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "The cell size changes the drawing precision.\nA value of 5 gives smooth curved contours where a value of 20 lets show lines."
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetCellWidth"
                  },
                  "parameters": [
                    "Field",
                    "MarchingSquaresBehavior",
                    "Variable(CellSize)",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::SetCellHeight"
                  },
                  "parameters": [
                    "Field",
                    "MarchingSquaresBehavior",
                    "Variable(CellSize)",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "IslandPositioning"
            },
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "GenerateTerrain"
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Reroll the map"
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "KeyReleased"
              },
              "parameters": [
                "",
                "Return"
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "Noise::SetSeed"
              },
              "parameters": [
                "",
                "RandomInRange(1, 65535)",
                ""
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "IslandPositioning"
            },
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "GenerateTerrain"
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "SetSceneVariableAsBoolean"
              },
              "parameters": [
                "useAnyButton",
                ""
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Reroll the island positions but keep the same noise"
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "BuiltinCommonInstructions::Or"
              },
              "parameters": [],
              "subInstructions": [
                {
                  "type": {
                    "value": "KeyReleased"
                  },
                  "parameters": [
                    "",
                    "i"
                  ]
                },
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::And"
                  },
                  "parameters": [],
                  "subInstructions": [
                    {
                      "type": {
                        "value": "MouseButtonReleased"
                      },
                      "parameters": [
                        "",
                        "Left"
                      ]
                    },
                    {
                      "type": {
                        "value": "SourisSurObjet"
                      },
                      "parameters": [
                        "RerollIslandButton",
                        "",
                        "",
                        ""
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "SetSceneVariableAsBoolean"
              },
              "parameters": [
                "useAnyButton",
                "True"
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "IslandPositioning"
            },
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "GenerateTerrain"
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Reroll the noise but keep the same island positions"
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "BuiltinCommonInstructions::Or"
              },
              "parameters": [],
              "subInstructions": [
                {
                  "type": {
                    "value": "KeyReleased"
                  },
                  "parameters": [
                    "",
                    "t"
                  ]
                },
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::And"
                  },
                  "parameters": [],
                  "subInstructions": [
                    {
                      "type": {
                        "value": "MouseButtonReleased"
                      },
                      "parameters": [
                        "",
                        "Left"
                      ]
                    },
                    {
                      "type": {
                        "value": "SourisSurObjet"
                      },
                      "parameters": [
                        "RerollTerrainButton",
                        "",
                        "",
                        ""
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "Noise::SetSeed"
              },
              "parameters": [
                "",
                "RandomInRange(1, 65535)",
                ""
              ]
            },
            {
              "type": {
                "value": "SetSceneVariableAsBoolean"
              },
              "parameters": [
                "useAnyButton",
                "True"
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "GenerateTerrain"
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Disable the noise to show the island positions."
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "BuiltinCommonInstructions::Or"
              },
              "parameters": [],
              "subInstructions": [
                {
                  "type": {
                    "value": "KeyReleased"
                  },
                  "parameters": [
                    "",
                    "h"
                  ]
                },
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::And"
                  },
                  "parameters": [],
                  "subInstructions": [
                    {
                      "type": {
                        "value": "MouseButtonReleased"
                      },
                      "parameters": [
                        "",
                        "Left"
                      ]
                    },
                    {
                      "type": {
                        "value": "SourisSurObjet"
                      },
                      "parameters": [
                        "ToogleNoiseButton",
                        "",
                        "",
                        ""
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "ToggleSceneVariableAsBoolean"
              },
              "parameters": [
                "IsNoiseEnable"
              ]
            },
            {
              "type": {
                "value": "SetSceneVariableAsBoolean"
              },
              "parameters": [
                "useAnyButton",
                "True"
              ]
            },
            {
              "type": {
                "value": "Cache"
              },
              "parameters": [
                "Directions"
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "GenerateTerrain"
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "IsNoiseEnable",
                    "True"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetAnimationName"
                  },
                  "parameters": [
                    "ToogleNoiseButton",
                    "\"Disable\""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "IsNoiseEnable",
                    "False"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetAnimationName"
                  },
                  "parameters": [
                    "ToogleNoiseButton",
                    "\"Enable\""
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SceneVariableAsBoolean"
                      },
                      "parameters": [
                        "IsIslandConstraintEnable",
                        "False"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Montre"
                      },
                      "parameters": [
                        "Directions",
                        ""
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Disable the island constraints to show the noise alone."
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "BuiltinCommonInstructions::Or"
              },
              "parameters": [],
              "subInstructions": [
                {
                  "type": {
                    "value": "KeyReleased"
                  },
                  "parameters": [
                    "",
                    "c"
                  ]
                },
                {
                  "type": {
                    "value": "BuiltinCommonInstructions::And"
                  },
                  "parameters": [],
                  "subInstructions": [
                    {
                      "type": {
                        "value": "MouseButtonReleased"
                      },
                      "parameters": [
                        "",
                        "Left"
                      ]
                    },
                    {
                      "type": {
                        "value": "SourisSurObjet"
                      },
                      "parameters": [
                        "ToogleConstraintButton",
                        "",
                        "",
                        ""
                      ]
                    }
                  ]
                }
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "ToggleSceneVariableAsBoolean"
              },
              "parameters": [
                "IsIslandConstraintEnable"
              ]
            },
            {
              "type": {
                "value": "SetSceneVariableAsBoolean"
              },
              "parameters": [
                "useAnyButton",
                "True"
              ]
            },
            {
              "type": {
                "value": "Cache"
              },
              "parameters": [
                "Directions"
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Link",
              "include": {
                "includeConfig": 0
              },
              "target": "GenerateTerrain"
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "IsIslandConstraintEnable",
                    "True"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetAnimationName"
                  },
                  "parameters": [
                    "ToogleConstraintButton",
                    "\"Disable\""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "IsIslandConstraintEnable",
                    "False"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetAnimationName"
                  },
                  "parameters": [
                    "ToogleConstraintButton",
                    "\"Enable\""
                  ]
                }
              ],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "SceneVariableAsBoolean"
                      },
                      "parameters": [
                        "IsNoiseEnable",
                        "False"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "Montre"
                      },
                      "parameters": [
                        "Directions",
                        ""
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Evaluate the height at the cursor location"
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "MouseButtonReleased"
              },
              "parameters": [
                "",
                "Left"
              ]
            },
            {
              "type": {
                "value": "SceneVariableAsBoolean"
              },
              "parameters": [
                "useAnyButton",
                "False"
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "TextObject::String"
              },
              "parameters": [
                "ValueLabel",
                "=",
                "\"Height: \" + ToString(HeightField.MarchingSquaresBehavior::FieldValue(MouseX(\"\", 0), MouseY(\"\", 0)))"
              ]
            },
            {
              "type": {
                "value": "TextObject::String"
              },
              "parameters": [
                "NormalLabel",
                "=",
                "\"Normal: \" + ToString(HeightField.MarchingSquaresBehavior::NormalX(MouseX(\"\", 0), MouseY(\"\", 0))) + \" ; \" + ToString(HeightField.MarchingSquaresBehavior::NormalY(MouseX(\"\", 0), MouseY(\"\", 0))) + \" ; \" + ToString(HeightField.MarchingSquaresBehavior::NormalZ(MouseX(\"\", 0), MouseY(\"\", 0)))"
              ]
            }
          ]
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [
            {
              "type": {
                "value": "KeyReleased"
              },
              "parameters": [
                "",
                "u"
              ]
            }
          ],
          "actions": [
            {
              "type": {
                "value": "ToggleSceneVariableAsBoolean"
              },
              "parameters": [
                "HideUI"
              ]
            }
          ],
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "HideUI",
                    "True"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "HideLayer"
                  },
                  "parameters": [
                    "",
                    "\"UI\""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "HideUI",
                    "False"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "ShowLayer"
                  },
                  "parameters": [
                    "",
                    "\"UI\""
                  ]
                }
              ]
            }
          ]
        }
      ],
      "layers": [
        {
          "ambientLightColorB": 32,
          "ambientLightColorG": 0,
          "ambientLightColorR": 0,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "",
          "renderingType": "",
          "visibility": true,
          "cameras": [
            {
              "defaultSize": true,
              "defaultViewport": true,
              "height": 0,
              "viewportBottom": 1,
              "viewportLeft": 0,
              "viewportRight": 1,
              "viewportTop": 0,
              "width": 0
            }
          ],
          "effects": []
        },
        {
          "ambientLightColorB": 12,
          "ambientLightColorG": 6023776,
          "ambientLightColorR": 7798800,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "Contours",
          "renderingType": "",
          "visibility": true,
          "cameras": [],
          "effects": []
        },
        {
          "ambientLightColorB": 12,
          "ambientLightColorG": 6026736,
          "ambientLightColorR": 8002696,
          "camera3DFarPlaneDistance": 10000,
          "camera3DFieldOfView": 45,
          "camera3DNearPlaneDistance": 0.1,
          "cameraType": "perspective",
          "followBaseLayerCamera": false,
          "isLightingLayer": false,
          "isLocked": false,
          "name": "UI",
          "renderingType": "",
          "visibility": true,
          "cameras": [],
          "effects": []
        }
      ],
      "behaviorsSharedData": [
        {
          "name": "MarchingSquaresBehavior",
          "type": "MarchingSquares::MarchingSquaresBehavior"
        }
      ]
    }
  ],
  "externalEvents": [
    {
      "associatedLayout": "IslandGenerator",
      "lastChangeTimeStamp": 0,
      "name": "IslandPositioning",
      "events": [
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Island positioning",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ClearField"
                  },
                  "parameters": [
                    "TerrainRangeSizeField",
                    "MarchingSquaresBehavior",
                    "0"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ClearField"
                  },
                  "parameters": [
                    "TerrainLowerBoundField",
                    "MarchingSquaresBehavior",
                    "0"
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Add 5 hills with random position and size.\nThe hills will dictate where the land and sea should be.\n\nA height of 4 and an opacity of 0.25 make an actual height of 1.\nSo, the values are from 0 to 1 and the maximum operation allow stay in this range.\n\nHere, the field name is not indicative to what it does yet.\nIt would take too much memory to create one field for each calculus step just to give it a good name.\nThe name should have been \"land probability field\"."
            },
            {
              "type": "BuiltinCommonInstructions::Repeat",
              "repeatExpression": "5",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::AddHill"
                  },
                  "parameters": [
                    "TerrainLowerBoundField",
                    "MarchingSquaresBehavior",
                    "RandomFloatInRange(200, 600)",
                    "RandomFloatInRange(200, 400)",
                    "4",
                    "RandomFloatInRange(75, 200)",
                    "0.25",
                    "32",
                    "\"Maximum\"",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "At the end of this event the fields deserve their names.\n\nTerrainLowerBoundField is the lowest value the terrain field will take.\nIt's from 0 to 0.5, the noise is generated between 0 and 1 and 0.5 is the sea level.\nSo, around the hill center, the terrain is very likely to be land.\n\nTerrainRangeSizeField is the amplitude that will be given to the noise.\nBefore the merge with a subtraction, the field was actually the \"terrain upper bound field\" (it's easier to understand it this way).\nIt was from 0.25 to 1, under 0.5 there can't be any land.\nSo, away from the hill center, the terrain will be under the sea.\n\nThe 2 offsets from the \"Transform\" actions can be changed to get a different kind of terrain.\nFor instance, using 0.5 or more instead of 0.25 will give a lot of reefs because the upper bound would be over the sea level."
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::MergeField"
                  },
                  "parameters": [
                    "TerrainRangeSizeField",
                    "MarchingSquaresBehavior",
                    "TerrainLowerBoundField",
                    "MarchingSquaresBehavior",
                    "\"Addition\"",
                    "100"
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::TransformField"
                  },
                  "parameters": [
                    "TerrainRangeSizeField",
                    "MarchingSquaresBehavior",
                    "1",
                    "0.25",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::TransformField"
                  },
                  "parameters": [
                    "TerrainLowerBoundField",
                    "MarchingSquaresBehavior",
                    "1",
                    "-0.5",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ClampField"
                  },
                  "parameters": [
                    "TerrainRangeSizeField",
                    "MarchingSquaresBehavior",
                    "0",
                    "1",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::ClampField"
                  },
                  "parameters": [
                    "TerrainLowerBoundField",
                    "MarchingSquaresBehavior",
                    "0",
                    "1",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::MergeField"
                  },
                  "parameters": [
                    "TerrainRangeSizeField",
                    "MarchingSquaresBehavior",
                    "TerrainLowerBoundField",
                    "MarchingSquaresBehavior",
                    "\"Subtraction\"",
                    "100"
                  ]
                }
              ]
            }
          ],
          "parameters": []
        }
      ]
    },
    {
      "associatedLayout": "IslandGenerator",
      "lastChangeTimeStamp": 0,
      "name": "GenerateTerrain",
      "events": [
        {
          "colorB": 228,
          "colorG": 176,
          "colorR": 74,
          "creationTime": 0,
          "name": "Terrain generation",
          "source": "",
          "type": "BuiltinCommonInstructions::Group",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "The noise generation uses 3 octaves. This can be seen as 3 layers of noise with different zoom.\nThe frequency double at each layer (lacunary = 2) and the amplitude is halved (persistence = 0.5).\nThe first octave gives the general shape of the terrain, but alone it looks very smooth.\nThe 2 other octaves add small perturbations to add finer details to the landscape."
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "Noise::SetFrequency"
                  },
                  "parameters": [
                    "",
                    "0.005 * HeightField.MarchingSquaresBehavior::CellWidth()",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Noise::SetOctaves"
                  },
                  "parameters": [
                    "",
                    "3",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Noise::SetLacunarity"
                  },
                  "parameters": [
                    "",
                    "2",
                    ""
                  ]
                },
                {
                  "type": {
                    "value": "Noise::SetPersistence"
                  },
                  "parameters": [
                    "",
                    "0.5",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "The whole field is set to the median value when the noise is disable to show the hill positions."
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "IsNoiseEnable",
                    ""
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::TransformField"
                  },
                  "parameters": [
                    "HeightField",
                    "MarchingSquaresBehavior",
                    "0",
                    "0.5",
                    ""
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Comment",
              "color": {
                "b": 109,
                "g": 230,
                "r": 255,
                "textB": 0,
                "textG": 0,
                "textR": 0
              },
              "comment": "Fill the field with noise between 0 and 1."
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "IsNoiseEnable",
                    "True"
                  ]
                }
              ],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "x",
                        "=",
                        "0"
                      ]
                    }
                  ]
                },
                {
                  "infiniteLoopWarning": true,
                  "type": "BuiltinCommonInstructions::While",
                  "whileConditions": [
                    {
                      "type": {
                        "value": "VarScene"
                      },
                      "parameters": [
                        "x",
                        "<",
                        "HeightField.MarchingSquaresBehavior::DimensionX()"
                      ]
                    }
                  ],
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "ModVarScene"
                      },
                      "parameters": [
                        "y",
                        "=",
                        "0"
                      ]
                    }
                  ],
                  "events": [
                    {
                      "infiniteLoopWarning": true,
                      "type": "BuiltinCommonInstructions::While",
                      "whileConditions": [
                        {
                          "type": {
                            "value": "VarScene"
                          },
                          "parameters": [
                            "y",
                            "<",
                            "HeightField.MarchingSquaresBehavior::DimensionY()"
                          ]
                        }
                      ],
                      "conditions": [],
                      "actions": [],
                      "events": [
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "MarchingSquares::MarchingSquaresBehavior::SetGridValue"
                              },
                              "parameters": [
                                "HeightField",
                                "MarchingSquaresBehavior",
                                "Variable(x)",
                                "Variable(y)",
                                "ExtendedMath::Map(Noise::Simplex2(Variable(x), Variable(y)), -1, 1, 0, 1)",
                                ""
                              ]
                            }
                          ]
                        },
                        {
                          "type": "BuiltinCommonInstructions::Standard",
                          "conditions": [],
                          "actions": [
                            {
                              "type": {
                                "value": "ModVarScene"
                              },
                              "parameters": [
                                "y",
                                "+",
                                "1"
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    {
                      "type": "BuiltinCommonInstructions::Standard",
                      "conditions": [],
                      "actions": [
                        {
                          "type": {
                            "value": "ModVarScene"
                          },
                          "parameters": [
                            "x",
                            "+",
                            "1"
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "SceneVariableAsBoolean"
                  },
                  "parameters": [
                    "IsIslandConstraintEnable",
                    "True"
                  ]
                }
              ],
              "actions": [],
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Comment",
                  "color": {
                    "b": 109,
                    "g": 230,
                    "r": 255,
                    "textB": 0,
                    "textG": 0,
                    "textR": 0
                  },
                  "comment": "Stretch the noise between lower and upper bounds.\n\nTerrainLowerBoundField and TerrainRangeSizeField are built in \"IslandPositioning\" external events.\nAs the bounds are defined by fields, each point of the field has their own lower and upper bounds."
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::MergeField"
                      },
                      "parameters": [
                        "HeightField",
                        "MarchingSquaresBehavior",
                        "TerrainRangeSizeField",
                        "MarchingSquaresBehavior",
                        "\"Multiplication\"",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::MergeField"
                      },
                      "parameters": [
                        "HeightField",
                        "MarchingSquaresBehavior",
                        "TerrainLowerBoundField",
                        "MarchingSquaresBehavior",
                        "\"Addition\"",
                        ""
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "MarchingSquares::MarchingSquaresBehavior::TransformField"
                  },
                  "parameters": [
                    "HeightField",
                    "MarchingSquaresBehavior",
                    "2 * Variable(HeightMax)",
                    "-Variable(HeightMax)",
                    ""
                  ]
                }
              ]
            }
          ],
          "parameters": []
        },
        {
          "type": "BuiltinCommonInstructions::Comment",
          "color": {
            "b": 109,
            "g": 230,
            "r": 255,
            "textB": 0,
            "textG": 0,
            "textR": 0
          },
          "comment": "Update the contour lines"
        },
        {
          "type": "BuiltinCommonInstructions::Standard",
          "conditions": [],
          "actions": [
            {
              "type": {
                "value": "MarchingSquares::MarchingSquaresBehavior::ClearField"
              },
              "parameters": [
                "ContourLine",
                "MarchingSquaresBehavior",
                ""
              ]
            },
            {
              "type": {
                "value": "MarchingSquares::MarchingSquaresBehavior::MergeField"
              },
              "parameters": [
                "ContourLine",
                "MarchingSquaresBehavior",
                "HeightField",
                "MarchingSquaresBehavior",
                "\"Addition\"",
                ""
              ]
            },
            {
              "type": {
                "value": "PrimitiveDrawing::Drawer::ClearShapes"
              },
              "parameters": [
                "ContourLine"
              ]
            },
            {
              "type": {
                "value": "MarchingSquares::MarchingSquaresBehavior::DrawField"
              },
              "parameters": [
                "ContourLine",
                "MarchingSquaresBehavior",
                "1"
              ]
            }
          ]
        }
      ]
    }
  ],
  "eventsFunctionsExtensions": [
    {
      "author": "add_, @Jurfix",
      "category": "Advanced",
      "extensionNamespace": "",
      "fullName": "Extended math support",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWZ1bmN0aW9uLXZhcmlhbnQiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIuNDIsNS4yOUMxMS4zMiw1LjE5IDEwLjM1LDYgMTAuMjUsNy4xMUwxMCwxMEgxMi44MlYxMkg5LjgyTDkuMzgsMTcuMDdDOS4xOCwxOS4yNyA3LjI0LDIwLjkgNS4wNCwyMC43QzMuNzksMjAuNTkgMi42NiwxOS45IDIsMTguODNMMy41LDE3LjMzQzMuODMsMTguMzggNC45NiwxOC45NyA2LDE4LjYzQzYuNzgsMTguMzkgNy4zMywxNy43IDcuNCwxNi44OUw3LjgyLDEySDQuODJWMTBIOEw4LjI3LDYuOTNDOC40Niw0LjczIDEwLjM5LDMuMSAxMi42LDMuMjhDMTMuODYsMy4zOSAxNSw0LjA5IDE1LjY2LDUuMTdMMTQuMTYsNi42N0MxMy45MSw1LjkgMTMuMjMsNS4zNiAxMi40Miw1LjI5TTIyLDEzLjY1TDIwLjU5LDEyLjI0TDE3Ljc2LDE1LjA3TDE0LjkzLDEyLjI0TDEzLjUsMTMuNjVMMTYuMzUsMTYuNUwxMy41LDE5LjMxTDE0LjkzLDIwLjcyTDE3Ljc2LDE3Ljg5TDIwLjU5LDIwLjcyTDIyLDE5LjMxTDE5LjE3LDE2LjVMMjIsMTMuNjVaIiAvPjwvc3ZnPg==",
      "name": "ExtendedMath",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/function-variant.svg",
      "shortDescription": "Additional math functions and constants as expressions and conditions.",
      "version": "1.1.0",
      "description": [
        "Expressions:",
        " - Mathematical constants",
        " - Greatest common factor/Lowest common multiple",
        " - Factorial",
        " - Coordinates conversion for polar and isometric systems",
        " - ToFixedString: Formats a number into a string with the specified number of decimal places",
        " - ToFixed: (Deprecated) Formats a number to use the specified number of decimal places",
        "",
        "Conditions:",
        "- IsEven: Check if the number is even (divisible by 2)",
        "",
        "Release Notes:",
        "",
        "Version 1.0.7",
        "- Added ToFixedString()",
        "- Deprecated ToFixed() because it does not show any trailing zeros for whole numbers. Prefer using ToFixedString() to set values in text objects.",
        ""
      ],
      "origin": {
        "identifier": "ExtendedMath",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "math",
        "constants",
        "conversion",
        "coordinates",
        "convert",
        "format",
        "modulus"
      ],
      "authorIds": [
        "AlZ3D1xkH0QDao7T37VZZUeYNpn1",
        "dt0tRnf2kHWJnjkrpnzTzNj9Yc63"
      ],
      "dependencies": [],
      "eventsFunctions": [
        {
          "description": "Returns a term from the Fibonacci sequence.",
          "fullName": "Fibonacci numbers",
          "functionType": "Expression",
          "name": "Fibonacci",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "function fibonacci(n) {",
                "    let initial = 0;",
                "    let final = 1;",
                "    let sum = 0;",
                "",
                "    let i = 0;",
                "    for(i = 2; i <= n; i++) {",
                "        sum = initial + final;",
                "",
                "        initial = final;",
                "        final = sum;",
                "    }",
                "    return n ? final : initial;",
                "}",
                "",
                "const n = eventsFunctionContext.getArgument(\"n\");",
                "",
                "eventsFunctionContext.returnValue = fibonacci(n);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "The desired term in the sequence",
              "name": "n",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Calculates the steepness of a line between two points.",
          "fullName": "Slope",
          "functionType": "Expression",
          "name": "Slope",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const x1 = eventsFunctionContext.getArgument(\"x1\");\r",
                "const y1 = eventsFunctionContext.getArgument(\"y1\");\r",
                "const x2 = eventsFunctionContext.getArgument(\"x2\");\r",
                "const y2 = eventsFunctionContext.getArgument(\"y2\");\r",
                "\r",
                "eventsFunctionContext.returnValue = (y2 - y1) / (x2 - x1);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "X value of the first point",
              "name": "x1",
              "type": "expression"
            },
            {
              "description": "Y value of the first point",
              "name": "y1",
              "type": "expression"
            },
            {
              "description": "X value of the second point",
              "name": "x2",
              "type": "expression"
            },
            {
              "description": "Y value of the second point",
              "name": "y2",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a number of one range e.g. 0-1 to another 0-255.",
          "fullName": "Map",
          "functionType": "Expression",
          "name": "Map",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const n = eventsFunctionContext.getArgument(\"n\");",
                "const min1 = eventsFunctionContext.getArgument(\"min1\");",
                "const max1 = eventsFunctionContext.getArgument(\"max1\");",
                "const min2 = eventsFunctionContext.getArgument(\"min2\");",
                "const max2 = eventsFunctionContext.getArgument(\"max2\");",
                "",
                "eventsFunctionContext.returnValue = (n - min1) * (max2 - min2) / (max1 - min1) + min2;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "The value to convert",
              "name": "n",
              "type": "expression"
            },
            {
              "description": "The lowest value of the first range",
              "name": "min1",
              "type": "expression"
            },
            {
              "description": "The highest value of the first range",
              "name": "max1",
              "type": "expression"
            },
            {
              "description": "The lowest value of the second range",
              "name": "min2",
              "type": "expression"
            },
            {
              "description": "The highest value of the second range",
              "name": "max2",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Returns the value of the length of the hypotenuse.",
          "fullName": "Hypotenuse length",
          "functionType": "Expression",
          "name": "Hypot",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const a = eventsFunctionContext.getArgument(\"a\");\r",
                "const b = eventsFunctionContext.getArgument(\"b\");\r",
                "\r",
                "eventsFunctionContext.returnValue = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "First side of the triangle",
              "name": "a",
              "type": "expression"
            },
            {
              "description": "Second side of the triangle",
              "name": "b",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Returns the greatest common factor of two numbers.",
          "fullName": "Greatest common factor (gcf)",
          "functionType": "Expression",
          "name": "Gcf",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "//uses Euclid's algorithm",
                "function gcf(a, b) {",
                "    while (a != b) {",
                "        if (a > b) {",
                "            a = a - b;",
                "        } else {",
                "            b = b - a;",
                "        }",
                "    }",
                "    return a;",
                "}",
                "",
                "const a = eventsFunctionContext.getArgument(\"a\");",
                "const b = eventsFunctionContext.getArgument(\"b\");",
                "",
                "if (Number.isInteger(a) === false || Number.isInteger(b) === false) {",
                "    eventsFunctionContext.returnValue = 0;",
                "} ",
                "else if (a === 0) {",
                "    eventsFunctionContext.returnValue = b;",
                "} ",
                "else if (b === 0) {",
                "    eventsFunctionContext.returnValue = a;",
                "} else {",
                "    eventsFunctionContext.returnValue = gcf(a, b);",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Any integer",
              "name": "a",
              "type": "expression"
            },
            {
              "description": "Any integer",
              "name": "b",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Returns the lowest common multiple of two numbers.",
          "fullName": "Lowest common multiple (lcm)",
          "functionType": "Expression",
          "name": "Lcm",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "function gcf(a, b) {\r",
                "    while (a != b) {\r",
                "        if (a > b) {\r",
                "            a = a - b;\r",
                "        } else {\r",
                "            b = b - a;\r",
                "        }\r",
                "    }\r",
                "    return a;\r",
                "}\r",
                "\r",
                "function lcm(a, b) {\r",
                "    return Math.abs(a * b) / gcf(a, b);\r",
                "}\r",
                "\r",
                "const a = eventsFunctionContext.getArgument(\"a\");\r",
                "const b = eventsFunctionContext.getArgument(\"b\");\r",
                "\r",
                "if (Number.isInteger(a) === false || Number.isInteger(b) === false) {\r",
                "    eventsFunctionContext.returnValue = 0;\r",
                "} \r",
                "else if (a === 0) {\r",
                "    eventsFunctionContext.returnValue = b;\r",
                "} \r",
                "else if (b === 0) {\r",
                "    eventsFunctionContext.returnValue = a;\r",
                "} else {\r",
                "    eventsFunctionContext.returnValue = lcm(a, b);\r",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Any integer",
              "name": "a",
              "type": "expression"
            },
            {
              "description": "Any integer",
              "name": "b",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Returns the input multiplied by all the previous whole numbers.",
          "fullName": "Factorial",
          "functionType": "Expression",
          "name": "Factorial",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "function factorial(n) {\r",
                "    let result = 1;\r",
                "\r",
                "    let i = 1;\r",
                "    for (i = 1; i <= n; i++) {\r",
                "        result *= i;\r",
                "    }\r",
                "\r",
                "    return result;\r",
                "}\r",
                "\r",
                "const n = eventsFunctionContext.getArgument(\"n\");\r",
                "\r",
                "eventsFunctionContext.returnValue = factorial(n);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Any positive integer",
              "name": "n",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a polar coordinate into the Cartesian x value.",
          "fullName": "Polar coordinate to Cartesian X value",
          "functionType": "Expression",
          "name": "PolarToCartesianX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const r = eventsFunctionContext.getArgument(\"r\");",
                "const theta = eventsFunctionContext.getArgument(\"theta\");",
                "",
                "eventsFunctionContext.returnValue = r * Math.cos(theta);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Radius",
              "name": "r",
              "type": "expression"
            },
            {
              "description": "Angle or theta in radians",
              "name": "theta",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a polar coordinate into the Cartesian y value.",
          "fullName": "Polar coordinate to Cartesian Y value",
          "functionType": "Expression",
          "name": "PolarToCartesianY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const r = eventsFunctionContext.getArgument(\"r\");",
                "const theta = eventsFunctionContext.getArgument(\"theta\");",
                "",
                "eventsFunctionContext.returnValue = r * Math.sin(theta);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Radius ",
              "name": "r",
              "type": "expression"
            },
            {
              "description": "Angle or theta in radians",
              "name": "theta",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a isometric coordinate into the Cartesian x value.",
          "fullName": "Isometric coordinate to Cartesian X value",
          "functionType": "Expression",
          "name": "IsoToCartesianX",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const x = eventsFunctionContext.getArgument(\"x\");",
                "const y = eventsFunctionContext.getArgument(\"y\");",
                "",
                "eventsFunctionContext.returnValue = (2 * y + x) * 0.5;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Position on the x axis",
              "name": "x",
              "type": "expression"
            },
            {
              "description": "Position on the y axis",
              "name": "y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a isometric coordinate into the Cartesian y value.",
          "fullName": "Isometric coordinate to Cartesian Y value",
          "functionType": "Expression",
          "name": "IisoToCartesianY",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const x = eventsFunctionContext.getArgument(\"x\");",
                "const y = eventsFunctionContext.getArgument(\"y\");",
                "",
                "eventsFunctionContext.returnValue = (2 * y - x) * 0.5;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Position on the x axis",
              "name": "x",
              "type": "expression"
            },
            {
              "description": "Position on the y axis",
              "name": "y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Returns the golden ratio.",
          "fullName": "Golden ratio",
          "functionType": "Expression",
          "name": "GoldenRatio",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "1.618033988749894"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns Pi (π).",
          "fullName": "Pi (π)",
          "functionType": "Expression",
          "name": "Pi",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.PI;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            },
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": []
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns half Pi.",
          "fullName": "Half Pi",
          "functionType": "Expression",
          "name": "HalfPi",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.PI / 2;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns the natural logarithm of e. (Euler's number).",
          "fullName": "Natural logarithm of e",
          "functionType": "Expression",
          "name": "E",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.E;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns the natural logarithm of 2.",
          "fullName": "Natural logarithm of 2",
          "functionType": "Expression",
          "name": "Ln2",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.LN2;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns the natural logarithm of 10.",
          "fullName": "Natural logarithm of 10",
          "functionType": "Expression",
          "name": "Ln10",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.LN10;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns the base 2 logarithm of e. (Euler's number).",
          "fullName": "Base 2 logarithm of e",
          "functionType": "Expression",
          "name": "Log2e",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.LOG10E;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns the base 10 logarithm of e. (Euler's number).",
          "fullName": "Base 10 logarithm of e",
          "functionType": "Expression",
          "name": "Log10e",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.LOG10E;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns square root of 2.",
          "fullName": "Square root of 2",
          "functionType": "Expression",
          "name": "Sqrt2",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.SQRT2;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns square root of 1/2.",
          "fullName": "Square root of 1/2",
          "functionType": "Expression",
          "name": "Sqrt1_2",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.SQRT1_2;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Returns quarter Pi.",
          "fullName": "Quarter Pi",
          "functionType": "Expression",
          "name": "QuarterPi",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = Math.PI / 4;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Formats a number to use the specified number of decimal places (Deprecated).",
          "fullName": "ToFixed",
          "functionType": "Expression",
          "name": "ToFixed",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": []
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const valueToBeRounded = eventsFunctionContext.getArgument(\"ValueToBeRounded\");",
                "const numberOfDecimalPlaces = eventsFunctionContext.getArgument(\"NumberOfDecimalPlaces\");",
                "eventsFunctionContext.returnValue = Number(valueToBeRounded.toFixed(numberOfDecimalPlaces));"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "The value to be rounded",
              "name": "ValueToBeRounded",
              "type": "expression"
            },
            {
              "description": "Number of decimal places",
              "name": "NumberOfDecimalPlaces",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Formats a number to a string with the specified number of decimal places.",
          "fullName": "ToFixed",
          "functionType": "StringExpression",
          "name": "ToFixedString",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": []
            },
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const valueToBeRounded = eventsFunctionContext.getArgument(\"ValueToBeRounded\");",
                "const numberOfDecimalPlaces = eventsFunctionContext.getArgument(\"NumberOfDecimalPlaces\");",
                "eventsFunctionContext.returnValue = valueToBeRounded.toFixed(numberOfDecimalPlaces);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "The value to be rounded",
              "name": "ValueToBeRounded",
              "type": "expression"
            },
            {
              "description": "Number of decimal places",
              "name": "NumberOfDecimalPlaces",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Check if the number is even (divisible by 2).  To check for odd numbers, invert this condition.",
          "fullName": "Is even?",
          "functionType": "Condition",
          "name": "IsEven",
          "sentence": "_PARAM1_ is even",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [
                {
                  "type": {
                    "value": "Egal"
                  },
                  "parameters": [
                    "mod(GetArgumentAsNumber(\"Value\"),2)",
                    "=",
                    "0"
                  ]
                }
              ],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnBoolean"
                  },
                  "parameters": [
                    "True"
                  ]
                }
              ]
            }
          ],
          "parameters": [
            {
              "description": "Value",
              "name": "Value",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": []
    },
    {
      "author": "Add00",
      "category": "Game mechanic",
      "extensionNamespace": "",
      "fullName": "Noise generator",
      "helpPath": "/tutorials/procedural-generation",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXNwcmlua2xlciIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0xMSA3SDEzVjlIMTFWN001IDIySDlWMTBINVYyMk0xNCAxMUgxNlY5SDE0VjExTTE3IDEwSDE5VjhIMTdWMTBNMTcgNVY3SDE5VjVIMTdNMTQgOEgxNlY2SDE0VjhNMTcgMTNIMTlWMTFIMTdWMTNNNSA3SDUuMzNMNiA5SDhMOC42NyA3SDlWNkg1VjdaIiAvPjwvc3ZnPg==",
      "name": "Noise",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/sprinkler.svg",
      "shortDescription": "Generate noise values for procedural generation.",
      "version": "2.1.3",
      "description": [
        "Noise can be useful for many procedural generation cases such as:",
        "- Terrain, top down or side view ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-island-generator))",
        "- Object positioning (tree, stars...)",
        "- Curves (roads, rivers...)",
        "- Textures (fog, milky way...)",
        "- Screen shake",
        "- Many other things",
        "",
        "This extension contains expressions to generate Simplex noise values in 1, 2, 3 and 4 dimensions. A *\"seed\"* allows to generate the same world again later on instead of having to save the whole generated world.",
        "",
        "Version 2.0.0 compatibility break:",
        "- Seeds doesn't give the same result as with version 1.x.x"
      ],
      "origin": {
        "identifier": "Noise",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "perlin noise",
        "simplex noise",
        "procedural generation"
      ],
      "authorIds": [
        "AlZ3D1xkH0QDao7T37VZZUeYNpn1",
        "gqDaZjCfevOOxBYkK6zlhtZnXCg1",
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "eventsFunctions": [
        {
          "fullName": "",
          "functionType": "Action",
          "name": "onFirstSceneLoaded",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "if (gdjs._extensionNoise) {",
                "    return;",
                "}",
                "",
                "/** Noise generator manager. */",
                "class NoiseManager {",
                "    /**",
                "     * Create the manager of noise generators.",
                "     */",
                "    constructor() {",
                "        this.seed = gdjs.randomInRange(1, Number.MAX_SAFE_INTEGER);",
                "        /** @type {Map<string, NoiseGenerator>} */",
                "        this.generators = new Map();",
                "    }",
                "",
                "    /**",
                "     * @param name {string}",
                "     * @return {NoiseGenerator}",
                "     */",
                "    getGenerator(name) {",
                "        let generator = this.generators.get(name);",
                "        if (!generator) {",
                "            generator = new NoiseGenerator(name + this.seed);",
                "            this.generators.set(name, generator);",
                "        }",
                "        return generator;",
                "    }",
                "",
                "    /**",
                "     * @param seed {number}",
                "     */",
                "    setSeed(seed) {",
                "        this.seed = seed;",
                "        this.generators.forEach(generator => generator.setSeed(name + this.seed));",
                "    }",
                "",
                "    /**",
                "     * @param name {string}",
                "     */",
                "    deleteGenerator(name) {",
                "        this.generators.delete(name);",
                "    }",
                "",
                "    /**",
                "     */",
                "    deleteAllGenerators() {",
                "        this.generators.clear();",
                "    }",
                "}",
                "",
                "/** Noise generator with octaves. */",
                "class NoiseGenerator {",
                "    /**",
                "     * Create a noise generator with a seed.",
                "     * @param seed {string}",
                "     */",
                "    constructor(seed) {",
                "        this.simplexNoise = new SimplexNoise(seed);",
                "        this.frequency = 1;",
                "        this.octaves = 1;",
                "        this.persistence = 0.5;",
                "        this.lacunarity = 2;",
                "        this.xLoopPeriod = 0;",
                "        this.yLoopPeriod = 0;",
                "    }",
                "",
                "    /**",
                "     * @param seed {string}",
                "     */",
                "    setSeed(seed) {",
                "        this.simplexNoise = new SimplexNoise(seed);",
                "    }",
                "",
                "    /**",
                "     * @param x {float}",
                "     * @param y {float}",
                "     * @param z {float} optionnal",
                "     * @param w {float} optionnal",
                "     * @return {float}",
                "     */",
                "    noise(x, y, z, w) {",
                "        if (this.xLoopPeriod && this.yLoopPeriod) {",
                "            const circleRatioX = 2 * Math.PI / this.xLoopPeriod;",
                "            const circleRatioY = 2 * Math.PI / this.yLoopPeriod;",
                "            const angleX = circleRatioX * x;",
                "            const angleY = circleRatioY * y;",
                "            x = Math.cos(angleX) / circleRatioX;",
                "            y = Math.sin(angleX) / circleRatioX;",
                "            z = Math.cos(angleY) / circleRatioY;",
                "            w = Math.sin(angleY) / circleRatioY;",
                "        }",
                "        else if (this.xLoopPeriod) {",
                "            const circleRatio = 2 * Math.PI / this.xLoopPeriod;",
                "            const angleX = circleRatio * x;",
                "            w = z;",
                "            z = y;",
                "            x = Math.cos(angleX) / circleRatio;",
                "            y = Math.sin(angleX) / circleRatio;",
                "        }",
                "        else if (this.yLoopPeriod) {",
                "            const circleRatio = 2 * Math.PI / this.xLoopPeriod;",
                "            const angleX = circleRatio * x;",
                "            w = z;",
                "            // Make the circle perimeter equals to the looping period",
                "            // to keep the same perceived frequency with or without looping.",
                "            y = Math.cos(angleX) / circleRatio;",
                "            z = Math.sin(angleX) / circleRatio;",
                "        }",
                "        let noiseFunction = this.simplexNoise.noise4D.bind(this.simplexNoise);",
                "        if (z === undefined) {",
                "            noiseFunction = this.simplexNoise.noise2D.bind(this.simplexNoise);",
                "        }",
                "        else if (w === undefined) {",
                "            noiseFunction = this.simplexNoise.noise3D.bind(this.simplexNoise);",
                "        }",
                "        let frequency = this.frequency;",
                "        let noiseSum = 0;",
                "        let amplitudeSum = 0;",
                "        let amplitude = 1;",
                "        for (let i = 0; i < this.octaves; i++) {",
                "            noiseSum += noiseFunction(x * frequency, y * frequency, z * frequency, w * frequency) * amplitude;",
                "            amplitudeSum += Math.abs(amplitude);",
                "            amplitude *= this.persistence;",
                "            frequency *= this.lacunarity;",
                "        }",
                "        return noiseSum / amplitudeSum;",
                "    }",
                "}",
                "",
                "/*",
                "A fast javascript implementation of simplex noise by Jonas Wagner",
                "https://github.com/jwagner/simplex-noise.js",
                "",
                "Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.",
                "Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).",
                "With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).",
                "Better rank ordering method by Stefan Gustavson in 2012.",
                "",
                " Copyright (c) 2021 Jonas Wagner",
                "",
                " Permission is hereby granted, free of charge, to any person obtaining a copy",
                " of this software and associated documentation files (the \"Software\"), to deal",
                " in the Software without restriction, including without limitation the rights",
                " to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                " copies of the Software, and to permit persons to whom the Software is",
                " furnished to do so, subject to the following conditions:",
                "",
                " The above copyright notice and this permission notice shall be included in all",
                " copies or substantial portions of the Software.",
                "",
                " THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                " IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                " FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                " AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                " LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                " OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
                " SOFTWARE.",
                " */",
                "",
                "const F2 = 0.5 * (Math.sqrt(3.0) - 1.0);",
                "const G2 = (3.0 - Math.sqrt(3.0)) / 6.0;",
                "const F3 = 1.0 / 3.0;",
                "const G3 = 1.0 / 6.0;",
                "const F4 = (Math.sqrt(5.0) - 1.0) / 4.0;",
                "const G4 = (5.0 - Math.sqrt(5.0)) / 20.0;",
                "const grad3 = new Float32Array([1, 1, 0,",
                "    -1, 1, 0,",
                "    1, -1, 0,",
                "    -1, -1, 0,",
                "    1, 0, 1,",
                "    -1, 0, 1,",
                "    1, 0, -1,",
                "    -1, 0, -1,",
                "    0, 1, 1,",
                "    0, -1, 1,",
                "    0, 1, -1,",
                "    0, -1, -1]);",
                "const grad4 = new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,",
                "    0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,",
                "    1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,",
                "    -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,",
                "    1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,",
                "    -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,",
                "    1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,",
                "    -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]);",
                "",
                "",
                "/**",
                " * Builds a random permutation table.",
                " * This is exported only for (internal) testing purposes.",
                " * Do not rely on this export.",
                " * @param {() => number} random",
                " * @private",
                " */",
                "function buildPermutationTable(random) {",
                "    const p = new Uint8Array(256);",
                "    for (let i = 0; i < 256; i++) {",
                "        p[i] = i;",
                "    }",
                "    for (let i = 0; i < 255; i++) {",
                "        const r = i + ~~(random() * (256 - i));",
                "        const aux = p[i];",
                "        p[i] = p[r];",
                "        p[r] = aux;",
                "    }",
                "    return p;",
                "}",
                "",
                "/*",
                "The ALEA PRNG and masher code used by simplex-noise.js",
                "is based on code by Johannes Baagøe, modified by Jonas Wagner.",
                "See alea.md for the full license.",
                "@param {string|number} seed",
                "*/",
                "function alea(seed) {",
                "    let s0 = 0;",
                "    let s1 = 0;",
                "    let s2 = 0;",
                "    let c = 1;",
                "    const mash = masher();",
                "    s0 = mash(' ');",
                "    s1 = mash(' ');",
                "    s2 = mash(' ');",
                "    s0 -= mash(seed);",
                "    if (s0 < 0) {",
                "        s0 += 1;",
                "    }",
                "    s1 -= mash(seed);",
                "    if (s1 < 0) {",
                "        s1 += 1;",
                "    }",
                "    s2 -= mash(seed);",
                "    if (s2 < 0) {",
                "        s2 += 1;",
                "    }",
                "    return function () {",
                "        const t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32",
                "        s0 = s1;",
                "        s1 = s2;",
                "        return s2 = t - (c = t | 0);",
                "    };",
                "}",
                "",
                "function masher() {",
                "    let n = 0xefc8249d;",
                "    return function (data) {",
                "        data = data.toString();",
                "        for (let i = 0; i < data.length; i++) {",
                "            n += data.charCodeAt(i);",
                "            let h = 0.02519603282416938 * n;",
                "            n = h >>> 0;",
                "            h -= n;",
                "            h *= n;",
                "            n = h >>> 0;",
                "            h -= n;",
                "            n += h * 0x100000000; // 2^32",
                "        }",
                "        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32",
                "    };",
                "}",
                "",
                "/** Deterministic simplex noise generator suitable for 2D, 3D and 4D spaces. */",
                "class SimplexNoise {",
                "    /**",
                "     * Creates a new `SimplexNoise` instance.",
                "     * This involves some setup. You can save a few cpu cycles by reusing the same instance.",
                "     * @param {(() => number)|string|number} randomOrSeed A random number generator or a seed (string|number).",
                "     * Defaults to Math.random (random irreproducible initialization).",
                "     */",
                "    constructor(randomOrSeed) {",
                "        if (randomOrSeed === void 0) { randomOrSeed = Math.random; }",
                "        const random = typeof randomOrSeed == 'function' ? randomOrSeed : alea(randomOrSeed);",
                "        this.p = buildPermutationTable(random);",
                "        this.perm = new Uint8Array(512);",
                "        this.permMod12 = new Uint8Array(512);",
                "        for (let i = 0; i < 512; i++) {",
                "            this.perm[i] = this.p[i & 255];",
                "            this.permMod12[i] = this.perm[i] % 12;",
                "        }",
                "    }",
                "",
                "    /**",
                "     * Samples the noise field in 2 dimensions",
                "     * @param {number} x",
                "     * @param {number} y",
                "     * @returns a number in the interval [-1, 1]",
                "     */",
                "    noise2D(x, y) {",
                "        const permMod12 = this.permMod12;",
                "        const perm = this.perm;",
                "        let n0 = 0; // Noise contributions from the three corners",
                "        let n1 = 0;",
                "        let n2 = 0;",
                "        // Skew the input space to determine which simplex cell we're in",
                "        const s = (x + y) * F2; // Hairy factor for 2D",
                "        const i = Math.floor(x + s);",
                "        const j = Math.floor(y + s);",
                "        const t = (i + j) * G2;",
                "        const X0 = i - t; // Unskew the cell origin back to (x,y) space",
                "        const Y0 = j - t;",
                "        const x0 = x - X0; // The x,y distances from the cell origin",
                "        const y0 = y - Y0;",
                "        // For the 2D case, the simplex shape is an equilateral triangle.",
                "        // Determine which simplex we are in.",
                "        let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords",
                "        if (x0 > y0) {",
                "            i1 = 1;",
                "            j1 = 0;",
                "        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)",
                "        else {",
                "            i1 = 0;",
                "            j1 = 1;",
                "        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)",
                "        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and",
                "        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where",
                "        // c = (3-sqrt(3))/6",
                "        const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords",
                "        const y1 = y0 - j1 + G2;",
                "        const x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords",
                "        const y2 = y0 - 1.0 + 2.0 * G2;",
                "        // Work out the hashed gradient indices of the three simplex corners",
                "        const ii = i & 255;",
                "        const jj = j & 255;",
                "        // Calculate the contribution from the three corners",
                "        let t0 = 0.5 - x0 * x0 - y0 * y0;",
                "        if (t0 >= 0) {",
                "            const gi0 = permMod12[ii + perm[jj]] * 3;",
                "            t0 *= t0;",
                "            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient",
                "        }",
                "        let t1 = 0.5 - x1 * x1 - y1 * y1;",
                "        if (t1 >= 0) {",
                "            const gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;",
                "            t1 *= t1;",
                "            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);",
                "        }",
                "        let t2 = 0.5 - x2 * x2 - y2 * y2;",
                "        if (t2 >= 0) {",
                "            const gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;",
                "            t2 *= t2;",
                "            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);",
                "        }",
                "        // Add contributions from each corner to get the final noise value.",
                "        // The result is scaled to return values in the interval [-1,1].",
                "        return 70.0 * (n0 + n1 + n2);",
                "    }",
                "",
                "    /**",
                "     * Samples the noise field in 3 dimensions",
                "     * @param {number} x",
                "     * @param {number} y",
                "     * @param {number} z",
                "     * @returns a number in the interval [-1, 1]",
                "     */",
                "    noise3D(x, y, z) {",
                "        const permMod12 = this.permMod12;",
                "        const perm = this.perm;",
                "        let n0, n1, n2, n3; // Noise contributions from the four corners",
                "        // Skew the input space to determine which simplex cell we're in",
                "        const s = (x + y + z) * F3; // Very nice and simple skew factor for 3D",
                "        const i = Math.floor(x + s);",
                "        const j = Math.floor(y + s);",
                "        const k = Math.floor(z + s);",
                "        const t = (i + j + k) * G3;",
                "        const X0 = i - t; // Unskew the cell origin back to (x,y,z) space",
                "        const Y0 = j - t;",
                "        const Z0 = k - t;",
                "        const x0 = x - X0; // The x,y,z distances from the cell origin",
                "        const y0 = y - Y0;",
                "        const z0 = z - Z0;",
                "        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.",
                "        // Determine which simplex we are in.",
                "        let i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords",
                "        let i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords",
                "        if (x0 >= y0) {",
                "            if (y0 >= z0) {",
                "                i1 = 1;",
                "                j1 = 0;",
                "                k1 = 0;",
                "                i2 = 1;",
                "                j2 = 1;",
                "                k2 = 0;",
                "            } // X Y Z order",
                "            else if (x0 >= z0) {",
                "                i1 = 1;",
                "                j1 = 0;",
                "                k1 = 0;",
                "                i2 = 1;",
                "                j2 = 0;",
                "                k2 = 1;",
                "            } // X Z Y order",
                "            else {",
                "                i1 = 0;",
                "                j1 = 0;",
                "                k1 = 1;",
                "                i2 = 1;",
                "                j2 = 0;",
                "                k2 = 1;",
                "            } // Z X Y order",
                "        }",
                "        else { // x0<y0",
                "            if (y0 < z0) {",
                "                i1 = 0;",
                "                j1 = 0;",
                "                k1 = 1;",
                "                i2 = 0;",
                "                j2 = 1;",
                "                k2 = 1;",
                "            } // Z Y X order",
                "            else if (x0 < z0) {",
                "                i1 = 0;",
                "                j1 = 1;",
                "                k1 = 0;",
                "                i2 = 0;",
                "                j2 = 1;",
                "                k2 = 1;",
                "            } // Y Z X order",
                "            else {",
                "                i1 = 0;",
                "                j1 = 1;",
                "                k1 = 0;",
                "                i2 = 1;",
                "                j2 = 1;",
                "                k2 = 0;",
                "            } // Y X Z order",
                "        }",
                "        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),",
                "        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and",
                "        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where",
                "        // c = 1/6.",
                "        const x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords",
                "        const y1 = y0 - j1 + G3;",
                "        const z1 = z0 - k1 + G3;",
                "        const x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords",
                "        const y2 = y0 - j2 + 2.0 * G3;",
                "        const z2 = z0 - k2 + 2.0 * G3;",
                "        const x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords",
                "        const y3 = y0 - 1.0 + 3.0 * G3;",
                "        const z3 = z0 - 1.0 + 3.0 * G3;",
                "        // Work out the hashed gradient indices of the four simplex corners",
                "        const ii = i & 255;",
                "        const jj = j & 255;",
                "        const kk = k & 255;",
                "        // Calculate the contribution from the four corners",
                "        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;",
                "        if (t0 < 0)",
                "            n0 = 0.0;",
                "        else {",
                "            const gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;",
                "            t0 *= t0;",
                "            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);",
                "        }",
                "        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;",
                "        if (t1 < 0)",
                "            n1 = 0.0;",
                "        else {",
                "            const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;",
                "            t1 *= t1;",
                "            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);",
                "        }",
                "        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;",
                "        if (t2 < 0)",
                "            n2 = 0.0;",
                "        else {",
                "            const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;",
                "            t2 *= t2;",
                "            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);",
                "        }",
                "        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;",
                "        if (t3 < 0)",
                "            n3 = 0.0;",
                "        else {",
                "            const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;",
                "            t3 *= t3;",
                "            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);",
                "        }",
                "        // Add contributions from each corner to get the final noise value.",
                "        // The result is scaled to stay just inside [-1,1]",
                "        return 32.0 * (n0 + n1 + n2 + n3);",
                "    }",
                "",
                "    /**",
                "     * Samples the noise field in 4 dimensions",
                "     * @param {number} x",
                "     * @param {number} y",
                "     * @param {number} z",
                "     * @returns a number in the interval [-1, 1]",
                "     */",
                "    noise4D(x, y, z, w) {",
                "        const perm = this.perm;",
                "        let n0, n1, n2, n3, n4; // Noise contributions from the five corners",
                "        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in",
                "        const s = (x + y + z + w) * F4; // Factor for 4D skewing",
                "        const i = Math.floor(x + s);",
                "        const j = Math.floor(y + s);",
                "        const k = Math.floor(z + s);",
                "        const l = Math.floor(w + s);",
                "        const t = (i + j + k + l) * G4; // Factor for 4D unskewing",
                "        const X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space",
                "        const Y0 = j - t;",
                "        const Z0 = k - t;",
                "        const W0 = l - t;",
                "        const x0 = x - X0; // The x,y,z,w distances from the cell origin",
                "        const y0 = y - Y0;",
                "        const z0 = z - Z0;",
                "        const w0 = w - W0;",
                "        // For the 4D case, the simplex is a 4D shape I won't even try to describe.",
                "        // To find out which of the 24 possible simplices we're in, we need to",
                "        // determine the magnitude ordering of x0, y0, z0 and w0.",
                "        // Six pair-wise comparisons are performed between each possible pair",
                "        // of the four coordinates, and the results are used to rank the numbers.",
                "        let rankx = 0;",
                "        let ranky = 0;",
                "        let rankz = 0;",
                "        let rankw = 0;",
                "        if (x0 > y0)",
                "            rankx++;",
                "        else",
                "            ranky++;",
                "        if (x0 > z0)",
                "            rankx++;",
                "        else",
                "            rankz++;",
                "        if (x0 > w0)",
                "            rankx++;",
                "        else",
                "            rankw++;",
                "        if (y0 > z0)",
                "            ranky++;",
                "        else",
                "            rankz++;",
                "        if (y0 > w0)",
                "            ranky++;",
                "        else",
                "            rankw++;",
                "        if (z0 > w0)",
                "            rankz++;",
                "        else",
                "            rankw++;",
                "        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.",
                "        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w",
                "        // impossible. Only the 24 indices which have non-zero entries make any sense.",
                "        // We use a thresholding to set the coordinates in turn from the largest magnitude.",
                "        // Rank 3 denotes the largest coordinate.",
                "        // Rank 2 denotes the second largest coordinate.",
                "        // Rank 1 denotes the second smallest coordinate.",
                "        // The integer offsets for the second simplex corner",
                "        const i1 = rankx >= 3 ? 1 : 0;",
                "        const j1 = ranky >= 3 ? 1 : 0;",
                "        const k1 = rankz >= 3 ? 1 : 0;",
                "        const l1 = rankw >= 3 ? 1 : 0;",
                "        // The integer offsets for the third simplex corner",
                "        const i2 = rankx >= 2 ? 1 : 0;",
                "        const j2 = ranky >= 2 ? 1 : 0;",
                "        const k2 = rankz >= 2 ? 1 : 0;",
                "        const l2 = rankw >= 2 ? 1 : 0;",
                "        // The integer offsets for the fourth simplex corner",
                "        const i3 = rankx >= 1 ? 1 : 0;",
                "        const j3 = ranky >= 1 ? 1 : 0;",
                "        const k3 = rankz >= 1 ? 1 : 0;",
                "        const l3 = rankw >= 1 ? 1 : 0;",
                "        // The fifth corner has all coordinate offsets = 1, so no need to compute that.",
                "        const x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords",
                "        const y1 = y0 - j1 + G4;",
                "        const z1 = z0 - k1 + G4;",
                "        const w1 = w0 - l1 + G4;",
                "        const x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords",
                "        const y2 = y0 - j2 + 2.0 * G4;",
                "        const z2 = z0 - k2 + 2.0 * G4;",
                "        const w2 = w0 - l2 + 2.0 * G4;",
                "        const x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords",
                "        const y3 = y0 - j3 + 3.0 * G4;",
                "        const z3 = z0 - k3 + 3.0 * G4;",
                "        const w3 = w0 - l3 + 3.0 * G4;",
                "        const x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords",
                "        const y4 = y0 - 1.0 + 4.0 * G4;",
                "        const z4 = z0 - 1.0 + 4.0 * G4;",
                "        const w4 = w0 - 1.0 + 4.0 * G4;",
                "        // Work out the hashed gradient indices of the five simplex corners",
                "        const ii = i & 255;",
                "        const jj = j & 255;",
                "        const kk = k & 255;",
                "        const ll = l & 255;",
                "        // Calculate the contribution from the five corners",
                "        let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;",
                "        if (t0 < 0)",
                "            n0 = 0.0;",
                "        else {",
                "            const gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;",
                "            t0 *= t0;",
                "            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);",
                "        }",
                "        let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;",
                "        if (t1 < 0)",
                "            n1 = 0.0;",
                "        else {",
                "            const gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;",
                "            t1 *= t1;",
                "            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);",
                "        }",
                "        let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;",
                "        if (t2 < 0)",
                "            n2 = 0.0;",
                "        else {",
                "            const gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;",
                "            t2 *= t2;",
                "            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);",
                "        }",
                "        let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;",
                "        if (t3 < 0)",
                "            n3 = 0.0;",
                "        else {",
                "            const gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;",
                "            t3 *= t3;",
                "            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);",
                "        }",
                "        let t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;",
                "        if (t4 < 0)",
                "            n4 = 0.0;",
                "        else {",
                "            const gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;",
                "            t4 *= t4;",
                "            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);",
                "        }",
                "        // Sum up and scale the result to cover the range [-1,1]",
                "        return 27.0 * (n0 + n1 + n2 + n3 + n4);",
                "    };",
                "}",
                "",
                "gdjs._extensionNoise = {",
                "    noiseManager: new NoiseManager(),",
                "};",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 1 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "1D noise",
          "functionType": "Expression",
          "name": "Noise1d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = 0;\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 2 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "2D noise",
          "functionType": "Expression",
          "name": "Noise2d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = eventsFunctionContext.getArgument(\"Y\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "Y coordinate",
              "name": "Y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 3 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "3D noise",
          "functionType": "Expression",
          "name": "Noise3d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = eventsFunctionContext.getArgument(\"Y\");\r",
                "const z = eventsFunctionContext.getArgument(\"Z\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y, z);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "Y coordinate",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "Z coordinate",
              "name": "Z",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Generate a number between -1 and 1 from 4 dimensional simplex noise. The \"Map\" expression from Extended Math extension can be used to map values to any chosen bounds.",
          "fullName": "4D noise",
          "functionType": "Expression",
          "name": "Noise4d",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "const x = eventsFunctionContext.getArgument(\"X\");\r",
                "const y = eventsFunctionContext.getArgument(\"Y\");\r",
                "const z = eventsFunctionContext.getArgument(\"Z\");\r",
                "const w = eventsFunctionContext.getArgument(\"W\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).noise(x, y, z, w);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            },
            {
              "description": "X coordinate",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "Y coordinate",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "Z coordinate",
              "name": "Z",
              "type": "expression"
            },
            {
              "description": "W coordinate",
              "name": "W",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Create a noise generator with default settings (frequency = 1,  octaves = 1, persistence = 0.5, lacunarity = 2).",
          "fullName": "Create a noise generator",
          "functionType": "Action",
          "name": "Create",
          "sentence": "Create a noise generator named _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Delete a noise generators and loose its settings.",
          "fullName": "Delete a noise generator",
          "functionType": "Action",
          "name": "Delete",
          "sentence": "Delete _PARAM1_ noise generator",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.deleteGenerator(name);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Delete all noise generators and loose their settings.",
          "fullName": "Delete all noise generators",
          "functionType": "Action",
          "name": "DeleteAll",
          "sentence": "Delete all noise generators",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "gdjs._extensionNoise.noiseManager.deleteAllGenerators();",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "The seed is a number used to generate the random noise. Setting the same seed will result in the same random noise generation. It's for example useful to generate the same world, by saving this seed value and reusing it later to generate again a world.",
          "fullName": "Noise seed",
          "functionType": "Action",
          "name": "SetSeed",
          "sentence": "Change the noise seed to _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "gdjs._extensionNoise.noiseManager.setSeed(eventsFunctionContext.getArgument(\"Seed\"));",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Seed",
              "longDescription": "15 digits numbers maximum",
              "name": "Seed",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the looping period on X used for noise generation. The noise will wrap-around on X.",
          "fullName": "Noise looping period on X",
          "functionType": "Action",
          "name": "SetLoopPeriodX",
          "sentence": "Change the looping period on X of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).xLoopPeriod = eventsFunctionContext.getArgument(\"LoopPeriod\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Looping period on X",
              "name": "LoopPeriod",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the looping period on Y used for noise generation. The noise will wrap-around on Y.",
          "fullName": "Noise looping period on Y",
          "functionType": "Action",
          "name": "SetLoopPeriodY",
          "sentence": "Change the looping period on Y of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).yLoopPeriod = eventsFunctionContext.getArgument(\"LoopPeriod\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [
            {
              "description": "Looping period on Y",
              "name": "LoopPeriod",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the base frequency used for noise generation. A lower frequency will zoom in the noise.",
          "fullName": "Noise base frequency",
          "functionType": "Action",
          "name": "SetFrequency",
          "sentence": "Change the noise frequency of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).frequency = eventsFunctionContext.getArgument(\"Frequency\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Frequency",
              "name": "Frequency",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the number of octaves used for noise generation. It can be seen as layers of noise with different zoom.",
          "fullName": "Noise octaves",
          "functionType": "Action",
          "name": "SetOctaves",
          "sentence": "Change the number of noise octaves of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).octaves = eventsFunctionContext.getArgument(\"Octaves\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Octaves",
              "name": "Octaves",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the persistence used for noise generation. At its default value \"0.5\", it halves the noise amplitude at each octave.",
          "fullName": "Noise persistence",
          "functionType": "Action",
          "name": "SetPersistence",
          "sentence": "Change the noise persistence of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).persistence = eventsFunctionContext.getArgument(\"Persistence\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Persistence",
              "name": "Persistence",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Change the lacunarity used for noise generation. At its default value \"2\", it doubles the frequency at each octave.",
          "fullName": "Noise lacunarity",
          "functionType": "Action",
          "name": "SetLacunarity",
          "sentence": "Change the noise lacunarity of _PARAM2_: _PARAM1_",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "gdjs._extensionNoise.noiseManager.getGenerator(name).lacunarity = eventsFunctionContext.getArgument(\"Lacunarity\");"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "parameters": [
            {
              "description": "Lacunarity",
              "name": "Lacunarity",
              "type": "expression"
            },
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The seed used for noise generation.",
          "fullName": "Noise seed",
          "functionType": "Expression",
          "name": "Seed",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.seed;",
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "The base frequency used for noise generation.",
          "fullName": "Noise base frequency",
          "functionType": "Expression",
          "name": "Frequency",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).frequency;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The number of octaves used for noise generation.",
          "fullName": "Noise octaves number",
          "functionType": "Expression",
          "name": "Octaves",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).octaves;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The persistence used for noise generation.",
          "fullName": "Noise persistence",
          "functionType": "Expression",
          "name": "Persistence",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).persistence;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "The lacunarity used for noise generation.",
          "fullName": "Noise lacunarity",
          "functionType": "Expression",
          "name": "Lacunarity",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const name = eventsFunctionContext.getArgument(\"Name\");\r",
                "\r",
                "eventsFunctionContext.returnValue = gdjs._extensionNoise.noiseManager.getGenerator(name).lacunarity;"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Generator name",
              "name": "Name",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "2 dimensional Perlin noise (depecated, use Noise2d instead).",
          "fullName": "Perlin 2D noise",
          "functionType": "Expression",
          "name": "Perlin2",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise2d(\"\", GetArgumentAsNumber(\"X\"), GetArgumentAsNumber(\"Y\"))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "3 dimensional Perlin noise (depecated, use Noise3d instead).",
          "fullName": "Perlin 3D noise",
          "functionType": "Expression",
          "name": "Perlin3",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise3d(\"\", GetArgumentAsNumber(\"X\"), GetArgumentAsNumber(\"Y\"), GetArgumentAsNumber(\"Z\"))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "z value",
              "name": "Z",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "2 dimensional simplex noise (depecated, use Noise2d instead).",
          "fullName": "Simplex 2D noise",
          "functionType": "Expression",
          "name": "Simplex2",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise2d(\"\", GetArgumentAsNumber(\"X\"), GetArgumentAsNumber(\"Y\"))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "3 dimensional simplex noise (depecated, use Noise3d instead).",
          "fullName": "Simplex 3D noise",
          "functionType": "Expression",
          "name": "Simplex3",
          "private": true,
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::Standard",
              "conditions": [],
              "actions": [
                {
                  "type": {
                    "value": "SetReturnNumber"
                  },
                  "parameters": [
                    "Noise::Noise3d(\"\", GetArgumentAsNumber(\"X\"), GetArgumentAsNumber(\"Y\"), GetArgumentAsNumber(\"Z\"))"
                  ]
                }
              ]
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "x value",
              "name": "X",
              "type": "expression"
            },
            {
              "description": "y value",
              "name": "Y",
              "type": "expression"
            },
            {
              "description": "z value",
              "name": "Z",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": []
    },
    {
      "author": "Add00, AlanPH, Tristan (Victris Games)",
      "category": "Advanced",
      "extensionNamespace": "",
      "fullName": "Color Conversion",
      "helpPath": "",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWludmVydC1jb2xvcnMiIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBkPSJNMTIsMTkuNThWMTkuNThDMTAuNCwxOS41OCA4Ljg5LDE4Ljk2IDcuNzYsMTcuODNDNi42MiwxNi42OSA2LDE1LjE5IDYsMTMuNThDNiwxMiA2LjYyLDEwLjQ3IDcuNzYsOS4zNEwxMiw1LjFNMTcuNjYsNy45M0wxMiwyLjI3VjIuMjdMNi4zNCw3LjkzQzMuMjIsMTEuMDUgMy4yMiwxNi4xMiA2LjM0LDE5LjI0QzcuOSwyMC44IDkuOTUsMjEuNTggMTIsMjEuNThDMTQuMDUsMjEuNTggMTYuMSwyMC44IDE3LjY2LDE5LjI0QzIwLjc4LDE2LjEyIDIwLjc4LDExLjA1IDE3LjY2LDcuOTNaIiAvPjwvc3ZnPg==",
      "name": "ColorConversion",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/invert-colors.svg",
      "shortDescription": "Expressions to convert color values between various formats (RGB, HSV, HSL, named colors), calculate luminance according to WCAG 2.0 standards, and to blend two colors.",
      "version": "1.3.1",
      "description": "Expressions to convert color values between various formats (RGB, HSV, HSL, named colors), calculate luminance according to WCAG 2.0 standards, and to blend two colors.",
      "origin": {
        "identifier": "ColorConversion",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "color",
        "conversion",
        "hexadecimal",
        "rgb",
        "hsl",
        "hsv",
        "hsb",
        "luminance",
        "wcag",
        "blend"
      ],
      "authorIds": [
        "gqDaZjCfevOOxBYkK6zlhtZnXCg1",
        "AlZ3D1xkH0QDao7T37VZZUeYNpn1",
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2",
        "onPsboRtDkUHNOsx7OPr8R8G1oj2"
      ],
      "dependencies": [],
      "eventsFunctions": [
        {
          "description": "Converts a hexadecimal string into a RGB string.  Example input: \"0459AF\".",
          "fullName": "Hexadecimal to RGB",
          "functionType": "StringExpression",
          "name": "HexToRgb",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "try {",
                "    let n = eventsFunctionContext.getArgument(\"n\");",
                "",
                "    //input validation",
                "    let v = parseInt(n, 16);",
                "    if (v.toString(16) === n.toUpperCase()) throw 'input is not hexadecimal'; ",
                "",
                "    let shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;",
                "    n = n.replace(shorthandRegex, function (m, r, g, b) {",
                "        return r + r + g + g + b + b;",
                "    });",
                "    let result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(n);",
                "",
                "    let r = parseInt(result[1], 16),",
                "        g = parseInt(result[2], 16),",
                "        b = parseInt(result[3], 16);",
                "",
                "    eventsFunctionContext.returnValue = r + ';' + g + ';' + b;",
                "} catch(e) {",
                "    console.error(\"Unable to convert a color: \", e);",
                "    eventsFunctionContext.returnValue = \"0;0;0\";",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Hex value",
              "name": "n",
              "type": "color"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Calculate luminance of a RGB color.  Example input: \"0;128;255\".",
          "fullName": "Luminance from RGB",
          "functionType": "Expression",
          "name": "RgbToLuminance",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "function toLuminance(color) {",
                "    // Convert the color string to an array of RGB values",
                "    let [r, g, b] = color.split(\";\");",
                "    let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;",
                "    return luminance;",
                "}",
                "",
                "const color = eventsFunctionContext.getArgument(\"color\");",
                "eventsFunctionContext.returnValue = toLuminance(color);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": false
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "RGB color",
              "name": "color",
              "type": "color"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Calculate luminance of a hexadecimal color.  Example input: \"0459AF\".",
          "fullName": "Luminance from hexadecimal",
          "functionType": "Expression",
          "name": "HexToLuminance",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "function hexToLuminance(color) {",
                "    // Convert the color string to an array of RGB values",
                "    let [r, g, b] = color.slice(1).match(/.{2}/g).map(x => parseInt(x, 16));",
                "    let luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;",
                "    return luminance;",
                "}",
                "",
                "const color = eventsFunctionContext.getArgument(\"color\");",
                "eventsFunctionContext.returnValue = hexToLuminance(color);"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "expression"
          },
          "parameters": [
            {
              "description": "Hex value",
              "name": "color",
              "type": "string"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Blend two RGB colors by applying a weighted mean.",
          "fullName": "Blend RGB colors",
          "functionType": "StringExpression",
          "name": "RgbMean",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "try {",
                "    // split do allocations, but the code a lot simpler this way.",
                "    const components1 = eventsFunctionContext.getArgument(\"Color1\").split(\";\");",
                "    const r1 = gdjs.evtTools.common.clamp(parseFloat(components1[0]), 0, 255);",
                "    const g1 = gdjs.evtTools.common.clamp(parseFloat(components1[1]), 0, 255);",
                "    const b1 = gdjs.evtTools.common.clamp(parseFloat(components1[2]), 0, 255);",
                "",
                "    const components2 = eventsFunctionContext.getArgument(\"Color2\").split(\";\");",
                "    const r2 = gdjs.evtTools.common.clamp(parseFloat(components2[0]), 0, 255);",
                "    const g2 = gdjs.evtTools.common.clamp(parseFloat(components2[1]), 0, 255);",
                "    const b2 = gdjs.evtTools.common.clamp(parseFloat(components2[2]), 0, 255);",
                "",
                "    const ratio = eventsFunctionContext.getArgument(\"Ratio\");",
                "    const r = gdjs.evtTools.common.clamp(Math.round((1 - ratio) * r1 + ratio * r2), 0, 255);",
                "    const g = gdjs.evtTools.common.clamp(Math.round((1 - ratio) * g1 + ratio * g2), 0, 255);",
                "    const b = gdjs.evtTools.common.clamp(Math.round((1 - ratio) * b1 + ratio * b2), 0, 255);",
                "",
                "    eventsFunctionContext.returnValue = r + \";\" + g + \";\" + b;",
                "} catch (e) {",
                "    console.error(\"Unable to convert a color: \", e);",
                "    eventsFunctionContext.returnValue = \"0;0;0\";",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "First RGB color",
              "name": "Color1",
              "type": "color"
            },
            {
              "description": "Second RGB color",
              "name": "Color2",
              "type": "color"
            },
            {
              "description": "Ratio",
              "longDescription": "Range: 0 to 1, where 0 gives the first color and 1 gives the second color",
              "name": "Ratio",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a RGB string into a hexadecimal string.  Example input: \"0;128;255\".",
          "fullName": "RGB to hexadecimal",
          "functionType": "StringExpression",
          "name": "RgbToHex",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "try {",
                "    const n = eventsFunctionContext.getArgument(\"n\");",
                "    const col = n.split(\";\");",
                "    ",
                "    let r = parseFloat(col[0]),",
                "        g = parseFloat(col[1]),",
                "        b = parseFloat(col[2]);",
                "",
                "    r = gdjs.evtTools.common.clamp(r, 0, 255);",
                "    g = gdjs.evtTools.common.clamp(g, 0, 255);",
                "    b = gdjs.evtTools.common.clamp(b, 0, 255);",
                "",
                "    eventsFunctionContext.returnValue = \"#\" + gdjs.rgbToHex(r, g, b).toUpperCase();",
                "} catch (e) {",
                "    console.error(\"Unable to convert a color: \", e);",
                "    eventsFunctionContext.returnValue = \"#000000\";",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "RGB value",
              "name": "n",
              "type": "color"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a RGB string into a HSL string.  Example input: \"0;128;255\"\".",
          "fullName": "RGB to HSL",
          "functionType": "StringExpression",
          "name": "RgbToHsl",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "const n = eventsFunctionContext.getArgument(\"n\");",
                "const col = n.split(\";\");",
                "",
                "let r = parseFloat(col[0]),",
                "    g = parseFloat(col[1]),",
                "    b = parseFloat(col[2]);",
                "",
                "    r = gdjs.evtTools.common.clamp(r, 0, 255);",
                "    g = gdjs.evtTools.common.clamp(g, 0, 255);",
                "    b = gdjs.evtTools.common.clamp(b, 0, 255);",
                "",
                "r /= 255;",
                "g /= 255;",
                "b /= 255;",
                "",
                "let v = Math.max(r, g, b), c = v - Math.min(r, g, b), f = (1 - Math.abs(v + v - c - 1));",
                "let h = c && ((v === r) ? (g - b) / c: ((v === g) ? 2 + (b - r) / c: 4 + (r - g) / c)); ",
                "",
                "eventsFunctionContext.returnValue = Math.round(60 * (h < 0 ? h + 6: h)) + ';' + Math.round((f ? c / f: 0) * 100) + ';' + Math.round(((v + v - c) / 2) * 100);",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "RGB value",
              "name": "n",
              "type": "color"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts HSV color values into a RGB string.  Valid input ranges:  H(0 to 360), S(0 to 100), V(0 to 100).",
          "fullName": "HSV to RGB",
          "functionType": "StringExpression",
          "name": "HsvToRgb",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "try {",
                "",
                "    let h = parseFloat(eventsFunctionContext.getArgument(\"h\")),",
                "        s = parseFloat(eventsFunctionContext.getArgument(\"s\")),",
                "        v = parseFloat(eventsFunctionContext.getArgument(\"v\"));",
                "    ",
                "    s = gdjs.evtTools.common.clamp(s, 0, 100);",
                "    v = gdjs.evtTools.common.clamp(v, 0, 100);",
                "",
                "    h %= 360;",
                "    if (h < 0) {",
                "        h += 360;",
                "    }",
                "",
                "    s /= 100;",
                "    v /= 100;",
                "",
                "    let f = (n , k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);",
                "",
                "    eventsFunctionContext.returnValue = Math.round(f(5) * 255) + ';' + Math.round(f(3) * 255) + ';' + Math.round(f(1) * 255);",
                "} catch(e) {",
                "    console.error(\"Unable to convert a color: \", e);",
                "    eventsFunctionContext.returnValue = \"0;0;0\";",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Hue 0-360",
              "name": "h",
              "type": "expression"
            },
            {
              "description": "Saturation 0-100",
              "name": "s",
              "type": "expression"
            },
            {
              "description": "Value 0-100",
              "name": "v",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a RGB string into a HSV string.  Example input: \"0;128;255\".",
          "fullName": "RGB to HSV",
          "functionType": "StringExpression",
          "name": "RgbToHsv",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "try {",
                "    const n = eventsFunctionContext.getArgument(\"n\");",
                "    const col = n.split(\";\");",
                "",
                "    let r = parseFloat(col[0]),",
                "        g = parseFloat(col[1]),",
                "        b = parseFloat(col[2]);",
                "",
                "    r = gdjs.evtTools.common.clamp(r, 0, 255);",
                "    g = gdjs.evtTools.common.clamp(g, 0, 255);",
                "    b = gdjs.evtTools.common.clamp(b, 0, 255);",
                "",
                "    r /= 255;",
                "    g /= 255;",
                "    b /= 255;",
                "",
                "    let v = Math.max(r, g, b), ",
                "        c = v - Math.min(r, g, b);",
                "",
                "    let h = c && ((v == r) ? (g - b) / c: ((v == g) ? 2 + (b - r) / c: 4 + (r - g) / c)); ",
                "",
                "    eventsFunctionContext.returnValue = Math.round(60 * (h < 0 ? h + 6: h)) + ';' + Math.round((v && c / v) * 100) + ';' + Math.round(v * 100);",
                "} catch (e) {",
                "    console.error(\"Unable to convert a color: \", e);",
                "    eventsFunctionContext.returnValue = \"0;0;0\";",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "RGB value",
              "name": "n",
              "type": "color"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a color name into a RGB string.  (Examples: black, gray, white, red, purple, green, yellow, blue)  \nFull list of colors: https://www.w3schools.com/colors/colors_names.asp.",
          "fullName": "Color name to RGB",
          "functionType": "StringExpression",
          "name": "NameToRgb",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "let n = eventsFunctionContext.getArgument(\"n\");",
                "",
                "n = n.toLowerCase();",
                "",
                "switch (n) {",
                "    case 'black':",
                "        eventsFunctionContext.returnValue = '0;0;0';",
                "        break;",
                "    case 'silver':",
                "        eventsFunctionContext.returnValue = '192;192;192';",
                "        break;",
                "    case 'gray':",
                "        eventsFunctionContext.returnValue = '128;128;128';",
                "        break;",
                "    case 'white':",
                "        eventsFunctionContext.returnValue = '255;255;255';",
                "        break;",
                "    case 'maroon':",
                "        eventsFunctionContext.returnValue = '128;0;0';",
                "        break;",
                "    case 'red':",
                "        eventsFunctionContext.returnValue = '255;0;0';",
                "        break;",
                "    case 'purple':",
                "        eventsFunctionContext.returnValue = '128;0;128';",
                "        break;",
                "    case 'fuchsia':",
                "        eventsFunctionContext.returnValue = '255;0;255';",
                "        break;",
                "    case 'green':",
                "        eventsFunctionContext.returnValue = '0;128;0';",
                "        break;",
                "    case 'lime':",
                "        eventsFunctionContext.returnValue = '0;255;0';",
                "        break;",
                "    case 'olive':",
                "        eventsFunctionContext.returnValue = '128;128;0';",
                "        break;",
                "    case 'yellow':",
                "        eventsFunctionContext.returnValue = '255;255;0';",
                "        break;",
                "    case 'navy':",
                "        eventsFunctionContext.returnValue = '0;0;128';",
                "        break;",
                "    case 'blue':",
                "        eventsFunctionContext.returnValue = '0;0;255';",
                "        break;",
                "    case 'teal':",
                "        eventsFunctionContext.returnValue = '0;128;128';",
                "        break;",
                "    case 'aqua':",
                "        eventsFunctionContext.returnValue = '0;255;255';",
                "        break;",
                "    case 'orange':",
                "        eventsFunctionContext.returnValue = '255;165;0';",
                "        break;",
                "    case 'aliceblue':",
                "        eventsFunctionContext.returnValue = '240;248;255';",
                "        break;",
                "    case 'antiquewhite':",
                "        eventsFunctionContext.returnValue = '250;235;215';",
                "        break;",
                "    case 'aquamarine':",
                "        eventsFunctionContext.returnValue = '127;255;212';",
                "        break;",
                "    case 'azure':",
                "        eventsFunctionContext.returnValue = '240;255;255';",
                "        break;",
                "    case 'beige':",
                "        eventsFunctionContext.returnValue = '245;245;220';",
                "        break;",
                "    case 'bisque':",
                "        eventsFunctionContext.returnValue = '255;228;196';",
                "        break;",
                "    case 'blanchedalmond':",
                "        eventsFunctionContext.returnValue = '255;235;205';",
                "        break;",
                "    case 'blueviolet':",
                "        eventsFunctionContext.returnValue = '128;43;226';",
                "        break;",
                "    case 'brown':",
                "        eventsFunctionContext.returnValue = '165;42;42';",
                "        break;",
                "    case 'burlywood':",
                "        eventsFunctionContext.returnValue = '222;184;135';",
                "        break;",
                "    case 'cadetblue':",
                "        eventsFunctionContext.returnValue = '95;158;160';",
                "        break;",
                "    case 'chartreuse':",
                "        eventsFunctionContext.returnValue = '127;255;0';",
                "        break;",
                "    case 'chocolate':",
                "        eventsFunctionContext.returnValue = '210;105;30';",
                "        break;",
                "    case 'coral':",
                "        eventsFunctionContext.returnValue = '255;127;80';",
                "        break;",
                "    case 'cornflowerblue':",
                "        eventsFunctionContext.returnValue = '100;149;237';",
                "        break;",
                "    case 'cornsilk':",
                "        eventsFunctionContext.returnValue = '255;248;220';",
                "        break;",
                "    case 'crimson':",
                "        eventsFunctionContext.returnValue = '220;20;60';",
                "        break;",
                "    case 'cyan':",
                "        eventsFunctionContext.returnValue = '220;20;60';",
                "        break;",
                "    case 'darkblue':",
                "        eventsFunctionContext.returnValue = '0;0;139';",
                "        break;",
                "    case 'darkcyan':",
                "        eventsFunctionContext.returnValue = '0;139;139';",
                "        break;",
                "    case 'darkgoldenrod':",
                "        eventsFunctionContext.returnValue = '184;134;11';",
                "        break;",
                "    case 'darkgray':",
                "    case 'darkgrey':",
                "        eventsFunctionContext.returnValue = '169;169;169';",
                "        break;",
                "    case 'darkgreen':",
                "        eventsFunctionContext.returnValue = '0;100;0';",
                "        break;",
                "    case 'darkkhaki':",
                "        eventsFunctionContext.returnValue = '189;183;107';",
                "        break;",
                "    case 'darkmagenta':",
                "        eventsFunctionContext.returnValue = '139;0;139';",
                "        break;",
                "    case 'darkolivegreen':",
                "        eventsFunctionContext.returnValue = '85;107;47';",
                "        break;",
                "    case 'darkorange':",
                "        eventsFunctionContext.returnValue = '255;140;0';",
                "        break;",
                "    case 'darkorchid':",
                "        eventsFunctionContext.returnValue = '153;50;204';",
                "        break;",
                "    case 'darkred':",
                "        eventsFunctionContext.returnValue = '139;0;0';",
                "        break;",
                "    case 'darksalmon':",
                "        eventsFunctionContext.returnValue = '233;150;122';",
                "        break;",
                "    case 'darkseagreen':",
                "        eventsFunctionContext.returnValue = '143;188;143';",
                "        break;",
                "    case 'darkslateblue':",
                "        eventsFunctionContext.returnValue = '72;61;139';",
                "        break;",
                "    case 'darkslategray':",
                "    case 'darkslategrey':",
                "        eventsFunctionContext.returnValue = '47;79;79';",
                "        break;",
                "    case 'darkturquoise':",
                "        eventsFunctionContext.returnValue = '0;206;209';",
                "        break;",
                "    case 'darkviolet':",
                "        eventsFunctionContext.returnValue = '148;0;211';",
                "        break;",
                "    case 'deeppink':",
                "        eventsFunctionContext.returnValue = '255;20;147';",
                "        break;",
                "    case 'deepskyblue':",
                "        eventsFunctionContext.returnValue = '0;191;255';",
                "        break;",
                "    case 'dimgray':",
                "    case 'dimgrey':",
                "        eventsFunctionContext.returnValue = '105;105;105';",
                "        break;",
                "    case 'dodgerblue':",
                "        eventsFunctionContext.returnValue = '30;144;255';",
                "        break;",
                "    case 'firebrick':",
                "        eventsFunctionContext.returnValue = '178;34;34';",
                "        break;",
                "    case 'floralwhite':",
                "        eventsFunctionContext.returnValue = '255;250;240';",
                "        break;",
                "    case 'forestgreen':",
                "        eventsFunctionContext.returnValue = '32;139;34';",
                "        break;",
                "    case 'gainsboro':",
                "        eventsFunctionContext.returnValue = '220;220;220';",
                "        break;",
                "    case 'ghostwhite':",
                "        eventsFunctionContext.returnValue = '248;248;255';",
                "        break;",
                "    case 'gold':",
                "        eventsFunctionContext.returnValue = '255;215;0';",
                "        break;",
                "    case 'goldenrod':",
                "        eventsFunctionContext.returnValue = '218;165;32';",
                "        break;",
                "    case 'greenyellow':",
                "        eventsFunctionContext.returnValue = '173;255;47';",
                "        break;",
                "    case 'grey':",
                "        eventsFunctionContext.returnValue = '128;128;128';",
                "        break;",
                "    case 'honeydew':",
                "        eventsFunctionContext.returnValue = '240;255;240';",
                "        break;",
                "    case 'hotpink':",
                "        eventsFunctionContext.returnValue = '255;105;180';",
                "        break;",
                "    case 'indianred':",
                "        eventsFunctionContext.returnValue = '205;92;92';",
                "        break;",
                "    case 'indigo':",
                "        eventsFunctionContext.returnValue = '75;0;130';",
                "        break;",
                "    case 'ivory':",
                "        eventsFunctionContext.returnValue = '255;255;240';",
                "        break;",
                "    case 'khaki':",
                "        eventsFunctionContext.returnValue = '240;230;140';",
                "        break;",
                "    case 'lavender':",
                "        eventsFunctionContext.returnValue = '230;230;250';",
                "        break;",
                "    case 'lavenderblush':",
                "        eventsFunctionContext.returnValue = '255;240;245';",
                "        break;",
                "    case 'lawngreen':",
                "        eventsFunctionContext.returnValue = '124;252;0';",
                "        break;",
                "    case 'lemonchiffon':",
                "        eventsFunctionContext.returnValue = '255;250;205';",
                "        break;",
                "    case 'lightblue':",
                "        eventsFunctionContext.returnValue = '173;216;230';",
                "        break;",
                "    case 'lightcoral':",
                "        eventsFunctionContext.returnValue = '240;128;128';",
                "        break;",
                "    case 'lightcyan':",
                "        eventsFunctionContext.returnValue = '224;255;255';",
                "        break;",
                "    case 'lightgoldenrodyellow':",
                "        eventsFunctionContext.returnValue = '250;250;210';",
                "        break;",
                "    case 'lightgray':",
                "    case 'lightgrey':",
                "        eventsFunctionContext.returnValue = '211;211;211';",
                "        break;",
                "    case 'lightgreen':",
                "        eventsFunctionContext.returnValue = '144;238;144';",
                "        break;",
                "    case 'lightpink':",
                "        eventsFunctionContext.returnValue = '255;182;193';",
                "        break;",
                "    case 'lightsalmon':",
                "        eventsFunctionContext.returnValue = '255;160;122';",
                "        break;",
                "    case 'lightseagreen':",
                "        eventsFunctionContext.returnValue = '32;178;170';",
                "        break;",
                "    case 'lightskyblue':",
                "        eventsFunctionContext.returnValue = '135;206;250';",
                "        break;",
                "    case 'lightslategray':",
                "    case 'lightslategrey':",
                "        eventsFunctionContext.returnValue = '119;136;153';",
                "        break;",
                "    case 'lightsteelblue':",
                "        eventsFunctionContext.returnValue = '176;196;222';",
                "        break;",
                "    case 'lightyellow':",
                "        eventsFunctionContext.returnValue = '255;255;224';",
                "        break;",
                "    case 'limegreen':",
                "        eventsFunctionContext.returnValue = '50;205;50';",
                "        break;",
                "    case 'linen':",
                "        eventsFunctionContext.returnValue = '250;240;230';",
                "        break;",
                "    case 'magenta':",
                "        eventsFunctionContext.returnValue = '255;0;255';",
                "        break;",
                "    case 'mediumaquamarine':",
                "        eventsFunctionContext.returnValue = '102;205;170';",
                "        break;",
                "    case 'mediumblue':",
                "        eventsFunctionContext.returnValue = '0;0;205';",
                "        break;",
                "    case 'mediumorchid':",
                "        eventsFunctionContext.returnValue = '186;85;211';",
                "        break;",
                "    case 'mediumpurple':",
                "        eventsFunctionContext.returnValue = '147;112;219';",
                "        break;",
                "    case 'mediumseagreen':",
                "        eventsFunctionContext.returnValue = '60;179;113';",
                "        break;",
                "    case 'mediumslateblue':",
                "        eventsFunctionContext.returnValue = '123;104;238';",
                "        break;",
                "    case 'mediumspringgreen':",
                "        eventsFunctionContext.returnValue = '0;250;154';",
                "        break;",
                "    case 'mediumturquoise':",
                "        eventsFunctionContext.returnValue = '72;209;204';",
                "        break;",
                "    case 'mediumvioletred':",
                "        eventsFunctionContext.returnValue = '199;21;133';",
                "        break;",
                "    case 'midnightblue':",
                "        eventsFunctionContext.returnValue = '25;25;112';",
                "        break;",
                "    case 'mintcream':",
                "        eventsFunctionContext.returnValue = '245;255;250';",
                "        break;",
                "    case 'mistyrose':",
                "        eventsFunctionContext.returnValue = '255;228;225';",
                "        break;",
                "    case 'moccasin':",
                "        eventsFunctionContext.returnValue = '255;228;181';",
                "        break;",
                "    case 'navajowhite':",
                "        eventsFunctionContext.returnValue = '255;222;173';",
                "        break;",
                "    case 'oldlace':",
                "        eventsFunctionContext.returnValue = '253;245;230';",
                "        break;",
                "    case 'olivedrab':",
                "        eventsFunctionContext.returnValue = '107;142;35';",
                "        break;",
                "    case 'orangered':",
                "        eventsFunctionContext.returnValue = '255;69;0';",
                "        break;",
                "    case 'orchid':",
                "        eventsFunctionContext.returnValue = '218;112;214';",
                "        break;",
                "    case 'palegoldenrod':",
                "        eventsFunctionContext.returnValue = '238;232;170';",
                "        break;",
                "    case 'palegreen':",
                "        eventsFunctionContext.returnValue = '152;251;152';",
                "        break;",
                "    case 'paleturquoise':",
                "        eventsFunctionContext.returnValue = '175;238;238';",
                "        break;",
                "    case 'palevioletred':",
                "        eventsFunctionContext.returnValue = '219;112;147';",
                "        break;",
                "    case 'papayawhip':",
                "        eventsFunctionContext.returnValue = '255;239;213';",
                "        break;",
                "    case 'peachpuff':",
                "        eventsFunctionContext.returnValue = '255;218;185';",
                "        break;",
                "    case 'peru':",
                "        eventsFunctionContext.returnValue = '205;133;63';",
                "        break;",
                "    case 'pink':",
                "        eventsFunctionContext.returnValue = '255;192;203';",
                "        break;",
                "    case 'plum':",
                "        eventsFunctionContext.returnValue = '221;160;221';",
                "        break;",
                "    case 'powderblue':",
                "        eventsFunctionContext.returnValue = '176;224;230';",
                "        break;",
                "    case 'rosybrown':",
                "        eventsFunctionContext.returnValue = '188;143;143';",
                "        break;",
                "    case 'royalblue':",
                "        eventsFunctionContext.returnValue = '65;105;225';",
                "        break;",
                "    case 'saddlebrown':",
                "        eventsFunctionContext.returnValue = '139;69;19';",
                "        break;",
                "    case 'salmon':",
                "        eventsFunctionContext.returnValue = '150;128;114';",
                "        break;",
                "    case 'sandybrown':",
                "        eventsFunctionContext.returnValue = '244;164;96';",
                "        break;",
                "    case 'seagreen':",
                "        eventsFunctionContext.returnValue = '46;139;87';",
                "        break;",
                "    case 'seashell':",
                "        eventsFunctionContext.returnValue = '255;245;238';",
                "        break;",
                "    case 'sienna':",
                "        eventsFunctionContext.returnValue = '160;82;45';",
                "        break;",
                "    case 'skyblue':",
                "        eventsFunctionContext.returnValue = '135;206;235';",
                "        break;",
                "    case 'slateblue':",
                "        eventsFunctionContext.returnValue = '106;90;205';",
                "        break;",
                "    case 'slategray':",
                "    case 'slategrey':",
                "        eventsFunctionContext.returnValue = '112;128;144';",
                "        break;",
                "    case 'snow':",
                "        eventsFunctionContext.returnValue = '255;250;250';",
                "        break;",
                "    case 'springgreen':",
                "        eventsFunctionContext.returnValue = '0;255;127';",
                "        break;",
                "    case 'steelblue':",
                "        eventsFunctionContext.returnValue = '70;130;180';",
                "        break;",
                "    case 'tan':",
                "        eventsFunctionContext.returnValue = '210;180;140';",
                "        break;",
                "    case 'thistle':",
                "        eventsFunctionContext.returnValue = '216;191;216';",
                "        break;",
                "    case 'tomato':",
                "        eventsFunctionContext.returnValue = '255;99;71';",
                "        break;",
                "    case 'turquoise':",
                "        eventsFunctionContext.returnValue = '64;224;208';",
                "        break;",
                "    case 'violet':",
                "        eventsFunctionContext.returnValue = '238;130;238';",
                "        break;",
                "    case 'wheat':",
                "        eventsFunctionContext.returnValue = '245;222;179';",
                "        break;",
                "    case 'whitesmoke':",
                "        eventsFunctionContext.returnValue = '245;245;245';",
                "        break;",
                "    case 'yellowgreen':",
                "        eventsFunctionContext.returnValue = '154;205;50';",
                "        break;",
                "    case 'rebeccapurple':",
                "        eventsFunctionContext.returnValue = '102;51;153';",
                "        break;",
                "    default:",
                "        eventsFunctionContext.returnValue = '0;0;0';",
                "        console.error(\"Not a vaild color name\");        ",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Name of a color",
              "name": "n",
              "type": "color"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts HSL color values into a RGB string.  Valid input ranges:  H(0 to 360), S(0 to 100), L(0 to 100).",
          "fullName": "HSL to RGB",
          "functionType": "StringExpression",
          "name": "HslToRgb",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "try {",
                "    let h = parseFloat(eventsFunctionContext.getArgument(\"Hue\")),",
                "        s = parseFloat(eventsFunctionContext.getArgument(\"Saturation\")),",
                "        l = parseFloat(eventsFunctionContext.getArgument(\"Lightness\"));",
                "",
                "    s = gdjs.evtTools.common.clamp(s, 0, 100);",
                "    l = gdjs.evtTools.common.clamp(l, 0, 100);",
                "",
                "    h %= 360;",
                "    if (h < 0) {",
                "        h += 360;",
                "    }",
                "",
                "    s /= 100;",
                "    l /= 100;",
                "",
                "    let a = s * Math.min(l, 1 - l);",
                "    let f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k , 1), - 1);                 ",
                "",
                "    eventsFunctionContext.returnValue = Math.round(f(0) * 255) + ';' + Math.round(f(8) * 255) + ';' + Math.round(f(4) * 255);",
                "} catch(e) {",
                "    console.error(\"Unable to convert a color: \", e);",
                "    eventsFunctionContext.returnValue = \"0;0;0\";",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Hue 0-360",
              "name": "Hue",
              "type": "expression"
            },
            {
              "description": "Saturation 0-100",
              "name": "Saturation",
              "type": "expression"
            },
            {
              "description": "Lightness 0-100",
              "name": "Lightness",
              "type": "expression"
            }
          ],
          "objectGroups": []
        },
        {
          "description": "Converts a color hue (range: 0 to 360) into an RGB color string with 100% saturation and 50% lightness.",
          "fullName": "Hue to RGB",
          "functionType": "StringExpression",
          "name": "HueToRgb",
          "sentence": "",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "try {",
                "    let h = parseFloat(eventsFunctionContext.getArgument(\"Hue\")),",
                "        s = 100,",
                "        l = 50;",
                "",
                "    s /= 100;",
                "    l /= 100;",
                "",
                "    h %= 360;",
                "    if (h < 0) {",
                "        h += 360;",
                "    }",
                "",
                "    let a = s * Math.min(l, 1 - l);",
                "    let f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k , 1), - 1);                 ",
                "",
                "    eventsFunctionContext.returnValue = Math.round(f(0) * 255) + ';' + Math.round(f(8) * 255) + ';' + Math.round(f(4) * 255);",
                "} catch(e) {",
                "    console.error(\"Unable to convert a color: \", e);",
                "    eventsFunctionContext.returnValue = \"0;0;0\";",
                "}"
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "expressionType": {
            "type": "string"
          },
          "parameters": [
            {
              "description": "Hue 0-360",
              "name": "Hue",
              "type": "expression"
            }
          ],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [],
      "eventsBasedObjects": []
    },
    {
      "author": "D8H",
      "category": "Visual effect",
      "extensionNamespace": "",
      "fullName": "Marching Squares (experimental)",
      "helpPath": "/extensions/marching-squares/details",
      "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLXBlYW51dC1vdXRsaW5lIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTEyIDIzQzExLjUzIDIzIDExLjA3IDIyLjk1IDEwLjYxIDIyLjg1QzcuMSAyMi4xIDQuODcgMTguNjQgNS42MiAxNS4xM0M1Ljg3IDEzLjk1IDYuNDUgMTIuODcgNy4yOCAxMkM3LjYyIDExLjY0IDcuNjIgMTEuMDggNy4yOCAxMC43MkM1LjIgOC4xNCA1LjYgNC4zNiA4LjE4IDIuMjhTMTQuNTQuNjA3IDE2LjYyIDMuMTlDMTguMzkgNS4zOCAxOC4zOSA4LjUgMTYuNjIgMTAuNzJDMTYuMzMgMTEuMTMgMTYuMzcgMTEuNyAxNi43MiAxMi4wNkMxOS4xNyAxNC42OCAxOS4wNCAxOC44IDE2LjQxIDIxLjI1QzE1LjIyIDIyLjM3IDEzLjY0IDIzIDEyIDIzTTEyIDNDMTEuMDkgMyAxMC4yIDMuMzEgOS41IDMuODlDOC41NSA0LjY1IDggNS43OSA4IDdDOCA3LjkxIDguMzEgOC43OSA4Ljg4IDkuNUM5Ljg0IDEwLjY0IDkuNzcgMTIuMzMgOC43MyAxMy40MUM3LjAzIDE1LjIyIDcuMTMgMTguMDcgOC45NCAxOS43N1MxMy42IDIxLjM4IDE1LjMgMTkuNTZDMTYuOTIgMTcuODMgMTYuOTIgMTUuMTQgMTUuMyAxMy40MUMxNC4yMyAxMi4zMiAxNC4xNSAxMC42IDE1LjEyIDkuNDFDMTYuNSA3LjY5IDE2LjIyIDUuMTcgMTQuNSAzLjc5QzE0IDMuNDEgMTMuNDcgMy4xNCAxMi44OCAzQzEyLjU5IDMgMTIuMjkgMyAxMiAzTTEyIDZDMTIgNi41NSAxMi40NSA3IDEzIDdTMTQgNi41NSAxNCA2IDEzLjU1IDUgMTMgNSAxMiA1LjQ1IDEyIDZNMTQgMTlDMTQuNTUgMTkgMTUgMTguNTUgMTUgMThTMTQuNTUgMTcgMTQgMTcgMTMgMTcuNDUgMTMgMTggMTMuNDUgMTkgMTQgMTlNMTMgMTZDMTMuNTUgMTYgMTQgMTUuNTUgMTQgMTVTMTMuNTUgMTQgMTMgMTQgMTIgMTQuNDUgMTIgMTUgMTIuNDUgMTYgMTMgMTZNMTEgMThDMTEuNTUgMTggMTIgMTcuNTUgMTIgMTdTMTEuNTUgMTYgMTEgMTYgMTAgMTYuNDUgMTAgMTcgMTAuNDUgMTggMTEgMThaIiAvPjwvc3ZnPg==",
      "name": "MarchingSquares",
      "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/peanut-outline.svg",
      "shortDescription": "Allow to build a \"scalar field\" and draw contour lines of it: useful for fog of wars, liquid effects, paint the ground, etc...",
      "version": "0.5.5",
      "description": [
        "It can be helpful for:",
        "  * Liquid effects like water, blobs or lava ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-liquids))",
        "  * Fog of wars ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-fog-of-war))",
        "  * Platformer with destructible platforms ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-platforms-painter))",
        "  * Dynamically paint territories ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-qix))",
        "  * Top-down relief with physics ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-terraforming))",
        "  * Island generator ([open the project online](https://editor.gdevelop.io/?project=example://marching-squares-island-generator))"
      ],
      "origin": {
        "identifier": "MarchingSquares",
        "name": "gdevelop-extension-store"
      },
      "tags": [
        "blobs",
        "liquid",
        "lava",
        "water",
        "fog",
        "paint",
        "heightmap"
      ],
      "authorIds": [
        "IWykYNRvhCZBN3vEgKEbBPOR3Oc2"
      ],
      "dependencies": [],
      "eventsFunctions": [
        {
          "description": "Define the scalar field painter library JavaScript code.",
          "fullName": "Define scalar field painter library",
          "functionType": "Action",
          "name": "DefineScalarFieldPainterLibrary",
          "private": true,
          "sentence": "Define the scalar field painter library JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "// This library comes from https://github.com/D8H/scalar-field-painter",
                "// It can be generated with \"npm run build\" to the dist/ScalarFieldPainter.js",
                "",
                "    /**",
                "     * A stock to reuse instances and avoid allocation.",
                "     */",
                "    var Stock = /** @class */ (function () {",
                "        /**",
                "         * Create a stock.",
                "         */",
                "        function Stock() {",
                "            this.elements = [];",
                "        }",
                "        /**",
                "         * Get an element to avoid allocation or create a new one if the stock is",
                "         * empty.",
                "         * @param create",
                "         * @returns an element",
                "         */",
                "        Stock.prototype.getOrCreate = function (create) {",
                "            return this.elements.pop() || create();",
                "        };",
                "        /**",
                "         * Stock an element to use it later.",
                "         * @param element",
                "         */",
                "        Stock.prototype.stock = function (element) {",
                "            this.elements.push(element);",
                "        };",
                "        /**",
                "         * Free all the elements from the stock.",
                "         */",
                "        Stock.prototype.flush = function () {",
                "            this.elements.length = 0;",
                "        };",
                "        return Stock;",
                "    }());",
                "",
                "    var deltas = [",
                "        { x: -1, y: 0 },",
                "        { x: 1, y: 0 },",
                "        { x: 0, y: -1 },",
                "        { x: 0, y: 1 },",
                "    ];",
                "    var createNode = function () { return ({ x: 0, y: 0 }); };",
                "    var createContourNode = function () { return ({",
                "        x: 0,",
                "        y: 0,",
                "        originX: 0,",
                "        originY: 0,",
                "        value: 0,",
                "    }); };",
                "    /**",
                "     *",
                "     */",
                "    var FloodFill = /** @class */ (function () {",
                "        function FloodFill(scalarField) {",
                "            this.floodStack = [];",
                "            this.nodeStock = new Stock();",
                "            this.contourStack = [];",
                "            this.nextContourStack = [];",
                "            this.contourNodeStock = new Stock();",
                "            this.scalarField = scalarField;",
                "        }",
                "        /**",
                "         * Fill an area from a given location until a maximum field value is reached.",
                "         *",
                "         * The result is the same as drawing circles at every point of the area.",
                "         * This mean that the area will be filled with a value a lot gibber than 1.",
                "         *",
                "         * @param originX {float} in grid basis",
                "         * @param originY {float} in grid basis",
                "         * @param valueMax {float} the value where to stop the flooding",
                "         * @param thickness {float} the thickness of the contour shading.",
                "         * The field will have the value 1 at this given distance from the area.",
                "         * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "         * or a maximum otherwise.",
                "         */",
                "        FloodFill.prototype.fillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "            var thicknessSq = thickness * thickness;",
                "            var fillingValue = Math.max(valueMax, thicknessSq * 1024 * 1024);",
                "            var cappingRadius = cappingRadiusRatio * thickness;",
                "            var cappingRadiusSq = cappingRadius * cappingRadius;",
                "            var getContourValue = function (fieldValue, distanceSq) {",
                "                var value = thicknessSq / distanceSq;",
                "                return fieldValue < value && distanceSq < cappingRadiusSq ? value : null;",
                "            };",
                "            this.floodFrom(originX, originY, function (fieldValue) { return fieldValue < valueMax; }, fillingValue, getContourValue);",
                "            this.shadeContour(getContourValue);",
                "        };",
                "        /**",
                "         * Unfill an area from a given location until a minimum field value is reached.",
                "         *",
                "         * It fills the area with the value 0.",
                "         *",
                "         * @param originX {float} in grid basis",
                "         * @param originY {float} in grid basis",
                "         * @param valueMax {float} the value where to stop the flooding",
                "         * @param thickness {float} the thickness of the contour shading.",
                "         * The field will have the value 1 at this given distance from the area.",
                "         * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "         * or a maximum otherwise.",
                "         */",
                "        FloodFill.prototype.unfillFrom = function (originX, originY, valueMin, thickness, cappingRadiusRatio) {",
                "            var fillingValue = 0;",
                "            var thicknessSq = thickness * thickness;",
                "            var cappingRadius = cappingRadiusRatio * thickness;",
                "            var cappingRadiusSq = cappingRadius * cappingRadius;",
                "            var getContourValue = function (fieldValue, distanceSq) {",
                "                var value = distanceSq / thicknessSq;",
                "                return fieldValue > value && distanceSq < cappingRadiusSq ? value : null;",
                "            };",
                "            this.floodFrom(originX, originY, function (fieldValue) { return fieldValue > valueMin; }, fillingValue, getContourValue);",
                "            this.shadeContour(getContourValue);",
                "        };",
                "        /**",
                "         * Flood an area from a given location until a condition is reached.",
                "         * @param originX {float} in grid basis",
                "         * @param originY {float} in grid basis",
                "         * @param canFlood {(float) => boolean}",
                "         * @param fillingValue {float}",
                "         * @param getContourValue {(number, number) => number}",
                "         * or a maximum otherwise.",
                "         */",
                "        FloodFill.prototype.floodFrom = function (originX, originY, canFlood, fillingValue, getContourValue) {",
                "            var scalarField = this.scalarField;",
                "            // They should already be empty at this point.",
                "            this.floodStack.length = 0;",
                "            this.contourStack.length = 0;",
                "            this.nextContourStack.length = 0;",
                "            {",
                "                var x = Math.round(originX);",
                "                var y = Math.round(originY);",
                "                if (!scalarField.isInside(x, y)) {",
                "                    return;",
                "                }",
                "                var fieldValue = scalarField.get(x, y);",
                "                if (canFlood(fieldValue)) {",
                "                    var node = this.nodeStock.getOrCreate(createNode);",
                "                    node.x = x;",
                "                    node.y = y;",
                "                    this.floodStack.push(node);",
                "                }",
                "            }",
                "            while (this.floodStack.length > 0) {",
                "                var node = this.floodStack.pop();",
                "                var x = node.x;",
                "                var y = node.y;",
                "                scalarField.set(x, y, fillingValue);",
                "                for (var _i = 0, deltas_1 = deltas; _i < deltas_1.length; _i++) {",
                "                    var delta = deltas_1[_i];",
                "                    var neighborX = x + delta.x;",
                "                    var neighborY = y + delta.y;",
                "                    if (!scalarField.isInside(neighborX, neighborY)) {",
                "                        continue;",
                "                    }",
                "                    var fieldValue = scalarField.get(neighborX, neighborY);",
                "                    if (canFlood(fieldValue)) {",
                "                        var neighbor = this.nodeStock.getOrCreate(createNode);",
                "                        neighbor.x = neighborX;",
                "                        neighbor.y = neighborY;",
                "                        this.floodStack.push(neighbor);",
                "                    }",
                "                    else {",
                "                        this.checkAnAddContourNode(neighborX, neighborY, x, y, getContourValue);",
                "                    }",
                "                }",
                "                this.nodeStock.stock(node);",
                "            }",
                "        };",
                "        /**",
                "         * Shade the contour to keep the field somewhat continuous.",
                "         * @param getContourValue",
                "         */",
                "        FloodFill.prototype.shadeContour = function (getContourValue) {",
                "            var scalarField = this.scalarField;",
                "            var swap = this.nextContourStack;",
                "            this.nextContourStack = this.contourStack;",
                "            this.contourStack = swap;",
                "            while (this.contourStack.length > 0) {",
                "                while (this.contourStack.length > 0) {",
                "                    var node = this.contourStack.pop();",
                "                    if (scalarField.get(node.x, node.y) > node.value) {",
                "                        // This node wasn't the nearest one.",
                "                        continue;",
                "                    }",
                "                    for (var _i = 0, deltas_2 = deltas; _i < deltas_2.length; _i++) {",
                "                        var delta = deltas_2[_i];",
                "                        var neighborX = node.x + delta.x;",
                "                        var neighborY = node.y + delta.y;",
                "                        this.checkAnAddContourNode(neighborX, neighborY, node.originX, node.originY, getContourValue);",
                "                    }",
                "                    this.contourNodeStock.stock(node);",
                "                }",
                "                var swap_1 = this.nextContourStack;",
                "                this.nextContourStack = this.contourStack;",
                "                this.contourStack = swap_1;",
                "            }",
                "        };",
                "        FloodFill.prototype.checkAnAddContourNode = function (nodeX, nodeY, originX, originY, getContourValue) {",
                "            var scalarField = this.scalarField;",
                "            if (!scalarField.isInside(nodeX, nodeY)) {",
                "                return;",
                "            }",
                "            // Avoid too big values",
                "            var minDistanceSq = 1 / 1024 / 1024;",
                "            var deltaX = nodeX - originX;",
                "            var deltaY = nodeY - originY;",
                "            var distanceSq = Math.max(minDistanceSq, deltaX * deltaX + deltaY * deltaY);",
                "            var value = getContourValue(scalarField.get(nodeX, nodeY), distanceSq);",
                "            if (value !== null) {",
                "                scalarField.set(nodeX, nodeY, value);",
                "                var newNode = this.contourNodeStock.getOrCreate(createContourNode);",
                "                newNode.x = nodeX;",
                "                newNode.y = nodeY;",
                "                newNode.originX = originX;",
                "                newNode.originY = originY;",
                "                newNode.value = value;",
                "                this.nextContourStack.push(newNode);",
                "            }",
                "        };",
                "        return FloodFill;",
                "    }());",
                "",
                "    /**",
                "     * @param x1 {float} first point x",
                "     * @param y1 {float} first point y",
                "     * @param x2 {float} second point x",
                "     * @param y2 {float} second point y",
                "     * @return {float} the square distance between 2 points",
                "     */",
                "    var getDistanceSq = function (x1, y1, x2, y2) {",
                "        var deltaX = x2 - x1;",
                "        var deltaY = y2 - y1;",
                "        return deltaX * deltaX + deltaY * deltaY;",
                "    };",
                "    /**",
                "     * @param x {float} point x",
                "     * @param y {float} point y",
                "     * @param x1 {float} segment extremity x",
                "     * @param y1 {float} segment extremity y",
                "     * @param x2 {float} segment extremity x",
                "     * @param y2 {float} segment extremity y",
                "     * @return {float} the square distance between a point and a segment",
                "     */",
                "    var getDistanceSqToSegment = function (x, y, x1, y1, x2, y2) {",
                "        var length2 = getDistanceSq(x1, y1, x2, y2);",
                "        if (length2 === 0)",
                "            return getDistanceSq(x, y, x1, y1);",
                "        var t = Math.max(0, Math.min(1, ((x - x1) * (x2 - x1) + (y - y1) * (y2 - y1)) / length2));",
                "        return getDistanceSq(x, y, x1 + t * (x2 - x1), y1 + t * (y2 - y1));",
                "    };",
                "    /**",
                "     * A scalar field.",
                "     */",
                "    var ScalarField = /** @class */ (function () {",
                "        /**",
                "         * Create a scalar field.",
                "         * @param dimX {integer}",
                "         * @param dimY {integer}",
                "         */",
                "        function ScalarField(dimX, dimY) {",
                "            var fieldValues = new Array(dimY);",
                "            for (var y = 0; y < dimY; y++) {",
                "                fieldValues[y] = new Array(dimX).fill(0);",
                "            }",
                "            this.values = fieldValues;",
                "            this.floodFill = new FloodFill(this);",
                "        }",
                "        /**",
                "         * @return {integer} grid dimension on y",
                "         */",
                "        ScalarField.prototype.dimY = function () {",
                "            return this.values.length;",
                "        };",
                "        /**",
                "         * @return {integer} grid dimension on y",
                "         */",
                "        ScalarField.prototype.dimX = function () {",
                "            var firstColumn = this.values[0];",
                "            return firstColumn ? firstColumn.length : 0;",
                "        };",
                "        ScalarField.prototype.isInside = function (x, y) {",
                "            return x >= 0 && x <= this.dimX() - 1 && y >= 0 && y <= this.dimY() - 1;",
                "        };",
                "        ScalarField.prototype.get = function (x, y) {",
                "            return this.values[y][x];",
                "        };",
                "        /**",
                "         * @param squareX {integer} x grid index",
                "         * @param squareY {integer} y grid index",
                "         * @param value {float} the field value",
                "         */",
                "        ScalarField.prototype.set = function (x, y, value) {",
                "            this.values[y][x] = value;",
                "        };",
                "        /**",
                "         * @param pointX {float} in grid basis",
                "         * @param pointY {float} in grid basis",
                "         * @return {float} the field value",
                "         */",
                "        ScalarField.prototype.extrapolate = function (x, y) {",
                "            var squareX = Math.floor(x);",
                "            var squareY = Math.floor(y);",
                "            if (squareX < 0 ||",
                "                squareY < 0 ||",
                "                squareX >= this.dimX() - 1 ||",
                "                squareY >= this.dimY() - 1) {",
                "                return 0;",
                "            }",
                "            // Extrapolate",
                "            var weighedValueSum = 0;",
                "            var weightSum = 0;",
                "            for (var vertexX = squareX; vertexX <= squareX + 1; vertexX++) {",
                "                for (var vertexY = squareY; vertexY <= squareY + 1; vertexY++) {",
                "                    var value = this.values[vertexY][vertexX];",
                "                    var dx = vertexX - x;",
                "                    var dy = vertexY - y;",
                "                    if (dx === 0 && dy === 0) {",
                "                        // No interpolation needed.",
                "                        return value;",
                "                    }",
                "                    else {",
                "                        var distance = Math.hypot(dx, dy);",
                "                        weighedValueSum += value / distance;",
                "                        weightSum += 1 / distance;",
                "                    }",
                "                }",
                "            }",
                "            var mean = weighedValueSum / weightSum;",
                "            return mean;",
                "        };",
                "        /**",
                "         * Clear the field by filling it with a give value.",
                "         * @param value {float}",
                "         */",
                "        ScalarField.prototype.clear = function (value) {",
                "            if (value === void 0) { value = 0; }",
                "            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {",
                "                var rowValues = _a[_i];",
                "                for (var x = 0; x < rowValues.length; x++) {",
                "                    rowValues[x] = value;",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Cap the field between 2 values.",
                "         * @param min {float}",
                "         * @param max {float}",
                "         */",
                "        ScalarField.prototype.clamp = function (min, max) {",
                "            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {",
                "                var rowValues = _a[_i];",
                "                for (var x = 0; x < rowValues.length; x++) {",
                "                    rowValues[x] = Math.min(Math.max(min, rowValues[x]), max);",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Apply an affine transformation on each field value.",
                "         * @param a {float} factor",
                "         * @param b {float} offset",
                "         */",
                "        ScalarField.prototype.transform = function (a, b) {",
                "            for (var _i = 0, _a = this.values; _i < _a.length; _i++) {",
                "                var rowValues = _a[_i];",
                "                for (var x = 0; x < rowValues.length; x++) {",
                "                    rowValues[x] = a * rowValues[x] + b;",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Merge the values from another field.",
                "         * @param scalarField {ScalarField}",
                "         * @param operation {function(float, float):float}",
                "         */",
                "        ScalarField.prototype.mergeField = function (scalarField, operation) {",
                "            const dimX = Math.min(this.dimX(), scalarField.dimX());",
                "            const dimY = Math.min(this.dimY(), scalarField.dimY());",
                "            for (var y = 0; y < dimY; y++) {",
                "                var thisRowValues = this.values[y];",
                "                var otherRowValues = scalarField.values[y];",
                "                for (var x = 0; x < dimX; x++) {",
                "                    thisRowValues[x] = operation(thisRowValues[x], otherRowValues[x]);",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Merge a disk in the field.",
                "         * @param centerX {float} in grid basis",
                "         * @param centerY {float} in grid basis",
                "         * @param radius {float} in grid basis",
                "         * @param cappingRadiusRatio {float}",
                "         * @param operation {function(float, float):float}",
                "         */",
                "        ScalarField.prototype.mergeDisk = function (centerX, centerY, radius, cappingRadiusRatio, operation) {",
                "            var cappingRadius = cappingRadiusRatio * radius;",
                "            var minX = Math.max(0, Math.floor(centerX - cappingRadius));",
                "            var minY = Math.max(0, Math.floor(centerY - cappingRadius));",
                "            var maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));",
                "            var maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));",
                "            var radiusSq = radius * radius;",
                "            // Avoid too big values",
                "            var minDistanceSq = 1 / 1024 / 1024;",
                "            for (var y = minY; y <= maxY; y++) {",
                "                var rowValues = this.values[y];",
                "                for (var x = minX; x <= maxX; x++) {",
                "                    var distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));",
                "                    rowValues[x] = operation(rowValues[x], radiusSq / distanceSq);",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Merge a segment in the field.",
                "         * @param startX {float} in grid basis",
                "         * @param startY {float} in grid basis",
                "         * @param endX {float} in grid basis",
                "         * @param endY {float} in grid basis",
                "         * @param thickness {float} in grid basis",
                "         * @param cappingRadiusRatio {float}",
                "         * @param operation {function(float, float):float}",
                "         */",
                "        ScalarField.prototype.mergeSegment = function (startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {",
                "            var cappingRadius = cappingRadiusRatio * thickness;",
                "            var minX = Math.max(0, Math.floor(Math.min(startX, endX) - cappingRadius));",
                "            var minY = Math.max(0, Math.floor(Math.min(startY, endY) - cappingRadius));",
                "            var maxX = Math.min(this.dimX() - 1, Math.ceil(Math.max(startX, endX) + cappingRadius));",
                "            var maxY = Math.min(this.dimY() - 1, Math.ceil(Math.max(startY, endY) + cappingRadius));",
                "            var thicknessSq = thickness * thickness;",
                "            // Avoid too big values",
                "            var minDistanceSq = 1 / 1024 / 1024;",
                "            for (var y = minY; y <= maxY; y++) {",
                "                var rowValues = this.values[y];",
                "                for (var x = minX; x <= maxX; x++) {",
                "                    var distanceSq = Math.max(minDistanceSq, getDistanceSqToSegment(x, y, startX, startY, endX, endY));",
                "                    rowValues[x] = operation(rowValues[x], thicknessSq / distanceSq);",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Merge a hill in the field.",
                "         * @param centerX {float} in grid basis",
                "         * @param centerY {float} in grid basis",
                "         * @param height {float}",
                "         * @param radius {float} in grid basis",
                "         * @param opacity {float}",
                "         * @param cappingRadiusRatio {float}",
                "         * @param operation {function(float, float):float}",
                "         */",
                "        ScalarField.prototype.mergeHill = function (centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {",
                "            var cappingRadius = cappingRadiusRatio * radius;",
                "            var minX = Math.max(0, Math.floor(centerX - cappingRadius));",
                "            var minY = Math.max(0, Math.floor(centerY - cappingRadius));",
                "            var maxX = Math.min(this.dimX() - 1, Math.ceil(centerX + cappingRadius));",
                "            var maxY = Math.min(this.dimY() - 1, Math.ceil(centerY + cappingRadius));",
                "            var logHeightDividedByRadiusSq = Math.log(height) / (radius * radius);",
                "            var opacityMultipliedByHeight = opacity * height;",
                "            // Avoid too big values",
                "            var minDistanceSq = 1 / 1024 / 1024;",
                "            for (var y = minY; y <= maxY; y++) {",
                "                var rowValues = this.values[y];",
                "                for (var x = minX; x <= maxX; x++) {",
                "                    var distanceSq = Math.max(minDistanceSq, getDistanceSq(x, y, centerX, centerY));",
                "                    // This is like a gaussian, but parametrized differently.",
                "                    rowValues[x] = operation(rowValues[x], opacityMultipliedByHeight *",
                "                        Math.exp(-distanceSq * logHeightDividedByRadiusSq));",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Flood an area from a given location until a maximum field value is reached.",
                "         * @param originX {float} in grid basis",
                "         * @param originY {float} in grid basis",
                "         * @param valueMax {float}",
                "         * @param thickness {float}",
                "         * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "         * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "         * or a maximum otherwise.",
                "         */",
                "        ScalarField.prototype.fillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "            this.floodFill.fillFrom(originX, originY, valueMax, thickness, cappingRadiusRatio);",
                "        };",
                "        /**",
                "         * Flood an area from a given location until a maximum field value is reached.",
                "         * @param originX {float} in grid basis",
                "         * @param originY {float} in grid basis",
                "         * @param valueMax {float}",
                "         * @param thickness {float}",
                "         * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "         * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "         * or a maximum otherwise.",
                "         */",
                "        ScalarField.prototype.unfillFrom = function (originX, originY, valueMin, thickness, cappingRadiusRatio) {",
                "            this.floodFill.unfillFrom(originX, originY, valueMin, thickness, cappingRadiusRatio);",
                "        };",
                "        return ScalarField;",
                "    }());",
                "",
                "    var South = 0;",
                "    var East = 1;",
                "    var North = 2;",
                "    var West = 3;",
                "    var SouthWest = 4;",
                "    var SouthEast = 5;",
                "    var NorthEast = 6;",
                "    var NorthWest = 7;",
                "    var SouthWestMask = 1;",
                "    var SouthEastMask = 2;",
                "    var NorthEastMask = 4;",
                "    var NorthWestMask = 8;",
                "    var marchingSquaresFillVertices = [",
                "        [],",
                "        [South, West, SouthWest],",
                "        [East, South, SouthEast],",
                "        [East, West, SouthWest, SouthEast],",
                "        [North, East, NorthEast],",
                "        [South, SouthWest, West, North, NorthEast, East],",
                "        [South, North, NorthEast, SouthEast],",
                "        [West, North, NorthEast, SouthEast, SouthWest],",
                "        [West, North, NorthWest],",
                "        [North, South, SouthWest, NorthWest],",
                "        [South, West, NorthWest, North, East, SouthEast],",
                "        [North, East, SouthEast, SouthWest, NorthWest],",
                "        [East, West, NorthWest, NorthEast],",
                "        [East, South, SouthWest, NorthWest, NorthEast],",
                "        [South, West, NorthWest, NorthEast, SouthEast],",
                "        [],",
                "    ];",
                "    var marchingSquaresOutlineVertices = [",
                "        [[]],",
                "        [[South, West]],",
                "        [[East, South]],",
                "        [[East, West]],",
                "        [[North, East]],",
                "        [",
                "            [East, South],",
                "            [West, North],",
                "        ],",
                "        [[South, North]],",
                "        [[West, North]],",
                "        [[West, North]],",
                "        [[North, South]],",
                "        [",
                "            [South, West],",
                "            [North, East],",
                "        ],",
                "        [[North, East]],",
                "        [[East, West]],",
                "        [[East, South]],",
                "        [[South, West]],",
                "        [[]],",
                "    ];",
                "    /**",
                "     * A marching square algorithm implementation.",
                "     */",
                "    var MarchingSquares = /** @class */ (function () {",
                "        /**",
                "         *",
                "         * @param scalarField",
                "         */",
                "        function MarchingSquares(scalarField) {",
                "            /** {FloatPoint} Avoid memory allocations when returning points */",
                "            this.workingPoint = [0, 0];",
                "            this.scalarField = scalarField;",
                "        }",
                "        /**",
                "         * @param x {integer} the square top in the grid",
                "         * @param y {integer} the square left in the grid",
                "         * @param threshold {float}",
                "         * @return {integer} one of the 16 marching squares cases",
                "         */",
                "        MarchingSquares.prototype.getSquareIndex = function (x, y, threshold) {",
                "            /** @type {float} */",
                "            var squareIndex = 0;",
                "            if (this.scalarField.get(x, y + 1) > threshold) {",
                "                squareIndex |= SouthWestMask;",
                "            }",
                "            if (this.scalarField.get(x + 1, y + 1) > threshold) {",
                "                squareIndex |= SouthEastMask;",
                "            }",
                "            if (this.scalarField.get(x + 1, y) > threshold) {",
                "                squareIndex |= NorthEastMask;",
                "            }",
                "            if (this.scalarField.get(x, y) > threshold) {",
                "                squareIndex |= NorthWestMask;",
                "            }",
                "            return squareIndex;",
                "        };",
                "        /**",
                "         * Returns the mean between 2 corners weighted by their field value.",
                "         * @param indexX1 {integer} first corner x",
                "         * @param indexY1 {integer} first corner y",
                "         * @param indexX2 {integer} second corner x",
                "         * @param indexY2 {integer} second corner y",
                "         * @param threshold {float}",
                "         * @return {float} x in the grid",
                "         */",
                "        MarchingSquares.prototype.betweenX = function (indexX1, indexY1, indexX2, indexY2, threshold) {",
                "            var value1 = this.scalarField.get(indexX1, indexY1);",
                "            var value2 = this.scalarField.get(indexX2, indexY2);",
                "            var weight1 = Math.abs(value1 - threshold);",
                "            var weight2 = Math.abs(value2 - threshold);",
                "            return (weight2 * indexX1 + weight1 * indexX2) / (weight1 + weight2);",
                "        };",
                "        /**",
                "         * Returns the mean between 2 corners weighted by their field value.",
                "         * @param indexX1 {integer} first corner x",
                "         * @param indexY1 {integer} first corner y",
                "         * @param indexX2 {integer} second corner x",
                "         * @param indexY2 {integer} second corner y",
                "         * @param threshold {float}",
                "         * @return {float} y in the grid",
                "         */",
                "        MarchingSquares.prototype.betweenY = function (indexX1, indexY1, indexX2, indexY2, threshold) {",
                "            var value1 = this.scalarField.get(indexX1, indexY1);",
                "            var value2 = this.scalarField.get(indexX2, indexY2);",
                "            var weight1 = Math.abs(value1 - threshold);",
                "            var weight2 = Math.abs(value2 - threshold);",
                "            return (weight2 * indexY1 + weight1 * indexY2) / (weight1 + weight2);",
                "        };",
                "        /**",
                "         * @param side {integer} point location",
                "         * @param indexX {integer} the square top in the grid",
                "         * @param indexY {integer} the square left in the grid",
                "         * @param threshold {float}",
                "         * @param point {FloatPoint} is the result",
                "         */",
                "        MarchingSquares.prototype.calcPoint = function (side, indexX, indexY, threshold, point) {",
                "            var gridX = 0;",
                "            var gridY = 0;",
                "            switch (side) {",
                "                case South:",
                "                    gridY = indexY + 1;",
                "                    gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);",
                "                    break;",
                "                case East:",
                "                    gridX = indexX + 1;",
                "                    gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);",
                "                    break;",
                "                case North:",
                "                    gridY = indexY;",
                "                    gridX = this.betweenX(indexX, gridY, indexX + 1, gridY, threshold);",
                "                    break;",
                "                case West:",
                "                    gridX = indexX;",
                "                    gridY = this.betweenY(gridX, indexY, gridX, indexY + 1, threshold);",
                "                    break;",
                "                case SouthWest:",
                "                    gridX = indexX;",
                "                    gridY = indexY + 1;",
                "                    break;",
                "                case SouthEast:",
                "                    gridX = indexX + 1;",
                "                    gridY = indexY + 1;",
                "                    break;",
                "                case NorthEast:",
                "                    gridX = indexX + 1;",
                "                    gridY = indexY;",
                "                    break;",
                "                case NorthWest:",
                "                    gridX = indexX;",
                "                    gridY = indexY;",
                "                    break;",
                "            }",
                "            point[0] = gridX;",
                "            point[1] = gridY;",
                "        };",
                "        /**",
                "         * Draw the field squares",
                "         * @param minX {integer} left",
                "         * @param minY {integer} top",
                "         * @param maxX {integer} right",
                "         * @param maxY {integer} bottom",
                "         * @param threshold {float}",
                "         * @param drawUnder {boolean}",
                "         * @param shapePainter {ShapePainter}",
                "         */",
                "        MarchingSquares.prototype.fillContour = function (minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {",
                "            var point = this.workingPoint;",
                "            // It draws bands and small polygons.",
                "            // The contour line is in a second loop, it's more efficient",
                "            // than switching the style constantly.",
                "            for (var squareY = minY; squareY < maxY - 1; squareY++) {",
                "                // for run-length encoding",
                "                var first15SquareX = -1;",
                "                for (var squareX = minX; squareX < maxX - 1; squareX++) {",
                "                    var squareIndex = this.getSquareIndex(squareX, squareY, threshold);",
                "                    if (drawUnder) {",
                "                        squareIndex = 15 - squareIndex;",
                "                    }",
                "                    if (squareIndex === 15) {",
                "                        shapePainter.onFilledSquareChange(squareX, squareY);",
                "                    }",
                "                    if (first15SquareX === -1 && squareIndex === 15) {",
                "                        first15SquareX = squareX;",
                "                    }",
                "                    if (first15SquareX !== -1) {",
                "                        if (squareIndex !== 15) {",
                "                            shapePainter.drawRectangle(first15SquareX, squareY, squareX, squareY + 1);",
                "                            first15SquareX = -1;",
                "                        }",
                "                        else if (squareX === maxX - 2) {",
                "                            shapePainter.drawRectangle(first15SquareX, squareY, squareX + 1, squareY + 1);",
                "                            first15SquareX = -1;",
                "                        }",
                "                    }",
                "                    if (squareIndex !== 0 && squareIndex !== 15) {",
                "                        var fillVertices = marchingSquaresFillVertices[squareIndex];",
                "                        this.calcPoint(fillVertices[0], squareX, squareY, threshold, point);",
                "                        shapePainter.beginPath(point[0], point[1]);",
                "                        for (var index = 1; index < fillVertices.length; index++) {",
                "                            this.calcPoint(fillVertices[index], squareX, squareY, threshold, point);",
                "                            shapePainter.lineTo(point[0], point[1]);",
                "                        }",
                "                        shapePainter.closePath();",
                "                        shapePainter.endPath(squareX, squareY);",
                "                    }",
                "                }",
                "            }",
                "        };",
                "        /**",
                "         * Draw the field squares",
                "         * @param minX {integer} left",
                "         * @param minY {integer} top",
                "         * @param maxX {integer} right",
                "         * @param maxY {integer} bottom",
                "         * @param threshold {float}",
                "         * @param drawUnder {boolean}",
                "         * @param shapePainter {ShapePainter}",
                "         */",
                "        MarchingSquares.prototype.outlineContour = function (minX, minY, maxX, maxY, threshold, drawUnder, shapePainter) {",
                "            var point = this.workingPoint;",
                "            for (var squareY = minY; squareY < maxY - 1; squareY++) {",
                "                for (var squareX = minX; squareX < maxX - 1; squareX++) {",
                "                    var squareIndex = this.getSquareIndex(squareX, squareY, threshold);",
                "                    if (drawUnder) {",
                "                        squareIndex = 15 - squareIndex;",
                "                    }",
                "                    if (squareIndex !== 0 && squareIndex !== 15) {",
                "                        for (var _i = 0, _a = marchingSquaresOutlineVertices[squareIndex]; _i < _a.length; _i++) {",
                "                            var outlineVertices = _a[_i];",
                "                            this.calcPoint(outlineVertices[0], squareX, squareY, threshold, point);",
                "                            shapePainter.beginPath(point[0], point[1]);",
                "                            for (var index = 1; index < outlineVertices.length; index++) {",
                "                                this.calcPoint(outlineVertices[index], squareX, squareY, threshold, point);",
                "                                shapePainter.lineTo(point[0], point[1]);",
                "                            }",
                "                            shapePainter.endPath(squareX, squareY);",
                "                        }",
                "                    }",
                "                }",
                "            }",
                "        };",
                "        return MarchingSquares;",
                "    }());",
                "",
                "    /**",
                "     * A coordinate converter between a surface and a grid.",
                "     */",
                "    var CoordConverter = /** @class */ (function () {",
                "        /**",
                "         * Create a coordinate converter between a surface and a grid.",
                "         * @param cellWidth {float}",
                "         * @param cellHeight {float}",
                "         * @param left {float}",
                "         * @param top {float}",
                "         * @param right {float}",
                "         * @param bottom {float}",
                "         */",
                "        function CoordConverter(cellWidth, cellHeight, left, top, right, bottom) {",
                "            this.cellWidth = cellWidth;",
                "            this.cellHeight = cellHeight;",
                "            this.left = left;",
                "            this.top = top;",
                "            this.right = right;",
                "            this.bottom = bottom;",
                "        }",
                "        /**",
                "         * @param x {float} in the scene basis",
                "         * @return {float} x in the grid basis",
                "         */",
                "        CoordConverter.prototype.convertToGridBasisX = function (x) {",
                "            return (x - this.left) / this.cellWidth;",
                "        };",
                "        /**",
                "         * @param y {float} in the scene basis",
                "         * @return {float} y in the grid basis",
                "         */",
                "        CoordConverter.prototype.convertToGridBasisY = function (y) {",
                "            return (y - this.top) / this.cellHeight;",
                "        };",
                "        /**",
                "         * @param x {float} in the grid basis",
                "         * @return {float} x in the scene basis",
                "         */",
                "        CoordConverter.prototype.convertFromGridBasisX = function (x) {",
                "            return x * this.cellWidth + this.left;",
                "        };",
                "        /**",
                "         * @param y {float} in the grid basis",
                "         * @return {float} y in the scene basis",
                "         */",
                "        CoordConverter.prototype.convertFromGridBasisY = function (y) {",
                "            return y * this.cellHeight + this.top;",
                "        };",
                "        /**",
                "         * @param distance {float} in the grid basis",
                "         * @return {float} distance in the scene basis",
                "         */",
                "        CoordConverter.prototype.convertToGridBasisDistance = function (distance) {",
                "            return distance / this.cellWidth;",
                "        };",
                "        return CoordConverter;",
                "    }());",
                "",
                "    /**",
                "     * A height map.",
                "     */",
                "    var HeightMap = /** @class */ (function () {",
                "        /**",
                "         * Create a height map.",
                "         * @param scalarField {ScalarField} a scalar field for the height values.",
                "         * @param coordConverter {CoordConverter} a coordinate converter between the",
                "         * surface and the scalar field grid.",
                "         */",
                "        function HeightMap(scalarField, coordConverter) {",
                "            this.scalarField = scalarField;",
                "            this.coordConverter = coordConverter;",
                "        }",
                "        /**",
                "         * @param pointX {float} in terrain basis",
                "         * @param pointY {float} in terrain basis",
                "         * @param normal {[float, float, float]} the result",
                "         * @return {[float, float, float]} the result",
                "         */",
                "        HeightMap.prototype.getFieldNormal = function (pointX, pointY, normal) {",
                "            if (!normal) {",
                "                normal = [0, 0, 0];",
                "            }",
                "            var x = this.coordConverter.convertToGridBasisX(pointX);",
                "            var y = this.coordConverter.convertToGridBasisY(pointY);",
                "            var squareX = Math.floor(x);",
                "            var squareY = Math.floor(y);",
                "            if (squareX < 0 ||",
                "                squareY < 0 ||",
                "                squareX >= this.scalarField.dimX() ||",
                "                squareY >= this.scalarField.dimY()) {",
                "                return null;",
                "            }",
                "            // This gives very approximating values on borders",
                "            // but it's the easiest way to avoid to be out of bounds.",
                "            // Why 1 but dim - 3?",
                "            // - 1 margin for the normal calculus on both side",
                "            // - 1 extra because extrapolation asks values on right and bottom.",
                "            if (squareX < 1) {",
                "                squareX = 1;",
                "                x = squareX;",
                "            }",
                "            if (squareX > this.scalarField.dimX() - 3) {",
                "                squareX = this.scalarField.dimX() - 3;",
                "                x = squareX;",
                "            }",
                "            if (squareY < 1) {",
                "                squareY = 1;",
                "                y = squareY;",
                "            }",
                "            if (squareY > this.scalarField.dimY() - 3) {",
                "                squareY = this.scalarField.dimY() - 3;",
                "                y = squareY;",
                "            }",
                "            // Extrapolate",
                "            var weighedValueSumX = 0;",
                "            var weighedValueSumY = 0;",
                "            var weighedValueSumZ = 0;",
                "            for (var vertexX = squareX; vertexX <= squareX + 1; vertexX++) {",
                "                for (var vertexY = squareY; vertexY <= squareY + 1; vertexY++) {",
                "                    normal[0] = 0;",
                "                    normal[1] = 0;",
                "                    normal[2] = 0;",
                "                    this.addGridPointNormal(vertexX, vertexY, normal);",
                "                    var dx = vertexX - x;",
                "                    var dy = vertexY - y;",
                "                    if (dx === 0 && dy === 0) {",
                "                        // Double break, no interpolation needed.",
                "                        vertexX += 2;",
                "                        vertexY += 2;",
                "                    }",
                "                    else {",
                "                        var distance = Math.hypot(dx, dy);",
                "                        weighedValueSumX += normal[0] / distance;",
                "                        weighedValueSumY += normal[1] / distance;",
                "                        weighedValueSumZ += normal[2] / distance;",
                "                    }",
                "                }",
                "            }",
                "            var length = Math.hypot(normal[0], normal[1], normal[2]);",
                "            normal[0] /= length;",
                "            normal[1] /= length;",
                "            normal[2] /= length;",
                "            return normal;",
                "        };",
                "        /**",
                "         * @param pointX {float} in terrain basis",
                "         * @param pointY {float} in terrain basis",
                "         * @return {float} the field value",
                "         */",
                "        HeightMap.prototype.getHeight = function (pointX, pointY) {",
                "            var x = this.coordConverter.convertToGridBasisX(pointX);",
                "            var y = this.coordConverter.convertToGridBasisY(pointY);",
                "            return this.scalarField.extrapolate(x, y);",
                "        };",
                "        /**",
                "         * Evaluate the normal at a given grid point.",
                "         *",
                "         * The normal is not normalized.",
                "         *",
                "         * @param x {integer} grid index",
                "         * @param y {integer} grid index",
                "         * @param normal {[float, float, float]} the result",
                "         */",
                "        HeightMap.prototype.addGridPointNormal = function (x, y, normal) {",
                "            var z = this.scalarField.get(x, y);",
                "            var rightX = 1;",
                "            var rightY = 0;",
                "            var rightZ = this.scalarField.get(x + 1, y) - z;",
                "            var rightLength = Math.hypot(rightX, rightZ);",
                "            rightX /= rightLength;",
                "            rightZ /= rightLength;",
                "            var leftX = -1;",
                "            var leftY = 0;",
                "            var leftZ = this.scalarField.get(x - 1, y) - z;",
                "            var leftLength = Math.hypot(leftX, leftZ);",
                "            leftX /= leftLength;",
                "            leftZ /= leftLength;",
                "            var bottomX = 0;",
                "            var bottomY = 1;",
                "            var bottomZ = this.scalarField.get(x, y + 1) - z;",
                "            var bottomLength = Math.hypot(bottomY, bottomZ);",
                "            bottomY /= bottomLength;",
                "            bottomZ /= bottomLength;",
                "            var topX = 0;",
                "            var topY = -1;",
                "            var topZ = this.scalarField.get(x, y - 1) - z;",
                "            var topLength = Math.hypot(topY, topZ);",
                "            topY /= topLength;",
                "            topZ /= topLength;",
                "            // The mean of the normal of the 4 triangles around the grid point.",
                "            this.addNormal(topX, topY, topZ, rightX, rightY, rightZ, normal);",
                "            this.addNormal(rightX, rightY, rightZ, bottomX, bottomY, bottomZ, normal);",
                "            this.addNormal(bottomX, bottomY, bottomZ, leftX, leftY, leftZ, normal);",
                "            this.addNormal(leftX, leftY, leftZ, topX, topY, topZ, normal);",
                "        };",
                "        /**",
                "         * @param uX {float}",
                "         * @param uY {float}",
                "         * @param uZ {float}",
                "         * @param vX {float}",
                "         * @param vY {float}",
                "         * @param vZ {float}",
                "         * @param normal {[float, float, float]} the result",
                "         */",
                "        HeightMap.prototype.addNormal = function (uX, uY, uZ, vX, vY, vZ, normal) {",
                "            normal[0] += uY * vZ - uZ * vY;",
                "            normal[1] += uZ * vX - uX * vZ;",
                "            normal[2] += uX * vY - uY * vX;",
                "        };",
                "        /**",
                "         * Clear the field by filling it with a give value.",
                "         * @param value {float}",
                "         */",
                "        HeightMap.prototype.clear = function (value) {",
                "            if (value === void 0) { value = 0; }",
                "            this.scalarField.clear(value);",
                "        };",
                "        /**",
                "         * Cap the field between 2 values.",
                "         * @param min {float}",
                "         * @param max {float}",
                "         */",
                "        HeightMap.prototype.clamp = function (min, max) {",
                "            this.scalarField.clamp(min, max);",
                "        };",
                "        /**",
                "         * Apply an affine transformation on each field value.",
                "         * @param a {float} factor",
                "         * @param b {float} offset",
                "         */",
                "        HeightMap.prototype.transform = function (a, b) {",
                "            this.scalarField.transform(a, b);",
                "        };",
                "        /**",
                "         * Merge a disk in the field.",
                "         * @param centerX {float} in terrain basis",
                "         * @param centerY {float} in terrain basis",
                "         * @param radius {float} in terrain basis",
                "         * @param cappingRadiusRatio {float}",
                "         * @param operation {function(float, float):float}",
                "         */",
                "        HeightMap.prototype.mergeDisk = function (centerX, centerY, radius, cappingRadiusRatio, operation) {",
                "            this.scalarField.mergeDisk(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), this.coordConverter.convertToGridBasisDistance(radius), cappingRadiusRatio, operation);",
                "        };",
                "        /**",
                "         * Merge a segment in the field.",
                "         * @param startX {float} in terrain basis",
                "         * @param startY {float} in terrain basis",
                "         * @param endX {float} in terrain basis",
                "         * @param endY {float} in terrain basis",
                "         * @param thickness {float} in terrain basis",
                "         * @param cappingRadiusRatio {float}",
                "         * @param operation {function(float, float):float}",
                "         */",
                "        HeightMap.prototype.mergeSegment = function (startX, startY, endX, endY, thickness, cappingRadiusRatio, operation) {",
                "            this.scalarField.mergeSegment(this.coordConverter.convertToGridBasisX(startX), this.coordConverter.convertToGridBasisY(startY), this.coordConverter.convertToGridBasisX(endX), this.coordConverter.convertToGridBasisY(endY), this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio, operation);",
                "        };",
                "        /**",
                "         * Merge a hill in the field.",
                "         * @param centerX {float} in terrain basis",
                "         * @param centerY {float} in terrain basis",
                "         * @param height {float}",
                "         * @param radius {float} in terrain basis",
                "         * @param opacity {float}",
                "         * @param cappingRadiusRatio {float}",
                "         * @param operation {function(float, float):float}",
                "         */",
                "        HeightMap.prototype.mergeHill = function (centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation) {",
                "            this.scalarField.mergeHill(this.coordConverter.convertToGridBasisX(centerX), this.coordConverter.convertToGridBasisY(centerY), height, this.coordConverter.convertToGridBasisDistance(radius), opacity, cappingRadiusRatio, operation);",
                "        };",
                "        /**",
                "         * Flood an area from a given location until a maximum field value is reached.",
                "         * @param originX {float} in terrain basis",
                "         * @param originY {float} in terrain basis",
                "         * @param valueMax {float}",
                "         * @param thickness {float}",
                "         * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "         * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "         * or a maximum otherwise.",
                "         */",
                "        HeightMap.prototype.fillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "            this.scalarField.fillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);",
                "        };",
                "        /**",
                "         * Flood an area from a given location until a maximum field value is reached.",
                "         * @param originX {float} in terrain basis",
                "         * @param originY {float} in terrain basis",
                "         * @param valueMax {float}",
                "         * @param thickness {float}",
                "         * @param cappingRadiusRatio {float} the radius where to stop the contour shading",
                "         * @param isMinimum {boolean} when set to true, the threshold is a minimum",
                "         * or a maximum otherwise.",
                "         */",
                "        HeightMap.prototype.unfillFrom = function (originX, originY, valueMax, thickness, cappingRadiusRatio) {",
                "            this.scalarField.unfillFrom(this.coordConverter.convertToGridBasisX(originX), this.coordConverter.convertToGridBasisY(originY), valueMax, this.coordConverter.convertToGridBasisDistance(thickness), cappingRadiusRatio);",
                "        };",
                "        return HeightMap;",
                "    }());",
                "",
                "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
                "gdjs.__marchingSquaresExtension.CoordConverter = CoordConverter;",
                "gdjs.__marchingSquaresExtension.HeightMap = HeightMap;",
                "gdjs.__marchingSquaresExtension.MarchingSquares = MarchingSquares;",
                "gdjs.__marchingSquaresExtension.ScalarField = ScalarField;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        },
        {
          "description": "Define helper classes JavaScript code.",
          "fullName": "Define helper classes",
          "functionType": "Action",
          "name": "DefineHelperClasses",
          "private": true,
          "sentence": "Define helper classes JavaScript code",
          "events": [
            {
              "type": "BuiltinCommonInstructions::JsCode",
              "inlineCode": [
                "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
                "",
                "const parseOperation = function (operation) {",
                "switch (operation) {",
                "    case \"Addition\":",
                "    return (value1, value2) => value1 + value2;",
                "    case \"Subtraction\":",
                "    return (value1, value2) => value1 - value2;",
                "    case \"Multiplication\":",
                "    return (value1, value2) => value1 * value2;",
                "    case \"Division\":",
                "    return (value1, value2) => value1 / value2;",
                "    case \"Minimum\":",
                "    return Math.min;",
                "    case \"Maximum\":",
                "    default:",
                "    return Math.max;",
                "}",
                "return;",
                "}",
                "",
                "const HitboxesIterable = /** @class */ (function () {",
                "  /**",
                "   * The hitboxes in a rectangular area.",
                "   * @constructor",
                "         * @param {any} behavior",
                "         * @param {integer} xMin The fist column to include.",
                "         * @param {integer} yMin The fist row to include.",
                "         * @param {integer} xMax The last column to include.",
                "         * @param {integer} yMax The last row to include.",
                "   */",
                "  function HitboxesIterable(",
                "    behavior,",
                "    xMin,",
                "    yMin,",
                "    xMax,",
                "    yMax",
                "  ) {",
                "    this.behavior = behavior;",
                "    this.xMin = xMin;",
                "    this.yMin = yMin;",
                "    this.xMax = xMax;",
                "    this.yMax = yMax;",
                "  };",
                "",
                "  HitboxesIterable.prototype.setBounds = function (",
                "    xMin,",
                "    yMin,",
                "    xMax,",
                "    yMax",
                "  ) {",
                "    this.xMin = xMin;",
                "    this.yMin = yMin;",
                "    this.xMax = xMax;",
                "    this.yMax = yMax;",
                "  }",
                "",
                "  HitboxesIterable.prototype[Symbol.iterator] = function () {",
                "    // xMin and yMin next increment",
                "    let x = this.xMax;",
                "    let y = this.yMin - 1;",
                "    let hitbox = null;",
                "    let previousHitbox = null;",
                "    /** @type {IteratorReturnResult<gdjs.Polygon>} */",
                "    const result = { done: false, value: undefined };",
                "",
                "    return {",
                "      next: () => {",
                "        do {",
                "          x++;",
                "          if (x > this.xMax) {",
                "            y++;",
                "            x = this.xMin;",
                "          }",
                "          if (y > this.yMax) {",
                "            // done",
                "            result.done = true;",
                "            result.value = undefined;",
                "            return result;",
                "          }",
                "          hitbox = this.behavior.getHitbox(x, y);",
                "        }",
                "        while (!hitbox || hitbox === previousHitbox);",
                "",
                "        // happen with run-length encoding",
                "        previousHitbox = hitbox;",
                "        result.done = false;",
                "        result.value = hitbox;",
                "        return result;",
                "      },",
                "    };",
                "  };",
                "    return HitboxesIterable;",
                "}());",
                "",
                "gdjs.__marchingSquaresExtension = gdjs.__marchingSquaresExtension || {};",
                "gdjs.__marchingSquaresExtension.parseOperation = parseOperation;",
                "gdjs.__marchingSquaresExtension.HitboxesIterable = HitboxesIterable;",
                ""
              ],
              "parameterObjects": "",
              "useStrict": true,
              "eventsSheetExpanded": true
            }
          ],
          "parameters": [],
          "objectGroups": []
        }
      ],
      "eventsBasedBehaviors": [
        {
          "description": "Add to a Shape painter object and use the actions to draw a field. Useful for fog of wars, liquid effects (water, lava, blobs...).",
          "fullName": "Marching squares painter",
          "name": "MarchingSquaresBehavior",
          "objectType": "PrimitiveDrawing::Drawer",
          "eventsFunctions": [
            {
              "description": "Extend behavior class",
              "fullName": "Extend behavior class",
              "functionType": "Action",
              "name": "ExtendBehaviorClass",
              "private": true,
              "sentence": "Extend behavior class",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "const prototype = Object.getPrototypeOf(behavior);",
                    "if (!prototype.drawField) {",
                    "",
                    "  prototype.createField = function () {",
                    "    /** @type {float} */",
                    "    const left = this._getAreaLeftBound();",
                    "    /** @type {float} */",
                    "    const top = this._getAreaTopBound();",
                    "    /** @type {float} */",
                    "    const right = this._getAreaRightBound();",
                    "    /** @type {float} */",
                    "    const bottom = this._getAreaBottomBound();",
                    "    /** @type {float} */",
                    "    const cellWidth = this._getCellWidth();",
                    "    /** @type {float} */",
                    "    const cellHeight = this._getCellHeight();",
                    "",
                    "    // Build the scalar field",
                    "    const dimX = 1 + Math.ceil((right - left) / cellWidth);",
                    "    const dimY = 1 + Math.ceil((bottom - top) / cellHeight);",
                    "    const scalarField = new gdjs.__marchingSquaresExtension.ScalarField(dimX, dimY);",
                    "    this.scalarField = scalarField;",
                    "    ",
                    "    const coordConverter = new gdjs.__marchingSquaresExtension.CoordConverter(",
                    "      cellWidth,",
                    "      cellHeight,",
                    "      left,",
                    "      top,",
                    "      right,",
                    "      bottom);",
                    "    this.coordConverter = coordConverter;",
                    "",
                    "    const heightMap = new gdjs.__marchingSquaresExtension.HeightMap(scalarField, coordConverter);",
                    "    this.heightMap = heightMap;",
                    "",
                    "    const marchingSquares = new gdjs.__marchingSquaresExtension.MarchingSquares(scalarField);",
                    "    this.marchingSquares = marchingSquares;",
                    "",
                    "    /** @type {gdjs.Polygon[][]} */",
                    "    const hitboxTiles = new Array(dimY);",
                    "    for (var y = 0; y < dimY; y++) {",
                    "      hitboxTiles[y] = new Array(dimX).fill(null);",
                    "    }",
                    "    this.hitboxTiles = hitboxTiles;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param pointX {float} in scene basis",
                    "   * @param pointY {float} in scene basis",
                    "   * @return {boolean} true if the point is inside the contour",
                    "   */",
                    "  prototype.containsPoint = function (",
                    "    pointX,",
                    "    pointY,",
                    "  ) {",
                    "    /** @type {boolean} */",
                    "    const drawUnder = this._getFillOutside();",
                    "",
                    "    // It's a bit more precise than the contour",
                    "    // so it's not completly accurate.",
                    "    return !drawUnder && this.heightMap.getHeight(pointX, pointY) > this._getThreshold() ||",
                    "      drawUnder && this.heightMap.getHeight(pointX, pointY) < this._getThreshold();",
                    "  }",
                    "",
                    "  /**",
                    "   * Draw the field squares",
                    "   * @param minX {integer} left",
                    "   * @param minY {integer} top",
                    "   * @param maxX {integer} right",
                    "   * @param maxY {integer} bottom",
                    "   */",
                    "  prototype.drawField = function (",
                    "    minX,",
                    "    minY,",
                    "    maxX,",
                    "    maxY",
                    "  ) {",
                    "    /** @type {boolean} */",
                    "    const drawUnder = this._getFillOutside();",
                    "    /** @type {gdjs.ShapePainterRuntimeObject} */",
                    "    const shapePainter = this.owner;",
                    "    /** @type {float} */",
                    "    const threshold = this._getThreshold();",
                    "",
                    "    const fillOpacity = shapePainter.getFillOpacity();",
                    "    const outlineSize = shapePainter.getOutlineSize();",
                    "",
                    "    // It draws bands and small polygons.",
                    "    // The contour line is in a second loop, it's more efficient",
                    "    // than switching the style constantly.",
                    "",
                    "    const that = this;",
                    "    // fill",
                    "    if (fillOpacity !== 0) {",
                    "      shapePainter.setOutlineSize(0);",
                    "      this.marchingSquares.fillContour(",
                    "        minX,",
                    "        minY,",
                    "        maxX,",
                    "        maxY,",
                    "        threshold,",
                    "        drawUnder,",
                    "        {",
                    "          drawRectangle(left, top, right, bottom) {",
                    "            shapePainter.drawRectangle(",
                    "              that.coordConverter.convertFromGridBasisX(left),",
                    "              that.coordConverter.convertFromGridBasisY(top),",
                    "              that.coordConverter.convertFromGridBasisX(right),",
                    "              that.coordConverter.convertFromGridBasisY(bottom));",
                    "          },",
                    "          beginPath(x, y) {",
                    "            shapePainter.beginFillPath(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          lineTo(x, y) {",
                    "            shapePainter.drawPathLineTo(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          closePath() {",
                    "            shapePainter.closePath();",
                    "          },",
                    "          endPath() {",
                    "            shapePainter.endFillPath();",
                    "          },",
                    "          onFilledSquareChange(x, y) {",
                    "",
                    "          }",
                    "        }",
                    "      );",
                    "      shapePainter.setOutlineSize(outlineSize);",
                    "    }",
                    "    // outline",
                    "    if (outlineSize !== 0) {",
                    "      shapePainter.setFillOpacity(0);",
                    "      this.marchingSquares.outlineContour(",
                    "        minX,",
                    "        minY,",
                    "        maxX,",
                    "        maxY,",
                    "        threshold,",
                    "        drawUnder,",
                    "        {",
                    "          drawRectangle(left, top, right, bottom) {",
                    "          },",
                    "          beginPath(x, y) {",
                    "            shapePainter.beginFillPath(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          lineTo(x, y) {",
                    "            shapePainter.drawPathLineTo(",
                    "              that.coordConverter.convertFromGridBasisX(x),",
                    "              that.coordConverter.convertFromGridBasisY(y));",
                    "          },",
                    "          closePath() {",
                    "            shapePainter.closePath();",
                    "          },",
                    "          endPath() {",
                    "            shapePainter.endFillPath();",
                    "          },",
                    "          onFilledSquareChange(x, y) {",
                    "",
                    "          }",
                    "        }",
                    "      );",
                    "    }",
                    "    shapePainter.setFillOpacity(fillOpacity);",
                    "  }",
                    "",
                    "  /**",
                    "   * Update the field hitboxes",
                    "   * @param minX {integer} left",
                    "   * @param minY {integer} top",
                    "   * @param maxX {integer} right",
                    "   * @param maxY {integer} bottom",
                    "   */",
                    "  prototype.updateMarchingSquareHitboxes = function (",
                    "    minX,",
                    "    minY,",
                    "    maxX,",
                    "    maxY",
                    "  ) {",
                    "    /** @type {boolean} */",
                    "    const drawUnder = this._getFillOutside();",
                    "    /** @type {float} */",
                    "    const threshold = this._getThreshold();",
                    "    /** @type {gdjs.ShapePainterRuntimeObject} */",
                    "    const shapePainter = this.owner;",
                    "",
                    "    const point = this.workingPoint;",
                    "",
                    "    // Move all Polygons to recycledPolygons",
                    "    if (this.recycledPolygons.length < shapePainter._defaultHitBoxes.length) {",
                    "      const swapPolygons = this.recycledPolygons;",
                    "      this.recycledPolygons = shapePainter._defaultHitBoxes;",
                    "      shapePainter._defaultHitBoxes = swapPolygons;",
                    "    }",
                    "    const hitboxes = shapePainter._defaultHitBoxes;",
                    "    this.recycledPolygons.push.apply(this, hitboxes);",
                    "    hitboxes.length = 0;",
                    "",
                    "    for (const hitboxRowTiles of this.hitboxTiles) {",
                    "      hitboxRowTiles.fill(null);",
                    "    }",
                    "    /** @type {gdjs.Polygon} */",
                    "    let currentRectangle = null;",
                    "    /** @type {gdjs.Polygon} */",
                    "    let currentPolygon = null;",
                    "    const that = this;",
                    "    this.marchingSquares.fillContour(",
                    "      minX,",
                    "      minY,",
                    "      maxX,",
                    "      maxY,",
                    "      threshold,",
                    "      drawUnder,",
                    "      {",
                    "        drawRectangle(left, top, right, bottom) {",
                    "          left = that.coordConverter.convertFromGridBasisX(left);",
                    "          top = that.coordConverter.convertFromGridBasisY(top);",
                    "          right = that.coordConverter.convertFromGridBasisX(right);",
                    "          bottom = that.coordConverter.convertFromGridBasisY(bottom);",
                    "          const vertices = currentRectangle.vertices;",
                    "",
                    "          vertices.length = 4;",
                    "          vertices[0] || (vertices[0] = [0, 0]);",
                    "          vertices[1] || (vertices[1] = [0, 0]);",
                    "          vertices[2] || (vertices[2] = [0, 0]);",
                    "          vertices[3] || (vertices[3] = [0, 0]);",
                    "",
                    "          vertices[0][0] = left;",
                    "          vertices[0][1] = top;",
                    "",
                    "          vertices[1][0] = right;",
                    "          vertices[1][1] = top;",
                    "",
                    "          vertices[2][0] = right;",
                    "          vertices[2][1] = bottom;",
                    "",
                    "          vertices[3][0] = left;",
                    "          vertices[3][1] = bottom;",
                    "          hitboxes.push(currentRectangle);",
                    "          currentRectangle = null;",
                    "        },",
                    "        beginPath(x, y) {",
                    "          currentPolygon = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();",
                    "          currentPolygon.vertices.length = 0;",
                    "          currentPolygon.vertices.push([",
                    "            that.coordConverter.convertFromGridBasisX(x),",
                    "            that.coordConverter.convertFromGridBasisY(y)]);",
                    "        },",
                    "        lineTo(x, y) {",
                    "          currentPolygon.vertices.push([",
                    "            that.coordConverter.convertFromGridBasisX(x),",
                    "            that.coordConverter.convertFromGridBasisY(y)]);",
                    "        },",
                    "        closePath() {",
                    "        },",
                    "        endPath(squareX, squareY) {",
                    "          hitboxes.push(currentPolygon);",
                    "          that.hitboxTiles[squareY][squareX] = currentPolygon;",
                    "        },",
                    "        onFilledSquareChange(squareX, squareY) {",
                    "          if (!currentRectangle) {",
                    "            currentRectangle = that.recycledPolygons.length === 0 ? new gdjs.Polygon() : that.recycledPolygons.pop();",
                    "          }",
                    "          that.hitboxTiles[squareY][squareX] = currentRectangle;",
                    "        }",
                    "      }",
                    "    );",
                    "",
                    "    shapePainter.hitBoxes = hitboxes;",
                    "    shapePainter.hitBoxesDirty = false;",
                    "    shapePainter.aabb.min[0] = this._getAreaLeftBound();",
                    "    shapePainter.aabb.min[1] = this._getAreaTopBound();",
                    "    shapePainter.aabb.max[0] = shapePainter.aabb.min[0] + (this.scalarField.dimX() - 1) * this._getCellWidth();",
                    "    shapePainter.aabb.max[1] = shapePainter.aabb.min[1] + (this.scalarField.dimY() - 1) * this._getCellHeight();",
                    "  }",
                    "",
                    "  /**",
                    "   * @param squareX {integer} x grid index",
                    "   * @param squareY {integer} y grid index",
                    "   * @return {gdjs.Polygon}",
                    "   */",
                    "  prototype.getHitbox = function (squareX, squareY) {",
                    "    return this.hitboxTiles[squareY][squareX];",
                    "  }",
                    "}",
                    "",
                    "",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Extend object instance prototype.",
              "fullName": "Extend object instance prototype",
              "functionType": "Action",
              "name": "ExtendObjectInstancePrototype",
              "private": true,
              "sentence": "Extend _PARAM0_ prototype",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/**",
                    " * @type {Iterable<gdjs.Polygon>}",
                    " */",
                    "behavior.marchingSquaresHitBoxesIterable = new gdjs.__marchingSquaresExtension.HitboxesIterable(behavior, 0, 0, 0, 0);",
                    "",
                    "/** @type {gdjs.Polygon[]} Avoid allocations when updating hitboxes*/",
                    "behavior.recycledPolygons = [];",
                    "",
                    "behavior.owner.updateHitBoxes = function () {",
                    "  this.hitBoxesDirty = false;",
                    "}",
                    "",
                    "behavior.owner.getHitBoxesAround = function (",
                    "  left,",
                    "  top,",
                    "  right,",
                    "  bottom",
                    ") {",
                    "  const leftIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(left)));",
                    "  const topIndex = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(top)));",
                    "  const rightIndex = Math.min(behavior.scalarField.dimX() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisX(right)));",
                    "  const bottomIndex = Math.min(behavior.scalarField.dimY() - 1, Math.ceil(behavior.coordConverter.convertToGridBasisY(bottom)));",
                    "  /** @type {Iterable<gdjs.Polygon>} */",
                    "  const iterable = behavior.marchingSquaresHitBoxesIterable;",
                    "  iterable.setBounds(leftIndex, topIndex, rightIndex, bottomIndex);",
                    "  return iterable;",
                    "}",
                    ""
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "fullName": "",
              "functionType": "Action",
              "name": "onCreated",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::PropertyAreaRightBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "<=",
                        "Object.Behavior::PropertyAreaLeftBound()"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaRightBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Behavior::AreaLeft() + SceneWindowWidth()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::PropertyAreaBottomBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "<=",
                        "Object.Behavior::PropertyAreaTopBound()"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaBottomBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "Object.Behavior::PropertyAreaBottomBound() + SceneWindowHeight()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GlobalVariableAsBoolean"
                      },
                      "parameters": [
                        "__marchingSquares.IsJavaScriptDefined",
                        "False"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetGlobalVariableAsBoolean"
                      },
                      "parameters": [
                        "__marchingSquares.IsJavaScriptDefined",
                        "True"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::DefineScalarFieldPainterLibrary"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::DefineHelperClasses"
                      },
                      "parameters": [
                        "",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::ExtendBehaviorClass"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::ExtendObjectInstancePrototype"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Clear the field by setting every values to 0.",
              "fullName": "Clear the field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "ClearField",
              "sentence": "Clear the field of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.clear();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Unfill an area of the field from a given location until a given height is reached.",
              "fullName": "Unfill area",
              "functionType": "Action",
              "group": "Field painting",
              "name": "UpsidedownFloodFrom",
              "sentence": "Unfill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a minimum of _PARAM4_ with thickness: _PARAM5_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const originX = eventsFunctionContext.getArgument(\"OriginX\");",
                    "const originY = eventsFunctionContext.getArgument(\"OriginY\");",
                    "const minimum = eventsFunctionContext.getArgument(\"Minimum\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.unfillFrom(originX, originY, minimum, thickness, cappingRadiusRatio);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Origin X",
                  "name": "OriginX",
                  "type": "expression"
                },
                {
                  "description": "Origin Y",
                  "name": "OriginY",
                  "type": "expression"
                },
                {
                  "description": "Minimum height",
                  "name": "Minimum",
                  "type": "expression"
                },
                {
                  "description": "Contour thickness",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Fill an area of the field from a given location until a given height is reached.",
              "fullName": "Fill area",
              "functionType": "Action",
              "group": "Field painting",
              "name": "FloodFrom",
              "sentence": "Fill the field of _PARAM0_ from x: _PARAM2_, y: _PARAM3_, to a maximum of _PARAM4_ with thickness: _PARAM5_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const originX = eventsFunctionContext.getArgument(\"OriginX\");",
                    "const originY = eventsFunctionContext.getArgument(\"OriginY\");",
                    "const maximum = eventsFunctionContext.getArgument(\"Maximum\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.fillFrom(originX, originY, maximum, thickness, cappingRadiusRatio);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Origin X",
                  "name": "OriginX",
                  "type": "expression"
                },
                {
                  "description": "Origin Y",
                  "name": "OriginY",
                  "type": "expression"
                },
                {
                  "description": "Maximum height",
                  "name": "Maximum",
                  "type": "expression"
                },
                {
                  "description": "Contour thickness",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Cap every value of the field to a range.",
              "fullName": "Clamp the field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "ClampField",
              "sentence": "Clamp the field of _PARAM0_ from: _PARAM2_ to: _PARAM3_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const min = eventsFunctionContext.getArgument(\"Minimum\");",
                    "const max = eventsFunctionContext.getArgument(\"Maximum\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.clamp(min, max);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Minimum",
                  "name": "Minimum",
                  "type": "expression"
                },
                {
                  "description": "Maximum",
                  "name": "Maximum",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Apply an affine on the field values.",
              "fullName": "Transform the field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "TransformField",
              "sentence": "Transform the field of _PARAM0_ with a coefficient: _PARAM2_ and an offset: _PARAM3_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const a = eventsFunctionContext.getArgument(\"Coefficient\");",
                    "const b = eventsFunctionContext.getArgument(\"Offset\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.transform(a, b);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Coefficient",
                  "name": "Coefficient",
                  "type": "expression"
                },
                {
                  "description": "Offset",
                  "name": "Offset",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Add a hill to the field.",
              "fullName": "Add a hill",
              "functionType": "Action",
              "group": "Field painting",
              "name": "AddHill",
              "sentence": "Add a hill to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, _PARAM4_, radius: _PARAM5_, opacity: _PARAM6_ using: _PARAM8_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                    "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                    "const height = Math.max(1, eventsFunctionContext.getArgument(\"Height\"));",
                    "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                    "const opacity = eventsFunctionContext.getArgument(\"Opacity\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeHill(centerX, centerY, height, radius, opacity, cappingRadiusRatio, operation);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Center X",
                  "name": "CenterX",
                  "type": "expression"
                },
                {
                  "description": "Center Y",
                  "name": "CenterY",
                  "type": "expression"
                },
                {
                  "description": "Height",
                  "longDescription": "The hill height at the center, a value of 1 or less means a flat hill.",
                  "name": "Height",
                  "type": "expression"
                },
                {
                  "description": "Radius",
                  "longDescription": "The hill height is 1 at this radius.",
                  "name": "Radius",
                  "type": "expression"
                },
                {
                  "description": "Opacity",
                  "longDescription": "Set to 1 to apply the hill instantly or repeat this action with a lower value to make is progressive.",
                  "name": "Opacity",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Add a disk to the field.",
              "fullName": "Add a disk",
              "functionType": "Action",
              "group": "Field painting",
              "name": "AddDisk",
              "sentence": "Add a disk to the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_ using: _PARAM6_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                    "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                    "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, operation);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Center X",
                  "name": "CenterX",
                  "type": "expression"
                },
                {
                  "description": "Center Y",
                  "name": "CenterY",
                  "type": "expression"
                },
                {
                  "description": "Radius",
                  "longDescription": "The spike height is 1 at this radius.",
                  "name": "Radius",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Mask a disk to the field.",
              "fullName": "Mask a disk",
              "functionType": "Action",
              "group": "Field painting",
              "name": "MaskDisk",
              "sentence": "Mask a disk on the field of _PARAM0_ with center: _PARAM2_, _PARAM3_, radius: _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const centerX = eventsFunctionContext.getArgument(\"CenterX\");",
                    "const centerY = eventsFunctionContext.getArgument(\"CenterY\");",
                    "const radius = eventsFunctionContext.getArgument(\"Radius\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const cappingRadius = cappingRadiusRatio * radius;",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeDisk(centerX, centerY, radius, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Center X",
                  "name": "CenterX",
                  "type": "expression"
                },
                {
                  "description": "Center Y",
                  "name": "CenterY",
                  "type": "expression"
                },
                {
                  "description": "Radius",
                  "longDescription": "The spike height is 1 at this radius.",
                  "name": "Radius",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Add a line to the field.",
              "fullName": "Add a line",
              "functionType": "Action",
              "group": "Field painting",
              "name": "AddLine",
              "sentence": "Add a line to the field of _PARAM0_ fom _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with thickness: _PARAM6_ using: _PARAM8_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const startX = eventsFunctionContext.getArgument(\"StartX\");",
                    "const startY = eventsFunctionContext.getArgument(\"StartY\");",
                    "const endX = eventsFunctionContext.getArgument(\"EndX\");",
                    "const endY = eventsFunctionContext.getArgument(\"EndY\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, operation);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the start",
                  "name": "StartX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the start",
                  "name": "StartY",
                  "type": "expression"
                },
                {
                  "description": "X position of the end",
                  "name": "EndX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the end",
                  "name": "EndY",
                  "type": "expression"
                },
                {
                  "description": "Thickness",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Mask a line to the field.",
              "fullName": "Mask a line",
              "functionType": "Action",
              "group": "Field painting",
              "name": "MaskLine",
              "sentence": "Mask a line on the field of _PARAM0_ fom _PARAM2_ ; _PARAM3_ to _PARAM4_ ; _PARAM5_ with thickness: _PARAM6_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const startX = eventsFunctionContext.getArgument(\"StartX\");",
                    "const startY = eventsFunctionContext.getArgument(\"StartY\");",
                    "const endX = eventsFunctionContext.getArgument(\"EndX\");",
                    "const endY = eventsFunctionContext.getArgument(\"EndY\");",
                    "const thickness = eventsFunctionContext.getArgument(\"Thickness\");",
                    "const cappingRadiusRatio = eventsFunctionContext.getArgument(\"CappingRadiusRatio\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.heightMap.mergeSegment(startX, startY, endX, endY, thickness, cappingRadiusRatio, (fieldValue, value) => Math.min(fieldValue, 1 / value));"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the start",
                  "name": "StartX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the start",
                  "name": "StartY",
                  "type": "expression"
                },
                {
                  "description": "X position of the end",
                  "name": "EndX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the end",
                  "name": "EndY",
                  "type": "expression"
                },
                {
                  "description": "Thickness",
                  "longDescription": "The spike height is 1 at this radius.",
                  "name": "Thickness",
                  "type": "expression"
                },
                {
                  "description": "Capping radius ratio",
                  "longDescription": "Small values allow quicker process, but can result to tearing. Try values around 8.",
                  "name": "CappingRadiusRatio",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Apply a given operation on every value of the field using the value from the other field at the same position.",
              "fullName": "Merge a field",
              "functionType": "Action",
              "group": "Field operation",
              "name": "MergeField",
              "sentence": "Merge _PARAM0_ with the field of _PARAM2_ using: _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const fieldObjects = eventsFunctionContext.getObjects(\"FieldObject\");",
                    "const fieldBehaviorName = eventsFunctionContext.getArgument(\"FieldBehavior\");",
                    "const operation = gdjs.__marchingSquaresExtension.parseOperation(eventsFunctionContext.getArgument(\"Operation\"));",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/** @type {Array<number[]>} */",
                    "const fieldValues = behavior.scalarFieldValues;",
                    "",
                    "for (const fieldObject of fieldObjects) {",
                    "    const otherBehavior = fieldObject.getBehavior(behaviorName);",
                    "    if (!otherBehavior) {",
                    "        continue;",
                    "    }",
                    "    behavior.scalarField.mergeField(otherBehavior.scalarField, operation);",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Field object",
                  "name": "FieldObject",
                  "type": "objectList"
                },
                {
                  "description": "Field behavior",
                  "name": "FieldBehavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Operation",
                  "name": "Operation",
                  "supplementaryInformation": "[\"Maximum\",\"Addition\",\"Subtraction\",\"Minimum\",\"Multiplication\",\"Division\"]",
                  "type": "stringWithSelector"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Update the field hitboxes.",
              "fullName": "Update hitboxes",
              "functionType": "Action",
              "group": "Field evaluation",
              "name": "UpdateHitboxes",
              "sentence": "Update the field hitboxes of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "behavior.updateMarchingSquareHitboxes(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Draw the field contours.",
              "fullName": "Draw the contours",
              "functionType": "Action",
              "group": "Field evaluation",
              "name": "DrawField",
              "sentence": "Draw the field contours of _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const screenWidth = runtimeScene.getGame().getGameResolutionWidth();",
                    "const screenHeight = runtimeScene.getGame().getGameResolutionHeight();",
                    "",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const object = objects[0];",
                    "const behavior = object.getBehavior(behaviorName);",
                    "",
                    "if (behavior._behaviorData.MustOnlyDrawScreen) {",
                    "    const layer = runtimeScene.getLayer(object.getLayer());",
                    "    const screen1 = layer.convertCoords(0, 0);",
                    "    const screen2 = layer.convertCoords(screenWidth, 0);",
                    "    const screen3 = layer.convertCoords(0, screenHeight);",
                    "    const screen4 = layer.convertCoords(screenWidth, screenHeight);",
                    "",
                    "    const screenLeft = Math.min(screen1[0], screen2[0], screen3[0], screen4[0]);",
                    "    const screenTop = Math.min(screen1[1], screen2[1], screen3[1], screen4[1]);",
                    "    const screenRight = Math.max(screen1[0], screen2[0], screen3[0], screen4[0]);",
                    "    const screenBottom = Math.max(screen1[1], screen2[1], screen3[1], screen4[1]);",
                    "",
                    "    const minX = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisX(screenLeft)));",
                    "    const minY = Math.max(0, Math.floor(behavior.coordConverter.convertToGridBasisY(screenTop)));",
                    "",
                    "    const maxX = Math.min(behavior.scalarField.dimX(), 1 + Math.ceil(behavior.coordConverter.convertToGridBasisX(screenRight)));",
                    "    const maxY = Math.min(behavior.scalarField.dimY(), 1 + Math.ceil(behavior.coordConverter.convertToGridBasisY(screenBottom)));",
                    "",
                    "    behavior.drawField(minX, minY, maxX, maxY);",
                    "}",
                    "else {",
                    "    // This is useful for static content or games without scrolling.",
                    "    behavior.drawField(0, 0, behavior.scalarField.dimX(), behavior.scalarField.dimY());",
                    "}"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the width of the field cells.",
              "fullName": "Width of the cells",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetCellWidth",
              "sentence": "Change the width of the field cells of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyCellWidth"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"CellWidth\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "CellWidth",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the height of the field cells.",
              "fullName": "Height of the cells",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetCellHeight",
              "sentence": "Change the height of the field cells of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyCellHeight"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"CellHeight\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::RebuildField"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        ""
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "CellHeight",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Rebuild the field with the new dimensions.",
              "fullName": "Rebuild the field",
              "functionType": "Action",
              "name": "RebuildField",
              "private": true,
              "sentence": "Rebuild the field _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const game = runtimeScene.getGame();",
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "/** @type {float} */",
                    "const left = behavior._getAreaLeftBound();",
                    "/** @type {float} */",
                    "const top = behavior._getAreaTopBound();",
                    "/** @type {float} */",
                    "const right = behavior._getAreaRightBound() || game.getGameResolutionWidth();",
                    "/** @type {float} */",
                    "const bottom = behavior._getAreaBottomBound() || game.getGameResolutionHeight();",
                    "/** @type {float} */",
                    "const cellWidth = behavior._getCellWidth();",
                    "/** @type {float} */",
                    "const cellHeight = behavior._getCellHeight();",
                    "",
                    "behavior.createField();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Fill outside or inside of the contours.",
              "fullName": "Fill outside",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetFillOutside",
              "sentence": "Fill outside of the contours of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyFillOutside"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "="
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "GetArgumentAsBoolean"
                      },
                      "parameters": [
                        "\"FillOutside\""
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyFillOutside"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "yes"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Fill outside?",
                  "name": "FillOutside",
                  "type": "yesorno"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the contour threshold.",
              "fullName": "Contour threshold",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetThreshold",
              "sentence": "Change the contour threshold of _PARAM0_: _PARAM2_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyThreshold"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"Threshold\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Value",
                  "name": "Threshold",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the field area bounds.",
              "fullName": "Area bounds",
              "functionType": "Action",
              "group": "Field configuration",
              "name": "SetAreaBounds",
              "sentence": "Change the field area bounds of _PARAM0_ left: _PARAM2_ top: _PARAM3_ right: _PARAM4_ bottom: _PARAM5_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaLeftBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"LeftBound\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaTopBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"TopBound\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaRightBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"RightBound\")"
                      ]
                    },
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::SetPropertyAreaBottomBound"
                      },
                      "parameters": [
                        "Object",
                        "Behavior",
                        "=",
                        "GetArgumentAsNumber(\"BottomBound\")"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "Left bound",
                  "name": "LeftBound",
                  "type": "expression"
                },
                {
                  "description": "Top bound",
                  "name": "TopBound",
                  "type": "expression"
                },
                {
                  "description": "Right bound",
                  "name": "RightBound",
                  "type": "expression"
                },
                {
                  "description": "Bottom bound",
                  "name": "BottomBound",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area left bound of the field.",
              "fullName": "Area left",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaLeft",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaLeftBound()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area top bound of the field.",
              "fullName": "Area top",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaTop",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaTopBound()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area right bound of the field.",
              "fullName": "Area right",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaRight",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaRightBound()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Egal"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaLeftBound()",
                        "=",
                        "Object.Behavior::PropertyAreaRightBound()"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaLeftBound() + SceneWindowWidth()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Area bottom bound of the field.",
              "fullName": "Area bottom",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "AreaBottom",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaBottomBound()"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "Egal"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaTopBound()",
                        "=",
                        "Object.Behavior::PropertyAreaBottomBound()"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyAreaTopBound() + SceneWindowHeight()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Width of the field cells.",
              "fullName": "Width of a cell",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "CellWidth",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyCellWidth()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Height of the field cells.",
              "fullName": "Height of a cell",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "CellHeight",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyCellHeight()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The number of cells on the x axis.",
              "fullName": "Dimension X",
              "functionType": "Expression",
              "group": "Field saving",
              "name": "DimensionX",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.dimX();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The number of cells on the y axis.",
              "fullName": "Dimension Y",
              "functionType": "Expression",
              "group": "Field saving",
              "name": "DimensionY",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.dimY();"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The contour threshold.",
              "fullName": "Contour threshold",
              "functionType": "Expression",
              "group": "Field configuration",
              "name": "ContourThreshold",
              "sentence": "",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnNumber"
                      },
                      "parameters": [
                        "Object.Behavior::PropertyThreshold()"
                      ]
                    }
                  ]
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The normal X coordinate at a given location.",
              "fullName": "Normal X",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "NormalX",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[0];"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The normal Y coordinate at a given location.",
              "fullName": "Normal Y",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "NormalY",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[1];"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The normal Z coordinate at a given location.",
              "fullName": "Normal Z",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "NormalZ",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getFieldNormal(pointX, pointY)[2];"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Change the field value at a grid point.",
              "fullName": "Grid value",
              "functionType": "Action",
              "group": "Field loading",
              "name": "SetGridValue",
              "sentence": "Change the field value of _PARAM0_ at the grid point _PARAM2_; _PARAM3_ to _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                    "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.set(indexX, indexY, value);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X grid index",
                  "name": "IndexX",
                  "type": "expression"
                },
                {
                  "description": "Y grid index",
                  "name": "IndexY",
                  "type": "expression"
                },
                {
                  "description": "Field value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The field value at a grid point.",
              "fullName": "Grid value",
              "functionType": "Expression",
              "group": "Field saving",
              "name": "GridValue",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const indexX = eventsFunctionContext.getArgument(\"IndexX\");",
                    "const indexY = eventsFunctionContext.getArgument(\"IndexY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.scalarField.get(indexX, indexY);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X grid index",
                  "name": "IndexX",
                  "type": "expression"
                },
                {
                  "description": "Y grid index",
                  "name": "IndexY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "The field value at a given location.",
              "fullName": "Field value",
              "functionType": "Expression",
              "group": "Field evaluation",
              "name": "FieldValue",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "expressionType": {
                "type": "expression"
              },
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if the contours are filled outside.",
              "fullName": "Fill outside",
              "functionType": "Condition",
              "group": "Field configuration",
              "name": "CheckFillOutside",
              "sentence": "The contours of _PARAM0_ are filled outside",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "False"
                      ]
                    }
                  ]
                },
                {
                  "type": "BuiltinCommonInstructions::Standard",
                  "conditions": [
                    {
                      "type": {
                        "value": "MarchingSquares::MarchingSquaresBehavior::PropertyFillOutside"
                      },
                      "parameters": [
                        "Object",
                        "Behavior"
                      ]
                    }
                  ],
                  "actions": [
                    {
                      "type": {
                        "value": "SetReturnBoolean"
                      },
                      "parameters": [
                        "True"
                      ]
                    }
                  ]
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if a field is greater than a given value.",
              "fullName": "Field value",
              "functionType": "Condition",
              "group": "Field evaluation",
              "name": "CheckFieldValue",
              "sentence": "At _PARAM2_; _PARAM3_ the field value of _PARAM0_ is greater than _PARAM4_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "const value = eventsFunctionContext.getArgument(\"Value\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.heightMap.getHeight(pointX, pointY) > value;"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                },
                {
                  "description": "Value",
                  "name": "Value",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            },
            {
              "description": "Check if a point is inside the contour.",
              "fullName": "Point is inside",
              "functionType": "Condition",
              "group": "Field evaluation",
              "name": "ContainsPoint",
              "sentence": "_PARAM2_; _PARAM3_ is inside _PARAM0_",
              "events": [
                {
                  "type": "BuiltinCommonInstructions::JsCode",
                  "inlineCode": [
                    "const behaviorName = eventsFunctionContext.getBehaviorName(\"Behavior\");",
                    "",
                    "const pointX = eventsFunctionContext.getArgument(\"PointX\");",
                    "const pointY = eventsFunctionContext.getArgument(\"PointY\");",
                    "",
                    "const behavior = objects[0].getBehavior(behaviorName);",
                    "",
                    "eventsFunctionContext.returnValue = behavior.containsPoint(pointX, pointY);"
                  ],
                  "parameterObjects": "Object",
                  "useStrict": true,
                  "eventsSheetExpanded": true
                }
              ],
              "parameters": [
                {
                  "description": "Object",
                  "name": "Object",
                  "supplementaryInformation": "PrimitiveDrawing::Drawer",
                  "type": "object"
                },
                {
                  "description": "Behavior",
                  "name": "Behavior",
                  "supplementaryInformation": "MarchingSquares::MarchingSquaresBehavior",
                  "type": "behavior"
                },
                {
                  "description": "X position of the point",
                  "name": "PointX",
                  "type": "expression"
                },
                {
                  "description": "Y position of the point",
                  "name": "PointY",
                  "type": "expression"
                }
              ],
              "objectGroups": []
            }
          ],
          "propertyDescriptors": [
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area left bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaLeftBound"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area top bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaTopBound"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area right bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaRightBound"
            },
            {
              "value": "0",
              "type": "Number",
              "unit": "Pixel",
              "label": "Area bottom bound",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "AreaBottomBound"
            },
            {
              "value": "20",
              "type": "Number",
              "unit": "Pixel",
              "label": "Cell width",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "CellWidth"
            },
            {
              "value": "20",
              "type": "Number",
              "unit": "Pixel",
              "label": "Cell height",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "CellHeight"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Fill outside",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "FillOutside"
            },
            {
              "value": "1",
              "type": "Number",
              "unit": "Dimensionless",
              "label": "Contour threshold",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "Threshold"
            },
            {
              "value": "",
              "type": "Boolean",
              "label": "Must only draw what is on the screen",
              "description": "",
              "group": "",
              "extraInformation": [],
              "name": "MustOnlyDrawScreen"
            }
          ],
          "sharedPropertyDescriptors": []
        }
      ],
      "eventsBasedObjects": []
    }
  ],
  "externalLayouts": [],
  "externalSourceFiles": []
}